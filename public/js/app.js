/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var uikit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uikit */ "./node_modules/uikit/dist/js/uikit.js");
/* harmony import */ var uikit__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uikit__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./resources/style/app.scss":
/*!**********************************!*\
  !*** ./resources/style/app.scss ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvc3R5bGUvYXBwLnNjc3MuanMiLCJtYXBwaW5ncyI6IjtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3N0eWxlL2FwcC5zY3NzPzg0MDEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/style/app.scss\n");

/***/ }),

/***/ "./node_modules/uikit/dist/js/uikit.js":
/*!*********************************************!*\
  !*** ./node_modules/uikit/dist/js/uikit.js ***!
  \*********************************************/
/***/ (function(module) {

eval("/*! UIkit 3.15.10 | https://www.getuikit.com | (c) 2014 - 2022 YOOtheme | MIT License */\n\n(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n})(this, (function () { 'use strict';\n\n    const { hasOwnProperty, toString } = Object.prototype;\n\n    function hasOwn(obj, key) {\n      return hasOwnProperty.call(obj, key);\n    }\n\n    const hyphenateRe = /\\B([A-Z])/g;\n\n    const hyphenate = memoize((str) => str.replace(hyphenateRe, '-$1').toLowerCase());\n\n    const camelizeRe = /-(\\w)/g;\n\n    const camelize = memoize((str) => str.replace(camelizeRe, toUpper));\n\n    const ucfirst = memoize((str) =>\n    str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : '');\n\n\n    function toUpper(_, c) {\n      return c ? c.toUpperCase() : '';\n    }\n\n    function startsWith(str, search) {\n      return str == null ? void 0 : str.startsWith == null ? void 0 : str.startsWith(search);\n    }\n\n    function endsWith(str, search) {\n      return str == null ? void 0 : str.endsWith == null ? void 0 : str.endsWith(search);\n    }\n\n    function includes(obj, search) {\n      return obj == null ? void 0 : obj.includes == null ? void 0 : obj.includes(search);\n    }\n\n    function findIndex(array, predicate) {\n      return array == null ? void 0 : array.findIndex == null ? void 0 : array.findIndex(predicate);\n    }\n\n    const { isArray, from: toArray } = Array;\n    const { assign } = Object;\n\n    function isFunction(obj) {\n      return typeof obj === 'function';\n    }\n\n    function isObject(obj) {\n      return obj !== null && typeof obj === 'object';\n    }\n\n    function isPlainObject(obj) {\n      return toString.call(obj) === '[object Object]';\n    }\n\n    function isWindow(obj) {\n      return isObject(obj) && obj === obj.window;\n    }\n\n    function isDocument(obj) {\n      return nodeType(obj) === 9;\n    }\n\n    function isNode(obj) {\n      return nodeType(obj) >= 1;\n    }\n\n    function isElement(obj) {\n      return nodeType(obj) === 1;\n    }\n\n    function nodeType(obj) {\n      return !isWindow(obj) && isObject(obj) && obj.nodeType;\n    }\n\n    function isBoolean(value) {\n      return typeof value === 'boolean';\n    }\n\n    function isString(value) {\n      return typeof value === 'string';\n    }\n\n    function isNumber(value) {\n      return typeof value === 'number';\n    }\n\n    function isNumeric(value) {\n      return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));\n    }\n\n    function isEmpty(obj) {\n      return !(isArray(obj) ? obj.length : isObject(obj) ? Object.keys(obj).length : false);\n    }\n\n    function isUndefined(value) {\n      return value === void 0;\n    }\n\n    function toBoolean(value) {\n      return isBoolean(value) ?\n      value :\n      value === 'true' || value === '1' || value === '' ?\n      true :\n      value === 'false' || value === '0' ?\n      false :\n      value;\n    }\n\n    function toNumber(value) {\n      const number = Number(value);\n      return isNaN(number) ? false : number;\n    }\n\n    function toFloat(value) {\n      return parseFloat(value) || 0;\n    }\n\n    function toNode(element) {\n      return toNodes(element)[0];\n    }\n\n    function toNodes(element) {\n      return element && (isNode(element) ? [element] : Array.from(element).filter(isNode)) || [];\n    }\n\n    function toWindow(element) {var _element;\n      if (isWindow(element)) {\n        return element;\n      }\n\n      element = toNode(element);\n      const document = isDocument(element) ? element : (_element = element) == null ? void 0 : _element.ownerDocument;\n\n      return (document == null ? void 0 : document.defaultView) || window;\n    }\n\n    function isEqual(value, other) {\n      return (\n        value === other ||\n        isObject(value) &&\n        isObject(other) &&\n        Object.keys(value).length === Object.keys(other).length &&\n        each(value, (val, key) => val === other[key]));\n\n    }\n\n    function swap(value, a, b) {\n      return value.replace(new RegExp(a + \"|\" + b, 'g'), (match) => match === a ? b : a);\n    }\n\n    function last(array) {\n      return array[array.length - 1];\n    }\n\n    function each(obj, cb) {\n      for (const key in obj) {\n        if (false === cb(obj[key], key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    function sortBy$1(array, prop) {\n      return array.\n      slice().\n      sort((_ref, _ref2) => {let { [prop]: propA = 0 } = _ref;let { [prop]: propB = 0 } = _ref2;return (\n          propA > propB ? 1 : propB > propA ? -1 : 0);});\n\n    }\n\n    function uniqueBy(array, prop) {\n      const seen = new Set();\n      return array.filter((_ref3) => {let { [prop]: check } = _ref3;return seen.has(check) ? false : seen.add(check);});\n    }\n\n    function clamp(number, min, max) {if (min === void 0) {min = 0;}if (max === void 0) {max = 1;}\n      return Math.min(Math.max(toNumber(number) || 0, min), max);\n    }\n\n    function noop() {}\n\n    function intersectRect() {for (var _len = arguments.length, rects = new Array(_len), _key = 0; _key < _len; _key++) {rects[_key] = arguments[_key];}\n      return [\n      ['bottom', 'top'],\n      ['right', 'left']].\n      every(\n      (_ref4) => {let [minProp, maxProp] = _ref4;return (\n          Math.min(...rects.map((_ref5) => {let { [minProp]: min } = _ref5;return min;})) -\n          Math.max(...rects.map((_ref6) => {let { [maxProp]: max } = _ref6;return max;})) >\n          0);});\n\n    }\n\n    function pointInRect(point, rect) {\n      return (\n        point.x <= rect.right &&\n        point.x >= rect.left &&\n        point.y <= rect.bottom &&\n        point.y >= rect.top);\n\n    }\n\n    function ratio(dimensions, prop, value) {\n      const aProp = prop === 'width' ? 'height' : 'width';\n\n      return {\n        [aProp]: dimensions[prop] ?\n        Math.round(value * dimensions[aProp] / dimensions[prop]) :\n        dimensions[aProp],\n        [prop]: value };\n\n    }\n\n    function contain(dimensions, maxDimensions) {\n      dimensions = { ...dimensions };\n\n      for (const prop in dimensions) {\n        dimensions =\n        dimensions[prop] > maxDimensions[prop] ?\n        ratio(dimensions, prop, maxDimensions[prop]) :\n        dimensions;\n      }\n\n      return dimensions;\n    }\n\n    function cover$1(dimensions, maxDimensions) {\n      dimensions = contain(dimensions, maxDimensions);\n\n      for (const prop in dimensions) {\n        dimensions =\n        dimensions[prop] < maxDimensions[prop] ?\n        ratio(dimensions, prop, maxDimensions[prop]) :\n        dimensions;\n      }\n\n      return dimensions;\n    }\n\n    const Dimensions = { ratio, contain, cover: cover$1 };\n\n    function getIndex(i, elements, current, finite) {if (current === void 0) {current = 0;}if (finite === void 0) {finite = false;}\n      elements = toNodes(elements);\n\n      const { length } = elements;\n\n      if (!length) {\n        return -1;\n      }\n\n      i = isNumeric(i) ?\n      toNumber(i) :\n      i === 'next' ?\n      current + 1 :\n      i === 'previous' ?\n      current - 1 :\n      elements.indexOf(toNode(i));\n\n      if (finite) {\n        return clamp(i, 0, length - 1);\n      }\n\n      i %= length;\n\n      return i < 0 ? i + length : i;\n    }\n\n    function memoize(fn) {\n      const cache = Object.create(null);\n      return (key) => cache[key] || (cache[key] = fn(key));\n    }\n\n    class Deferred {\n      constructor() {\n        this.promise = new Promise((resolve, reject) => {\n          this.reject = reject;\n          this.resolve = resolve;\n        });\n      }}\n\n    function attr(element, name, value) {\n      if (isObject(name)) {\n        for (const key in name) {\n          attr(element, key, name[key]);\n        }\n        return;\n      }\n\n      if (isUndefined(value)) {var _toNode;\n        return (_toNode = toNode(element)) == null ? void 0 : _toNode.getAttribute(name);\n      } else {\n        for (const el of toNodes(element)) {\n          if (isFunction(value)) {\n            value = value.call(el, attr(el, name));\n          }\n\n          if (value === null) {\n            removeAttr(el, name);\n          } else {\n            el.setAttribute(name, value);\n          }\n        }\n      }\n    }\n\n    function hasAttr(element, name) {\n      return toNodes(element).some((element) => element.hasAttribute(name));\n    }\n\n    function removeAttr(element, name) {\n      const elements = toNodes(element);\n      for (const attribute of name.split(' ')) {\n        for (const element of elements) {\n          element.removeAttribute(attribute);\n        }\n      }\n    }\n\n    function data(element, attribute) {\n      for (const name of [attribute, \"data-\" + attribute]) {\n        if (hasAttr(element, name)) {\n          return attr(element, name);\n        }\n      }\n    }\n\n    const voidElements = {\n      area: true,\n      base: true,\n      br: true,\n      col: true,\n      embed: true,\n      hr: true,\n      img: true,\n      input: true,\n      keygen: true,\n      link: true,\n      menuitem: true,\n      meta: true,\n      param: true,\n      source: true,\n      track: true,\n      wbr: true };\n\n    function isVoidElement(element) {\n      return toNodes(element).some((element) => voidElements[element.tagName.toLowerCase()]);\n    }\n\n    function isVisible(element) {\n      return toNodes(element).some(\n      (element) => element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n\n    }\n\n    const selInput = 'input,select,textarea,button';\n    function isInput(element) {\n      return toNodes(element).some((element) => matches(element, selInput));\n    }\n\n    const selFocusable = selInput + \",a[href],[tabindex]\";\n    function isFocusable(element) {\n      return matches(element, selFocusable);\n    }\n\n    function parent(element) {var _toNode;\n      return (_toNode = toNode(element)) == null ? void 0 : _toNode.parentElement;\n    }\n\n    function filter$1(element, selector) {\n      return toNodes(element).filter((element) => matches(element, selector));\n    }\n\n    function matches(element, selector) {\n      return toNodes(element).some((element) => element.matches(selector));\n    }\n\n    function closest(element, selector) {\n      return isElement(element) ?\n      element.closest(startsWith(selector, '>') ? selector.slice(1) : selector) :\n      toNodes(element).\n      map((element) => closest(element, selector)).\n      filter(Boolean);\n    }\n\n    function within(element, selector) {\n      return isString(selector) ?\n      !!closest(element, selector) :\n      toNode(selector).contains(toNode(element));\n    }\n\n    function parents(element, selector) {\n      const elements = [];\n\n      while (element = parent(element)) {\n        if (!selector || matches(element, selector)) {\n          elements.push(element);\n        }\n      }\n\n      return elements;\n    }\n\n    function children(element, selector) {\n      element = toNode(element);\n      const children = element ? toNodes(element.children) : [];\n      return selector ? filter$1(children, selector) : children;\n    }\n\n    function index(element, ref) {\n      return ref ? toNodes(element).indexOf(toNode(ref)) : children(parent(element)).indexOf(element);\n    }\n\n    function query(selector, context) {\n      return find(selector, getContext(selector, context));\n    }\n\n    function queryAll(selector, context) {\n      return findAll(selector, getContext(selector, context));\n    }\n\n    function find(selector, context) {\n      return toNode(_query(selector, context, 'querySelector'));\n    }\n\n    function findAll(selector, context) {\n      return toNodes(_query(selector, context, 'querySelectorAll'));\n    }\n\n    const contextSelectorRe = /(^|[^\\\\],)\\s*[!>+~-]/;\n    const isContextSelector = memoize((selector) => selector.match(contextSelectorRe));\n\n    function getContext(selector, context) {if (context === void 0) {context = document;}\n      return isString(selector) && isContextSelector(selector) || isDocument(context) ?\n      context :\n      context.ownerDocument;\n    }\n\n    const contextSanitizeRe = /([!>+~-])(?=\\s+[!>+~-]|\\s*$)/g;\n    const sanatize = memoize((selector) => selector.replace(contextSanitizeRe, '$1 *'));\n\n    function _query(selector, context, queryFn) {if (context === void 0) {context = document;}\n      if (!selector || !isString(selector)) {\n        return selector;\n      }\n\n      selector = sanatize(selector);\n\n      if (isContextSelector(selector)) {\n        const split = splitSelector(selector);\n        selector = '';\n        for (let sel of split) {\n          let ctx = context;\n\n          if (sel[0] === '!') {\n            const selectors = sel.substr(1).trim().split(' ');\n            ctx = closest(parent(context), selectors[0]);\n            sel = selectors.slice(1).join(' ').trim();\n            if (!sel.length && split.length === 1) {\n              return ctx;\n            }\n          }\n\n          if (sel[0] === '-') {\n            const selectors = sel.substr(1).trim().split(' ');\n            const prev = (ctx || context).previousElementSibling;\n            ctx = matches(prev, sel.substr(1)) ? prev : null;\n            sel = selectors.slice(1).join(' ');\n          }\n\n          if (ctx) {\n            selector += \"\" + (selector ? ',' : '') + domPath(ctx) + \" \" + sel;\n          }\n        }\n\n        context = document;\n      }\n\n      try {\n        return context[queryFn](selector);\n      } catch (e) {\n        return null;\n      }\n    }\n\n    const selectorRe = /.*?[^\\\\](?:,|$)/g;\n\n    const splitSelector = memoize((selector) =>\n    selector.match(selectorRe).map((selector) => selector.replace(/,$/, '').trim()));\n\n\n    function domPath(element) {\n      const names = [];\n      while (element.parentNode) {\n        const id = attr(element, 'id');\n        if (id) {\n          names.unshift(\"#\" + escape(id));\n          break;\n        } else {\n          let { tagName } = element;\n          if (tagName !== 'HTML') {\n            tagName += \":nth-child(\" + (index(element) + 1) + \")\";\n          }\n          names.unshift(tagName);\n          element = element.parentNode;\n        }\n      }\n      return names.join(' > ');\n    }\n\n    function escape(css) {\n      return isString(css) ? CSS.escape(css) : '';\n    }\n\n    function on() {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}\n      let [targets, types, selector, listener, useCapture = false] = getArgs(args);\n\n      if (listener.length > 1) {\n        listener = detail(listener);\n      }\n\n      if (useCapture != null && useCapture.self) {\n        listener = selfFilter(listener);\n      }\n\n      if (selector) {\n        listener = delegate(selector, listener);\n      }\n\n      for (const type of types) {\n        for (const target of targets) {\n          target.addEventListener(type, listener, useCapture);\n        }\n      }\n\n      return () => off(targets, types, listener, useCapture);\n    }\n\n    function off() {for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {args[_key2] = arguments[_key2];}\n      let [targets, types,, listener, useCapture = false] = getArgs(args);\n      for (const type of types) {\n        for (const target of targets) {\n          target.removeEventListener(type, listener, useCapture);\n        }\n      }\n    }\n\n    function once() {for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {args[_key3] = arguments[_key3];}\n      const [element, types, selector, listener, useCapture = false, condition] = getArgs(args);\n      const off = on(\n      element,\n      types,\n      selector,\n      (e) => {\n        const result = !condition || condition(e);\n        if (result) {\n          off();\n          listener(e, result);\n        }\n      },\n      useCapture);\n\n\n      return off;\n    }\n\n    function trigger(targets, event, detail) {\n      return toEventTargets(targets).every((target) =>\n      target.dispatchEvent(createEvent(event, true, true, detail)));\n\n    }\n\n    function createEvent(e, bubbles, cancelable, detail) {if (bubbles === void 0) {bubbles = true;}if (cancelable === void 0) {cancelable = false;}\n      if (isString(e)) {\n        e = new CustomEvent(e, { bubbles, cancelable, detail });\n      }\n\n      return e;\n    }\n\n    function getArgs(args) {\n      // Event targets\n      args[0] = toEventTargets(args[0]);\n\n      // Event types\n      if (isString(args[1])) {\n        args[1] = args[1].split(' ');\n      }\n\n      // Delegate?\n      if (isFunction(args[2])) {\n        args.splice(2, 0, false);\n      }\n\n      return args;\n    }\n\n    function delegate(selector, listener) {\n      return (e) => {\n        const current =\n        selector[0] === '>' ?\n        findAll(selector, e.currentTarget).\n        reverse().\n        filter((element) => within(e.target, element))[0] :\n        closest(e.target, selector);\n\n        if (current) {\n          e.current = current;\n          listener.call(this, e);\n        }\n      };\n    }\n\n    function detail(listener) {\n      return (e) => isArray(e.detail) ? listener(e, ...e.detail) : listener(e);\n    }\n\n    function selfFilter(listener) {\n      return function (e) {\n        if (e.target === e.currentTarget || e.target === e.current) {\n          return listener.call(null, e);\n        }\n      };\n    }\n\n    function isEventTarget(target) {\n      return target && 'addEventListener' in target;\n    }\n\n    function toEventTarget(target) {\n      return isEventTarget(target) ? target : toNode(target);\n    }\n\n    function toEventTargets(target) {\n      return isArray(target) ?\n      target.map(toEventTarget).filter(Boolean) :\n      isString(target) ?\n      findAll(target) :\n      isEventTarget(target) ?\n      [target] :\n      toNodes(target);\n    }\n\n    function isTouch(e) {\n      return e.pointerType === 'touch' || !!e.touches;\n    }\n\n    function getEventPos(e) {var _e$touches, _e$changedTouches;\n      const { clientX: x, clientY: y } = ((_e$touches = e.touches) == null ? void 0 : _e$touches[0]) || ((_e$changedTouches = e.changedTouches) == null ? void 0 : _e$changedTouches[0]) || e;\n\n      return { x, y };\n    }\n\n    function ajax(url, options) {\n      const env = {\n        data: null,\n        method: 'GET',\n        headers: {},\n        xhr: new XMLHttpRequest(),\n        beforeSend: noop,\n        responseType: '',\n        ...options };\n\n      return Promise.resolve().\n      then(() => env.beforeSend(env)).\n      then(() => send(url, env));\n    }\n\n    function send(url, env) {\n      return new Promise((resolve, reject) => {\n        const { xhr } = env;\n\n        for (const prop in env) {\n          if (prop in xhr) {\n            try {\n              xhr[prop] = env[prop];\n            } catch (e) {\n              // noop\n            }\n          }\n        }\n\n        xhr.open(env.method.toUpperCase(), url);\n\n        for (const header in env.headers) {\n          xhr.setRequestHeader(header, env.headers[header]);\n        }\n\n        on(xhr, 'load', () => {\n          if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n            resolve(xhr);\n          } else {\n            reject(\n            assign(Error(xhr.statusText), {\n              xhr,\n              status: xhr.status }));\n\n\n          }\n        });\n\n        on(xhr, 'error', () => reject(assign(Error('Network Error'), { xhr })));\n        on(xhr, 'timeout', () => reject(assign(Error('Network Timeout'), { xhr })));\n\n        xhr.send(env.data);\n      });\n    }\n\n    function getImage(src, srcset, sizes) {\n      return new Promise((resolve, reject) => {\n        const img = new Image();\n\n        img.onerror = (e) => {\n          reject(e);\n        };\n        img.onload = () => {\n          resolve(img);\n        };\n\n        sizes && (img.sizes = sizes);\n        srcset && (img.srcset = srcset);\n        img.src = src;\n      });\n    }\n\n    const cssNumber = {\n      'animation-iteration-count': true,\n      'column-count': true,\n      'fill-opacity': true,\n      'flex-grow': true,\n      'flex-shrink': true,\n      'font-weight': true,\n      'line-height': true,\n      opacity: true,\n      order: true,\n      orphans: true,\n      'stroke-dasharray': true,\n      'stroke-dashoffset': true,\n      widows: true,\n      'z-index': true,\n      zoom: true };\n\n\n    function css(element, property, value, priority) {if (priority === void 0) {priority = '';}\n      const elements = toNodes(element);\n      for (const element of elements) {\n        if (isString(property)) {\n          property = propName(property);\n\n          if (isUndefined(value)) {\n            return getComputedStyle(element).getPropertyValue(property);\n          } else {\n            element.style.setProperty(\n            property,\n            isNumeric(value) && !cssNumber[property] ?\n            value + \"px\" :\n            value || isNumber(value) ?\n            value :\n            '',\n            priority);\n\n          }\n        } else if (isArray(property)) {\n          const props = {};\n          for (const prop of property) {\n            props[prop] = css(element, prop);\n          }\n          return props;\n        } else if (isObject(property)) {\n          priority = value;\n          each(property, (value, property) => css(element, property, value, priority));\n        }\n      }\n      return elements[0];\n    }\n\n    // https://drafts.csswg.org/cssom/#dom-cssstyledeclaration-setproperty\n    const propName = memoize((name) => vendorPropName(name));\n\n    function vendorPropName(name) {\n      if (startsWith(name, '--')) {\n        return name;\n      }\n\n      name = hyphenate(name);\n\n      const { style } = document.documentElement;\n\n      if (name in style) {\n        return name;\n      }\n\n      for (const prefix of ['webkit', 'moz']) {\n        const prefixedName = \"-\" + prefix + \"-\" + name;\n        if (prefixedName in style) {\n          return prefixedName;\n        }\n      }\n    }\n\n    function addClass(element) {for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {args[_key - 1] = arguments[_key];}\n      apply$1(element, args, 'add');\n    }\n\n    function removeClass(element) {for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {args[_key2 - 1] = arguments[_key2];}\n      apply$1(element, args, 'remove');\n    }\n\n    function removeClasses(element, cls) {\n      attr(element, 'class', (value) =>\n      (value || '').replace(new RegExp(\"\\\\b\" + cls + \"\\\\b\\\\s?\", 'g'), ''));\n\n    }\n\n    function replaceClass(element) {\n      (arguments.length <= 1 ? undefined : arguments[1]) && removeClass(element, arguments.length <= 1 ? undefined : arguments[1]);\n      (arguments.length <= 2 ? undefined : arguments[2]) && addClass(element, arguments.length <= 2 ? undefined : arguments[2]);\n    }\n\n    function hasClass(element, cls) {\n      [cls] = getClasses(cls);\n      return !!cls && toNodes(element).some((node) => node.classList.contains(cls));\n    }\n\n    function toggleClass(element, cls, force) {\n      const classes = getClasses(cls);\n\n      if (!isUndefined(force)) {\n        force = !!force;\n      }\n\n      for (const node of toNodes(element)) {\n        for (const cls of classes) {\n          node.classList.toggle(cls, force);\n        }\n      }\n    }\n\n    function apply$1(element, args, fn) {\n      args = args.reduce((args, arg) => args.concat(getClasses(arg)), []);\n\n      for (const node of toNodes(element)) {\n        node.classList[fn](...args);\n      }\n    }\n\n    function getClasses(str) {\n      return String(str).split(/\\s|,/).filter(Boolean);\n    }\n\n    function transition$1(element, props, duration, timing) {if (duration === void 0) {duration = 400;}if (timing === void 0) {timing = 'linear';}\n      duration = Math.round(duration);\n      return Promise.all(\n      toNodes(element).map(\n      (element) =>\n      new Promise((resolve, reject) => {\n        for (const name in props) {\n          const value = css(element, name);\n          if (value === '') {\n            css(element, name, value);\n          }\n        }\n\n        const timer = setTimeout(() => trigger(element, 'transitionend'), duration);\n\n        once(\n        element,\n        'transitionend transitioncanceled',\n        (_ref) => {let { type } = _ref;\n          clearTimeout(timer);\n          removeClass(element, 'uk-transition');\n          css(element, {\n            transitionProperty: '',\n            transitionDuration: '',\n            transitionTimingFunction: '' });\n\n          type === 'transitioncanceled' ? reject() : resolve(element);\n        },\n        { self: true });\n\n\n        addClass(element, 'uk-transition');\n        css(element, {\n          transitionProperty: Object.keys(props).map(propName).join(','),\n          transitionDuration: duration + \"ms\",\n          transitionTimingFunction: timing,\n          ...props });\n\n      })));\n\n\n    }\n\n    const Transition = {\n      start: transition$1,\n\n      async stop(element) {\n        trigger(element, 'transitionend');\n        await Promise.resolve();\n      },\n\n      async cancel(element) {\n        trigger(element, 'transitioncanceled');\n        await Promise.resolve();\n      },\n\n      inProgress(element) {\n        return hasClass(element, 'uk-transition');\n      } };\n\n\n    const animationPrefix = 'uk-animation-';\n\n    function animate$2(element, animation, duration, origin, out) {if (duration === void 0) {duration = 200;}\n      return Promise.all(\n      toNodes(element).map(\n      (element) =>\n      new Promise((resolve, reject) => {\n        trigger(element, 'animationcanceled');\n        const timer = setTimeout(() => trigger(element, 'animationend'), duration);\n\n        once(\n        element,\n        'animationend animationcanceled',\n        (_ref2) => {let { type } = _ref2;\n          clearTimeout(timer);\n\n          type === 'animationcanceled' ? reject() : resolve(element);\n\n          css(element, 'animationDuration', '');\n          removeClasses(element, animationPrefix + \"\\\\S*\");\n        },\n        { self: true });\n\n\n        css(element, 'animationDuration', duration + \"ms\");\n        addClass(element, animation, animationPrefix + (out ? 'leave' : 'enter'));\n\n        if (startsWith(animation, animationPrefix)) {\n          origin && addClass(element, \"uk-transform-origin-\" + origin);\n          out && addClass(element, animationPrefix + \"reverse\");\n        }\n      })));\n\n\n    }\n\n    const inProgressRe = new RegExp(animationPrefix + \"(enter|leave)\");\n\n    const Animation = {\n      in: animate$2,\n\n      out(element, animation, duration, origin) {\n        return animate$2(element, animation, duration, origin, true);\n      },\n\n      inProgress(element) {\n        return inProgressRe.test(attr(element, 'class'));\n      },\n\n      cancel(element) {\n        trigger(element, 'animationcanceled');\n      } };\n\n    const dirs$1 = {\n      width: ['left', 'right'],\n      height: ['top', 'bottom'] };\n\n\n    function dimensions$1(element) {\n      const rect = isElement(element) ?\n      toNode(element).getBoundingClientRect() :\n      { height: height(element), width: width(element), top: 0, left: 0 };\n\n      return {\n        height: rect.height,\n        width: rect.width,\n        top: rect.top,\n        left: rect.left,\n        bottom: rect.top + rect.height,\n        right: rect.left + rect.width };\n\n    }\n\n    function offset(element, coordinates) {\n      const currentOffset = dimensions$1(element);\n\n      if (element) {\n        const { scrollY, scrollX } = toWindow(element);\n        const offsetBy = { height: scrollY, width: scrollX };\n\n        for (const dir in dirs$1) {\n          for (const prop of dirs$1[dir]) {\n            currentOffset[prop] += offsetBy[dir];\n          }\n        }\n      }\n\n      if (!coordinates) {\n        return currentOffset;\n      }\n\n      const pos = css(element, 'position');\n\n      each(css(element, ['left', 'top']), (value, prop) =>\n      css(\n      element,\n      prop,\n      coordinates[prop] -\n      currentOffset[prop] +\n      toFloat(pos === 'absolute' && value === 'auto' ? position(element)[prop] : value)));\n\n\n    }\n\n    function position(element) {\n      let { top, left } = offset(element);\n\n      const {\n        ownerDocument: { body, documentElement },\n        offsetParent } =\n      toNode(element);\n      let parent = offsetParent || documentElement;\n\n      while (\n      parent && (\n      parent === body || parent === documentElement) &&\n      css(parent, 'position') === 'static')\n      {\n        parent = parent.parentNode;\n      }\n\n      if (isElement(parent)) {\n        const parentOffset = offset(parent);\n        top -= parentOffset.top + toFloat(css(parent, 'borderTopWidth'));\n        left -= parentOffset.left + toFloat(css(parent, 'borderLeftWidth'));\n      }\n\n      return {\n        top: top - toFloat(css(element, 'marginTop')),\n        left: left - toFloat(css(element, 'marginLeft')) };\n\n    }\n\n    function offsetPosition(element) {\n      element = toNode(element);\n\n      const offset = [element.offsetTop, element.offsetLeft];\n\n      while (element = element.offsetParent) {\n        offset[0] += element.offsetTop + toFloat(css(element, \"borderTopWidth\"));\n        offset[1] += element.offsetLeft + toFloat(css(element, \"borderLeftWidth\"));\n\n        if (css(element, 'position') === 'fixed') {\n          const win = toWindow(element);\n          offset[0] += win.scrollY;\n          offset[1] += win.scrollX;\n          return offset;\n        }\n      }\n\n      return offset;\n    }\n\n    const height = dimension('height');\n    const width = dimension('width');\n\n    function dimension(prop) {\n      const propName = ucfirst(prop);\n      return (element, value) => {\n        if (isUndefined(value)) {\n          if (isWindow(element)) {\n            return element[\"inner\" + propName];\n          }\n\n          if (isDocument(element)) {\n            const doc = element.documentElement;\n            return Math.max(doc[\"offset\" + propName], doc[\"scroll\" + propName]);\n          }\n\n          element = toNode(element);\n\n          value = css(element, prop);\n          value = value === 'auto' ? element[\"offset\" + propName] : toFloat(value) || 0;\n\n          return value - boxModelAdjust(element, prop);\n        } else {\n          return css(\n          element,\n          prop,\n          !value && value !== 0 ? '' : +value + boxModelAdjust(element, prop) + 'px');\n\n        }\n      };\n    }\n\n    function boxModelAdjust(element, prop, sizing) {if (sizing === void 0) {sizing = 'border-box';}\n      return css(element, 'boxSizing') === sizing ?\n      dirs$1[prop].\n      map(ucfirst).\n      reduce(\n      (value, prop) =>\n      value +\n      toFloat(css(element, \"padding\" + prop)) +\n      toFloat(css(element, \"border\" + prop + \"Width\")),\n      0) :\n\n      0;\n    }\n\n    function flipPosition(pos) {\n      for (const dir in dirs$1) {\n        for (const i in dirs$1[dir]) {\n          if (dirs$1[dir][i] === pos) {\n            return dirs$1[dir][1 - i];\n          }\n        }\n      }\n      return pos;\n    }\n\n    function toPx(value, property, element, offsetDim) {if (property === void 0) {property = 'width';}if (element === void 0) {element = window;}if (offsetDim === void 0) {offsetDim = false;}\n      if (!isString(value)) {\n        return toFloat(value);\n      }\n\n      return parseCalc(value).reduce((result, value) => {\n        const unit = parseUnit(value);\n        if (unit) {\n          value = percent(\n          unit === 'vh' ?\n          height(toWindow(element)) :\n          unit === 'vw' ?\n          width(toWindow(element)) :\n          offsetDim ?\n          element[\"offset\" + ucfirst(property)] :\n          dimensions$1(element)[property],\n          value);\n\n        }\n\n        return result + toFloat(value);\n      }, 0);\n    }\n\n    const calcRe = /-?\\d+(?:\\.\\d+)?(?:v[wh]|%|px)?/g;\n    const parseCalc = memoize((calc) => calc.toString().replace(/\\s/g, '').match(calcRe) || []);\n    const unitRe$1 = /(?:v[hw]|%)$/;\n    const parseUnit = memoize((str) => (str.match(unitRe$1) || [])[0]);\n\n    function percent(base, value) {\n      return base * toFloat(value) / 100;\n    }\n\n    function ready(fn) {\n      if (document.readyState !== 'loading') {\n        fn();\n        return;\n      }\n\n      once(document, 'DOMContentLoaded', fn);\n    }\n\n    function isTag(element, tagName) {var _element$tagName;\n      return (element == null ? void 0 : (_element$tagName = element.tagName) == null ? void 0 : _element$tagName.toLowerCase()) === tagName.toLowerCase();\n    }\n\n    function empty(element) {\n      element = $(element);\n      element.innerHTML = '';\n      return element;\n    }\n\n    function html(parent, html) {\n      return isUndefined(html) ? $(parent).innerHTML : append(empty(parent), html);\n    }\n\n    const prepend = applyFn('prepend');\n    const append = applyFn('append');\n    const before = applyFn('before');\n    const after = applyFn('after');\n\n    function applyFn(fn) {\n      return function (ref, element) {var _$;\n        const nodes = toNodes(isString(element) ? fragment(element) : element);\n        (_$ = $(ref)) == null ? void 0 : _$[fn](...nodes);\n        return unwrapSingle(nodes);\n      };\n    }\n\n    function remove$1(element) {\n      toNodes(element).forEach((element) => element.remove());\n    }\n\n    function wrapAll(element, structure) {\n      structure = toNode(before(element, structure));\n\n      while (structure.firstChild) {\n        structure = structure.firstChild;\n      }\n\n      append(structure, element);\n\n      return structure;\n    }\n\n    function wrapInner(element, structure) {\n      return toNodes(\n      toNodes(element).map((element) =>\n      element.hasChildNodes() ?\n      wrapAll(toNodes(element.childNodes), structure) :\n      append(element, structure)));\n\n\n    }\n\n    function unwrap(element) {\n      toNodes(element).\n      map(parent).\n      filter((value, index, self) => self.indexOf(value) === index).\n      forEach((parent) => parent.replaceWith(...parent.childNodes));\n    }\n\n    const fragmentRe = /^\\s*<(\\w+|!)[^>]*>/;\n    const singleTagRe = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/;\n\n    function fragment(html) {\n      const matches = singleTagRe.exec(html);\n      if (matches) {\n        return document.createElement(matches[1]);\n      }\n\n      const container = document.createElement('div');\n      if (fragmentRe.test(html)) {\n        container.insertAdjacentHTML('beforeend', html.trim());\n      } else {\n        container.textContent = html;\n      }\n\n      return unwrapSingle(container.childNodes);\n    }\n\n    function unwrapSingle(nodes) {\n      return nodes.length > 1 ? nodes : nodes[0];\n    }\n\n    function apply(node, fn) {\n      if (!isElement(node)) {\n        return;\n      }\n\n      fn(node);\n      node = node.firstElementChild;\n      while (node) {\n        const next = node.nextElementSibling;\n        apply(node, fn);\n        node = next;\n      }\n    }\n\n    function $(selector, context) {\n      return isHtml(selector) ? toNode(fragment(selector)) : find(selector, context);\n    }\n\n    function $$(selector, context) {\n      return isHtml(selector) ? toNodes(fragment(selector)) : findAll(selector, context);\n    }\n\n    function isHtml(str) {\n      return isString(str) && startsWith(str.trim(), '<');\n    }\n\n    const inBrowser = typeof window !== 'undefined';\n    const isRtl = inBrowser && attr(document.documentElement, 'dir') === 'rtl';\n\n    const hasTouch = inBrowser && 'ontouchstart' in window;\n    const hasPointerEvents = inBrowser && window.PointerEvent;\n\n    const pointerDown$1 = hasPointerEvents ? 'pointerdown' : hasTouch ? 'touchstart' : 'mousedown';\n    const pointerMove$1 = hasPointerEvents ? 'pointermove' : hasTouch ? 'touchmove' : 'mousemove';\n    const pointerUp$1 = hasPointerEvents ? 'pointerup' : hasTouch ? 'touchend' : 'mouseup';\n    const pointerEnter = hasPointerEvents ? 'pointerenter' : hasTouch ? '' : 'mouseenter';\n    const pointerLeave = hasPointerEvents ? 'pointerleave' : hasTouch ? '' : 'mouseleave';\n    const pointerCancel = hasPointerEvents ? 'pointercancel' : 'touchcancel';\n\n    /*\n        Based on:\n        Copyright (c) 2016 Wilson Page wilsonpage@me.com\n        https://github.com/wilsonpage/fastdom\n    */\n\n    const fastdom = {\n      reads: [],\n      writes: [],\n\n      read(task) {\n        this.reads.push(task);\n        scheduleFlush();\n        return task;\n      },\n\n      write(task) {\n        this.writes.push(task);\n        scheduleFlush();\n        return task;\n      },\n\n      clear(task) {\n        remove(this.reads, task);\n        remove(this.writes, task);\n      },\n\n      flush };\n\n\n    function flush(recursion) {\n      runTasks(fastdom.reads);\n      runTasks(fastdom.writes.splice(0));\n\n      fastdom.scheduled = false;\n\n      if (fastdom.reads.length || fastdom.writes.length) {\n        scheduleFlush(recursion + 1);\n      }\n    }\n\n    const RECURSION_LIMIT = 4;\n    function scheduleFlush(recursion) {\n      if (fastdom.scheduled) {\n        return;\n      }\n\n      fastdom.scheduled = true;\n      if (recursion && recursion < RECURSION_LIMIT) {\n        Promise.resolve().then(() => flush(recursion));\n      } else {\n        requestAnimationFrame(() => flush(1));\n      }\n    }\n\n    function runTasks(tasks) {\n      let task;\n      while (task = tasks.shift()) {\n        try {\n          task();\n        } catch (e) {\n          console.error(e);\n        }\n      }\n    }\n\n    function remove(array, item) {\n      const index = array.indexOf(item);\n      return ~index && array.splice(index, 1);\n    }\n\n    function MouseTracker() {}\n\n    MouseTracker.prototype = {\n      positions: [],\n\n      init() {\n        this.positions = [];\n\n        let position;\n        this.unbind = on(document, 'mousemove', (e) => position = getEventPos(e));\n        this.interval = setInterval(() => {\n          if (!position) {\n            return;\n          }\n\n          this.positions.push(position);\n\n          if (this.positions.length > 5) {\n            this.positions.shift();\n          }\n        }, 50);\n      },\n\n      cancel() {var _this$unbind;\n        (_this$unbind = this.unbind) == null ? void 0 : _this$unbind.call(this);\n        this.interval && clearInterval(this.interval);\n      },\n\n      movesTo(target) {\n        if (this.positions.length < 2) {\n          return false;\n        }\n\n        const p = target.getBoundingClientRect();\n        const { left, right, top, bottom } = p;\n\n        const [prevPosition] = this.positions;\n        const position = last(this.positions);\n        const path = [prevPosition, position];\n\n        if (pointInRect(position, p)) {\n          return false;\n        }\n\n        const diagonals = [\n        [\n        { x: left, y: top },\n        { x: right, y: bottom }],\n\n        [\n        { x: left, y: bottom },\n        { x: right, y: top }]];\n\n\n\n        return diagonals.some((diagonal) => {\n          const intersection = intersect(path, diagonal);\n          return intersection && pointInRect(intersection, p);\n        });\n      } };\n\n\n    // Inspired by http://paulbourke.net/geometry/pointlineplane/\n    function intersect(_ref, _ref2) {let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = _ref;let [{ x: x3, y: y3 }, { x: x4, y: y4 }] = _ref2;\n      const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\n      // Lines are parallel\n      if (denominator === 0) {\n        return false;\n      }\n\n      const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;\n\n      if (ua < 0) {\n        return false;\n      }\n\n      // Return an object with the x and y coordinates of the intersection\n      return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1) };\n    }\n\n    function observeIntersection(targets, cb, options, intersecting) {if (intersecting === void 0) {intersecting = true;}\n      const observer = new IntersectionObserver(\n      intersecting ?\n      (entries, observer) => {\n        if (entries.some((entry) => entry.isIntersecting)) {\n          cb(entries, observer);\n        }\n      } :\n      cb,\n      options);\n\n      for (const el of toNodes(targets)) {\n        observer.observe(el);\n      }\n\n      return observer;\n    }\n\n    const hasResizeObserver = inBrowser && window.ResizeObserver;\n    function observeResize(targets, cb, options) {if (options === void 0) {options = { box: 'border-box' };}\n      if (hasResizeObserver) {\n        return observe(ResizeObserver, targets, cb, options);\n      }\n\n      // Fallback Safari < 13.1\n      initResizeListener();\n      listeners.add(cb);\n\n      return {\n        disconnect() {\n          listeners.delete(cb);\n        } };\n\n    }\n\n    let listeners;\n    function initResizeListener() {\n      if (listeners) {\n        return;\n      }\n\n      listeners = new Set();\n\n      // throttle 'resize'\n      let pendingResize;\n      const handleResize = () => {\n        if (pendingResize) {\n          return;\n        }\n        pendingResize = true;\n        requestAnimationFrame(() => pendingResize = false);\n        for (const listener of listeners) {\n          listener();\n        }\n      };\n\n      on(window, 'load resize', handleResize);\n      on(document, 'loadedmetadata load', handleResize, true);\n    }\n\n    function observeMutation(targets, cb, options) {\n      return observe(MutationObserver, targets, cb, options);\n    }\n\n    function observe(Observer, targets, cb, options) {\n      const observer = new Observer(cb);\n      for (const el of toNodes(targets)) {\n        observer.observe(el, options);\n      }\n\n      return observer;\n    }\n\n    const strats = {};\n\n    strats.events =\n    strats.created =\n    strats.beforeConnect =\n    strats.connected =\n    strats.beforeDisconnect =\n    strats.disconnected =\n    strats.destroy =\n    concatStrat;\n\n    // args strategy\n    strats.args = function (parentVal, childVal) {\n      return childVal !== false && concatStrat(childVal || parentVal);\n    };\n\n    // update strategy\n    strats.update = function (parentVal, childVal) {\n      return sortBy$1(\n      concatStrat(parentVal, isFunction(childVal) ? { read: childVal } : childVal),\n      'order');\n\n    };\n\n    // property strategy\n    strats.props = function (parentVal, childVal) {\n      if (isArray(childVal)) {\n        const value = {};\n        for (const key of childVal) {\n          value[key] = String;\n        }\n        childVal = value;\n      }\n\n      return strats.methods(parentVal, childVal);\n    };\n\n    // extend strategy\n    strats.computed = strats.methods = function (parentVal, childVal) {\n      return childVal ? parentVal ? { ...parentVal, ...childVal } : childVal : parentVal;\n    };\n\n    // data strategy\n    strats.data = function (parentVal, childVal, vm) {\n      if (!vm) {\n        if (!childVal) {\n          return parentVal;\n        }\n\n        if (!parentVal) {\n          return childVal;\n        }\n\n        return function (vm) {\n          return mergeFnData(parentVal, childVal, vm);\n        };\n      }\n\n      return mergeFnData(parentVal, childVal, vm);\n    };\n\n    function mergeFnData(parentVal, childVal, vm) {\n      return strats.computed(\n      isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal,\n      isFunction(childVal) ? childVal.call(vm, vm) : childVal);\n\n    }\n\n    // concat strategy\n    function concatStrat(parentVal, childVal) {\n      parentVal = parentVal && !isArray(parentVal) ? [parentVal] : parentVal;\n\n      return childVal ?\n      parentVal ?\n      parentVal.concat(childVal) :\n      isArray(childVal) ?\n      childVal :\n      [childVal] :\n      parentVal;\n    }\n\n    // default strategy\n    function defaultStrat(parentVal, childVal) {\n      return isUndefined(childVal) ? parentVal : childVal;\n    }\n\n    function mergeOptions(parent, child, vm) {\n      const options = {};\n\n      if (isFunction(child)) {\n        child = child.options;\n      }\n\n      if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n      }\n\n      if (child.mixins) {\n        for (const mixin of child.mixins) {\n          parent = mergeOptions(parent, mixin, vm);\n        }\n      }\n\n      for (const key in parent) {\n        mergeKey(key);\n      }\n\n      for (const key in child) {\n        if (!hasOwn(parent, key)) {\n          mergeKey(key);\n        }\n      }\n\n      function mergeKey(key) {\n        options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);\n      }\n\n      return options;\n    }\n\n    function parseOptions(options, args) {if (args === void 0) {args = [];}\n      try {\n        return options ?\n        startsWith(options, '{') ?\n        JSON.parse(options) :\n        args.length && !includes(options, ':') ?\n        { [args[0]]: options } :\n        options.split(';').reduce((options, option) => {\n          const [key, value] = option.split(/:(.*)/);\n          if (key && !isUndefined(value)) {\n            options[key.trim()] = value.trim();\n          }\n          return options;\n        }, {}) :\n        {};\n      } catch (e) {\n        return {};\n      }\n    }\n\n    function play(el) {\n      if (isIFrame(el)) {\n        call(el, { func: 'playVideo', method: 'play' });\n      }\n\n      if (isHTML5(el)) {\n        try {\n          el.play().catch(noop);\n        } catch (e) {\n          // noop\n        }\n      }\n    }\n\n    function pause(el) {\n      if (isIFrame(el)) {\n        call(el, { func: 'pauseVideo', method: 'pause' });\n      }\n\n      if (isHTML5(el)) {\n        el.pause();\n      }\n    }\n\n    function mute(el) {\n      if (isIFrame(el)) {\n        call(el, { func: 'mute', method: 'setVolume', value: 0 });\n      }\n\n      if (isHTML5(el)) {\n        el.muted = true;\n      }\n    }\n\n    function isVideo(el) {\n      return isHTML5(el) || isIFrame(el);\n    }\n\n    function isHTML5(el) {\n      return isTag(el, 'video');\n    }\n\n    function isIFrame(el) {\n      return isTag(el, 'iframe') && (isYoutube(el) || isVimeo(el));\n    }\n\n    function isYoutube(el) {\n      return !!el.src.match(\n      /\\/\\/.*?youtube(-nocookie)?\\.[a-z]+\\/(watch\\?v=[^&\\s]+|embed)|youtu\\.be\\/.*/);\n\n    }\n\n    function isVimeo(el) {\n      return !!el.src.match(/vimeo\\.com\\/video\\/.*/);\n    }\n\n    async function call(el, cmd) {\n      await enableApi(el);\n      post(el, cmd);\n    }\n\n    function post(el, cmd) {\n      try {\n        el.contentWindow.postMessage(JSON.stringify({ event: 'command', ...cmd }), '*');\n      } catch (e) {\n        // noop\n      }\n    }\n\n    const stateKey = '_ukPlayer';\n    let counter = 0;\n    function enableApi(el) {\n      if (el[stateKey]) {\n        return el[stateKey];\n      }\n\n      const youtube = isYoutube(el);\n      const vimeo = isVimeo(el);\n\n      const id = ++counter;\n      let poller;\n\n      return el[stateKey] = new Promise((resolve) => {\n        youtube &&\n        once(el, 'load', () => {\n          const listener = () => post(el, { event: 'listening', id });\n          poller = setInterval(listener, 100);\n          listener();\n        });\n\n        once(window, 'message', resolve, false, (_ref) => {let { data } = _ref;\n          try {\n            data = JSON.parse(data);\n            return (\n              data && (\n              youtube && data.id === id && data.event === 'onReady' ||\n              vimeo && Number(data.player_id) === id));\n\n          } catch (e) {\n            // noop\n          }\n        });\n\n        el.src = \"\" + el.src + (includes(el.src, '?') ? '&' : '?') + (\n        youtube ? 'enablejsapi=1' : \"api=1&player_id=\" + id);\n\n      }).then(() => clearInterval(poller));\n    }\n\n    function isInView(element, offsetTop, offsetLeft) {if (offsetTop === void 0) {offsetTop = 0;}if (offsetLeft === void 0) {offsetLeft = 0;}\n      if (!isVisible(element)) {\n        return false;\n      }\n\n      return intersectRect(\n      ...scrollParents(element).\n      map((parent) => {\n        const { top, left, bottom, right } = offsetViewport(parent);\n\n        return {\n          top: top - offsetTop,\n          left: left - offsetLeft,\n          bottom: bottom + offsetTop,\n          right: right + offsetLeft };\n\n      }).\n      concat(offset(element)));\n\n    }\n\n    function scrollIntoView(element, _temp) {let { offset: offsetBy = 0 } = _temp === void 0 ? {} : _temp;\n      const parents = isVisible(element) ? scrollParents(element) : [];\n      return parents.reduce(\n      (fn, scrollElement, i) => {\n        const { scrollTop, scrollHeight, offsetHeight } = scrollElement;\n        const viewport = offsetViewport(scrollElement);\n        const maxScroll = scrollHeight - viewport.height;\n        const { height: elHeight, top: elTop } = parents[i - 1] ?\n        offsetViewport(parents[i - 1]) :\n        offset(element);\n\n        let top = Math.ceil(elTop - viewport.top - offsetBy + scrollTop);\n\n        if (offsetBy > 0 && offsetHeight < elHeight + offsetBy) {\n          top += offsetBy;\n        } else {\n          offsetBy = 0;\n        }\n\n        if (top > maxScroll) {\n          offsetBy -= top - maxScroll;\n          top = maxScroll;\n        } else if (top < 0) {\n          offsetBy -= top;\n          top = 0;\n        }\n\n        return () => scrollTo(scrollElement, top - scrollTop).then(fn);\n      },\n      () => Promise.resolve())();\n\n\n      function scrollTo(element, top) {\n        return new Promise((resolve) => {\n          const scroll = element.scrollTop;\n          const duration = getDuration(Math.abs(top));\n          const start = Date.now();\n\n          (function step() {\n            const percent = ease(clamp((Date.now() - start) / duration));\n\n            element.scrollTop = scroll + top * percent;\n\n            // scroll more if we have not reached our destination\n            if (percent === 1) {\n              resolve();\n            } else {\n              requestAnimationFrame(step);\n            }\n          })();\n        });\n      }\n\n      function getDuration(dist) {\n        return 40 * Math.pow(dist, 0.375);\n      }\n\n      function ease(k) {\n        return 0.5 * (1 - Math.cos(Math.PI * k));\n      }\n    }\n\n    function scrolledOver(element, startOffset, endOffset) {if (startOffset === void 0) {startOffset = 0;}if (endOffset === void 0) {endOffset = 0;}\n      if (!isVisible(element)) {\n        return 0;\n      }\n\n      const [scrollElement] = scrollParents(element, /auto|scroll/, true);\n      const { scrollHeight, scrollTop } = scrollElement;\n      const { height: viewportHeight } = offsetViewport(scrollElement);\n      const maxScroll = scrollHeight - viewportHeight;\n      const elementOffsetTop = offsetPosition(element)[0] - offsetPosition(scrollElement)[0];\n\n      const start = Math.max(0, elementOffsetTop - viewportHeight + startOffset);\n      const end = Math.min(maxScroll, elementOffsetTop + element.offsetHeight - endOffset);\n\n      return clamp((scrollTop - start) / (end - start));\n    }\n\n    function scrollParents(element, overflowRe, scrollable) {if (overflowRe === void 0) {overflowRe = /auto|scroll|hidden|clip/;}if (scrollable === void 0) {scrollable = false;}\n      const scrollEl = scrollingElement(element);\n\n      let ancestors = parents(element).reverse();\n      ancestors = ancestors.slice(ancestors.indexOf(scrollEl) + 1);\n\n      const fixedIndex = findIndex(ancestors, (el) => css(el, 'position') === 'fixed');\n      if (~fixedIndex) {\n        ancestors = ancestors.slice(fixedIndex);\n      }\n\n      return [scrollEl].\n      concat(\n      ancestors.filter(\n      (parent) =>\n      overflowRe.test(css(parent, 'overflow')) && (\n      !scrollable || parent.scrollHeight > offsetViewport(parent).height))).\n\n\n      reverse();\n    }\n\n    function offsetViewport(scrollElement) {\n      const window = toWindow(scrollElement);\n      const {\n        document: { documentElement } } =\n      window;\n      let viewportElement =\n      scrollElement === scrollingElement(scrollElement) ? window : scrollElement;\n\n      const { visualViewport } = window;\n      if (isWindow(viewportElement) && visualViewport) {\n        let { height, width, scale, pageTop: top, pageLeft: left } = visualViewport;\n        height = Math.round(height * scale);\n        width = Math.round(width * scale);\n        return { height, width, top, left, bottom: top + height, right: left + width };\n      }\n\n      let rect = offset(viewportElement);\n      for (let [prop, dir, start, end] of [\n      ['width', 'x', 'left', 'right'],\n      ['height', 'y', 'top', 'bottom']])\n      {\n        if (isWindow(viewportElement)) {\n          // iOS 12 returns <body> as scrollingElement\n          viewportElement = documentElement;\n        } else {\n          rect[start] += toFloat(css(viewportElement, \"border-\" + start + \"-width\"));\n        }\n        rect[prop] = rect[dir] = viewportElement[\"client\" + ucfirst(prop)];\n        rect[end] = rect[prop] + rect[start];\n      }\n      return rect;\n    }\n\n    function scrollingElement(element) {\n      return toWindow(element).document.scrollingElement;\n    }\n\n    const dirs = [\n    ['width', 'x', 'left', 'right'],\n    ['height', 'y', 'top', 'bottom']];\n\n\n    function positionAt(element, target, options) {\n      options = {\n        attach: {\n          element: ['left', 'top'],\n          target: ['left', 'top'],\n          ...options.attach },\n\n        offset: [0, 0],\n        placement: [],\n        ...options };\n\n\n      if (!isArray(target)) {\n        target = [target, target];\n      }\n\n      offset(element, getPosition(element, target, options));\n    }\n\n    function getPosition(element, target, options) {\n      const position = attachTo(element, target, options);\n      const { boundary, viewportOffset = 0, placement } = options;\n\n      let offsetPosition = position;\n      for (const [i, [prop,, start, end]] of Object.entries(dirs)) {\n        const viewport = getViewport$1(target[i], viewportOffset, boundary, i);\n\n        if (isWithin(position, viewport, i)) {\n          continue;\n        }\n\n        let offsetBy = 0;\n\n        // Flip\n        if (placement[i] === 'flip') {\n          const attach = options.attach.target[i];\n          if (\n          attach === end && position[end] <= viewport[end] ||\n          attach === start && position[start] >= viewport[start])\n          {\n            continue;\n          }\n\n          offsetBy = flip(element, target, options, i)[start] - position[start];\n\n          const scrollArea = getScrollArea(target[i], viewportOffset, i);\n\n          if (!isWithin(applyOffset(position, offsetBy, i), scrollArea, i)) {\n            if (isWithin(position, scrollArea, i)) {\n              continue;\n            }\n\n            if (options.recursion) {\n              return false;\n            }\n\n            const newPos = flipAxis(element, target, options);\n\n            if (newPos && isWithin(newPos, scrollArea, 1 - i)) {\n              return newPos;\n            }\n\n            continue;\n          }\n\n          // Shift\n        } else if (placement[i] === 'shift') {\n          const targetDim = offset(target[i]);\n          const { offset: elOffset } = options;\n          offsetBy =\n          clamp(\n          clamp(position[start], viewport[start], viewport[end] - position[prop]),\n          targetDim[start] - position[prop] + elOffset[i],\n          targetDim[end] - elOffset[i]) -\n          position[start];\n        }\n\n        offsetPosition = applyOffset(offsetPosition, offsetBy, i);\n      }\n\n      return offsetPosition;\n    }\n\n    function attachTo(element, target, options) {\n      let { attach, offset: offsetBy } = {\n        attach: {\n          element: ['left', 'top'],\n          target: ['left', 'top'],\n          ...options.attach },\n\n        offset: [0, 0],\n        ...options };\n\n\n      let elOffset = offset(element);\n\n      for (const [i, [prop,, start, end]] of Object.entries(dirs)) {\n        const targetOffset =\n        attach.target[i] === attach.element[i] ? offsetViewport(target[i]) : offset(target[i]);\n\n        elOffset = applyOffset(\n        elOffset,\n        targetOffset[start] -\n        elOffset[start] +\n        moveBy(attach.target[i], end, targetOffset[prop]) -\n        moveBy(attach.element[i], end, elOffset[prop]) +\n        +offsetBy[i],\n        i);\n\n      }\n      return elOffset;\n    }\n\n    function applyOffset(position, offset, i) {\n      const [, dir, start, end] = dirs[i];\n      const newPos = { ...position };\n      newPos[start] = position[dir] = position[start] + offset;\n      newPos[end] += offset;\n      return newPos;\n    }\n\n    function moveBy(attach, end, dim) {\n      return attach === 'center' ? dim / 2 : attach === end ? dim : 0;\n    }\n\n    function getViewport$1(element, viewportOffset, boundary, i) {\n      let viewport = getIntersectionArea(...scrollParents(element).map(offsetViewport));\n\n      if (viewportOffset) {\n        viewport[dirs[i][2]] += viewportOffset;\n        viewport[dirs[i][3]] -= viewportOffset;\n      }\n\n      if (boundary) {\n        viewport = getIntersectionArea(\n        viewport,\n        offset(isArray(boundary) ? boundary[i] : boundary));\n\n      }\n\n      return viewport;\n    }\n\n    function getScrollArea(element, viewportOffset, i) {\n      const [prop,, start, end] = dirs[i];\n      const [scrollElement] = scrollParents(element);\n      const viewport = offsetViewport(scrollElement);\n      viewport[start] -= scrollElement[\"scroll\" + ucfirst(start)] - viewportOffset;\n      viewport[end] = viewport[start] + scrollElement[\"scroll\" + ucfirst(prop)] - viewportOffset;\n      return viewport;\n    }\n\n    function getIntersectionArea() {\n      let area = {};for (var _len = arguments.length, rects = new Array(_len), _key = 0; _key < _len; _key++) {rects[_key] = arguments[_key];}\n      for (const rect of rects) {\n        for (const [,, start, end] of dirs) {\n          area[start] = Math.max(area[start] || 0, rect[start]);\n          area[end] = Math.min(...[area[end], rect[end]].filter(Boolean));\n        }\n      }\n      return area;\n    }\n\n    function isWithin(positionA, positionB, i) {\n      const [,, start, end] = dirs[i];\n      return positionA[start] >= positionB[start] && positionA[end] <= positionB[end];\n    }\n\n    function flip(element, target, _ref, i) {let { offset, attach } = _ref;\n      return attachTo(element, target, {\n        attach: {\n          element: flipAttach(attach.element, i),\n          target: flipAttach(attach.target, i) },\n\n        offset: flipOffset(offset, i) });\n\n    }\n\n    function flipAxis(element, target, options) {\n      return getPosition(element, target, {\n        ...options,\n        attach: {\n          element: options.attach.element.map(flipAttachAxis).reverse(),\n          target: options.attach.target.map(flipAttachAxis).reverse() },\n\n        offset: options.offset.reverse(),\n        placement: options.placement.reverse(),\n        recursion: true });\n\n    }\n\n    function flipAttach(attach, i) {\n      const newAttach = [...attach];\n      const index = dirs[i].indexOf(attach[i]);\n      if (~index) {\n        newAttach[i] = dirs[i][1 - index % 2 + 2];\n      }\n      return newAttach;\n    }\n\n    function flipAttachAxis(prop) {\n      for (let i = 0; i < dirs.length; i++) {\n        const index = dirs[i].indexOf(prop);\n        if (~index) {\n          return dirs[1 - i][index % 2 + 2];\n        }\n      }\n    }\n\n    function flipOffset(offset, i) {\n      offset = [...offset];\n      offset[i] *= -1;\n      return offset;\n    }\n\n    var util = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        ajax: ajax,\n        getImage: getImage,\n        Transition: Transition,\n        Animation: Animation,\n        attr: attr,\n        hasAttr: hasAttr,\n        removeAttr: removeAttr,\n        data: data,\n        addClass: addClass,\n        removeClass: removeClass,\n        removeClasses: removeClasses,\n        replaceClass: replaceClass,\n        hasClass: hasClass,\n        toggleClass: toggleClass,\n        dimensions: dimensions$1,\n        offset: offset,\n        position: position,\n        offsetPosition: offsetPosition,\n        height: height,\n        width: width,\n        boxModelAdjust: boxModelAdjust,\n        flipPosition: flipPosition,\n        toPx: toPx,\n        ready: ready,\n        isTag: isTag,\n        empty: empty,\n        html: html,\n        prepend: prepend,\n        append: append,\n        before: before,\n        after: after,\n        remove: remove$1,\n        wrapAll: wrapAll,\n        wrapInner: wrapInner,\n        unwrap: unwrap,\n        fragment: fragment,\n        apply: apply,\n        $: $,\n        $$: $$,\n        inBrowser: inBrowser,\n        isRtl: isRtl,\n        hasTouch: hasTouch,\n        pointerDown: pointerDown$1,\n        pointerMove: pointerMove$1,\n        pointerUp: pointerUp$1,\n        pointerEnter: pointerEnter,\n        pointerLeave: pointerLeave,\n        pointerCancel: pointerCancel,\n        on: on,\n        off: off,\n        once: once,\n        trigger: trigger,\n        createEvent: createEvent,\n        toEventTargets: toEventTargets,\n        isTouch: isTouch,\n        getEventPos: getEventPos,\n        fastdom: fastdom,\n        isVoidElement: isVoidElement,\n        isVisible: isVisible,\n        selInput: selInput,\n        isInput: isInput,\n        selFocusable: selFocusable,\n        isFocusable: isFocusable,\n        parent: parent,\n        filter: filter$1,\n        matches: matches,\n        closest: closest,\n        within: within,\n        parents: parents,\n        children: children,\n        index: index,\n        hasOwn: hasOwn,\n        hyphenate: hyphenate,\n        camelize: camelize,\n        ucfirst: ucfirst,\n        startsWith: startsWith,\n        endsWith: endsWith,\n        includes: includes,\n        findIndex: findIndex,\n        isArray: isArray,\n        toArray: toArray,\n        assign: assign,\n        isFunction: isFunction,\n        isObject: isObject,\n        isPlainObject: isPlainObject,\n        isWindow: isWindow,\n        isDocument: isDocument,\n        isNode: isNode,\n        isElement: isElement,\n        isBoolean: isBoolean,\n        isString: isString,\n        isNumber: isNumber,\n        isNumeric: isNumeric,\n        isEmpty: isEmpty,\n        isUndefined: isUndefined,\n        toBoolean: toBoolean,\n        toNumber: toNumber,\n        toFloat: toFloat,\n        toNode: toNode,\n        toNodes: toNodes,\n        toWindow: toWindow,\n        isEqual: isEqual,\n        swap: swap,\n        last: last,\n        each: each,\n        sortBy: sortBy$1,\n        uniqueBy: uniqueBy,\n        clamp: clamp,\n        noop: noop,\n        intersectRect: intersectRect,\n        pointInRect: pointInRect,\n        Dimensions: Dimensions,\n        getIndex: getIndex,\n        memoize: memoize,\n        Deferred: Deferred,\n        MouseTracker: MouseTracker,\n        observeIntersection: observeIntersection,\n        observeResize: observeResize,\n        observeMutation: observeMutation,\n        mergeOptions: mergeOptions,\n        parseOptions: parseOptions,\n        play: play,\n        pause: pause,\n        mute: mute,\n        isVideo: isVideo,\n        positionAt: positionAt,\n        query: query,\n        queryAll: queryAll,\n        find: find,\n        findAll: findAll,\n        escape: escape,\n        css: css,\n        propName: propName,\n        isInView: isInView,\n        scrollIntoView: scrollIntoView,\n        scrolledOver: scrolledOver,\n        scrollParents: scrollParents,\n        offsetViewport: offsetViewport\n    });\n\n    function globalAPI (UIkit) {\n      const DATA = UIkit.data;\n\n      UIkit.use = function (plugin) {\n        if (plugin.installed) {\n          return;\n        }\n\n        plugin.call(null, this);\n        plugin.installed = true;\n\n        return this;\n      };\n\n      UIkit.mixin = function (mixin, component) {\n        component = (isString(component) ? UIkit.component(component) : component) || this;\n        component.options = mergeOptions(component.options, mixin);\n      };\n\n      UIkit.extend = function (options) {\n        options = options || {};\n\n        const Super = this;\n        const Sub = function UIkitComponent(options) {\n          this._init(options);\n        };\n\n        Sub.prototype = Object.create(Super.prototype);\n        Sub.prototype.constructor = Sub;\n        Sub.options = mergeOptions(Super.options, options);\n\n        Sub.super = Super;\n        Sub.extend = Super.extend;\n\n        return Sub;\n      };\n\n      UIkit.update = function (element, e) {\n        element = element ? toNode(element) : document.body;\n\n        for (const parentEl of parents(element).reverse()) {\n          update(parentEl[DATA], e);\n        }\n\n        apply(element, (element) => update(element[DATA], e));\n      };\n\n      let container;\n      Object.defineProperty(UIkit, 'container', {\n        get() {\n          return container || document.body;\n        },\n\n        set(element) {\n          container = $(element);\n        } });\n\n\n      function update(data, e) {\n        if (!data) {\n          return;\n        }\n\n        for (const name in data) {\n          if (data[name]._connected) {\n            data[name]._callUpdate(e);\n          }\n        }\n      }\n    }\n\n    function hooksAPI (UIkit) {\n      UIkit.prototype._callHook = function (hook) {var _this$$options$hook;\n        (_this$$options$hook = this.$options[hook]) == null ? void 0 : _this$$options$hook.forEach((handler) => handler.call(this));\n      };\n\n      UIkit.prototype._callConnected = function () {\n        if (this._connected) {\n          return;\n        }\n\n        this._data = {};\n        this._computed = {};\n\n        this._initProps();\n\n        this._callHook('beforeConnect');\n        this._connected = true;\n\n        this._initEvents();\n        this._initObservers();\n\n        this._callHook('connected');\n        this._callUpdate();\n      };\n\n      UIkit.prototype._callDisconnected = function () {\n        if (!this._connected) {\n          return;\n        }\n\n        this._callHook('beforeDisconnect');\n        this._disconnectObservers();\n        this._unbindEvents();\n        this._callHook('disconnected');\n\n        this._connected = false;\n        delete this._watch;\n      };\n\n      UIkit.prototype._callUpdate = function (e) {if (e === void 0) {e = 'update';}\n        if (!this._connected) {\n          return;\n        }\n\n        if (e === 'update' || e === 'resize') {\n          this._callWatches();\n        }\n\n        if (!this.$options.update) {\n          return;\n        }\n\n        if (!this._updates) {\n          this._updates = new Set();\n          fastdom.read(() => {\n            if (this._connected) {\n              runUpdates.call(this, this._updates);\n            }\n            delete this._updates;\n          });\n        }\n\n        this._updates.add(e.type || e);\n      };\n\n      UIkit.prototype._callWatches = function () {\n        if (this._watch) {\n          return;\n        }\n\n        const initial = !hasOwn(this, '_watch');\n\n        this._watch = fastdom.read(() => {\n          if (this._connected) {\n            runWatches.call(this, initial);\n          }\n          this._watch = null;\n        });\n      };\n\n      function runUpdates(types) {\n        for (const { read, write, events = [] } of this.$options.update) {\n          if (!types.has('update') && !events.some((type) => types.has(type))) {\n            continue;\n          }\n\n          let result;\n          if (read) {\n            result = read.call(this, this._data, types);\n\n            if (result && isPlainObject(result)) {\n              assign(this._data, result);\n            }\n          }\n\n          if (write && result !== false) {\n            fastdom.write(() => {\n              if (this._connected) {\n                write.call(this, this._data, types);\n              }\n            });\n          }\n        }\n      }\n\n      function runWatches(initial) {\n        const {\n          $options: { computed } } =\n        this;\n        const values = { ...this._computed };\n        this._computed = {};\n\n        for (const key in computed) {\n          const { watch, immediate } = computed[key];\n          if (\n          watch && (\n          initial && immediate ||\n          hasOwn(values, key) && !isEqual(values[key], this[key])))\n          {\n            watch.call(this, this[key], values[key]);\n          }\n        }\n      }\n    }\n\n    function stateAPI (UIkit) {\n      let uid = 0;\n\n      UIkit.prototype._init = function (options) {\n        options = options || {};\n        options.data = normalizeData(options, this.constructor.options);\n\n        this.$options = mergeOptions(this.constructor.options, options, this);\n        this.$el = null;\n        this.$props = {};\n\n        this._uid = uid++;\n        this._initData();\n        this._initMethods();\n        this._initComputeds();\n        this._callHook('created');\n\n        if (options.el) {\n          this.$mount(options.el);\n        }\n      };\n\n      UIkit.prototype._initData = function () {\n        const { data = {} } = this.$options;\n\n        for (const key in data) {\n          this.$props[key] = this[key] = data[key];\n        }\n      };\n\n      UIkit.prototype._initMethods = function () {\n        const { methods } = this.$options;\n\n        if (methods) {\n          for (const key in methods) {\n            this[key] = methods[key].bind(this);\n          }\n        }\n      };\n\n      UIkit.prototype._initComputeds = function () {\n        const { computed } = this.$options;\n\n        this._computed = {};\n\n        if (computed) {\n          for (const key in computed) {\n            registerComputed(this, key, computed[key]);\n          }\n        }\n      };\n\n      UIkit.prototype._initProps = function (props) {\n        let key;\n\n        props = props || getProps$1(this.$options);\n\n        for (key in props) {\n          if (!isUndefined(props[key])) {\n            this.$props[key] = props[key];\n          }\n        }\n\n        const exclude = [this.$options.computed, this.$options.methods];\n        for (key in this.$props) {\n          if (key in props && notIn(exclude, key)) {\n            this[key] = this.$props[key];\n          }\n        }\n      };\n\n      UIkit.prototype._initEvents = function () {\n        this._events = [];\n        for (const event of this.$options.events || []) {\n          if (hasOwn(event, 'handler')) {\n            registerEvent(this, event);\n          } else {\n            for (const key in event) {\n              registerEvent(this, event[key], key);\n            }\n          }\n        }\n      };\n\n      UIkit.prototype._unbindEvents = function () {\n        this._events.forEach((unbind) => unbind());\n        delete this._events;\n      };\n\n      UIkit.prototype._initObservers = function () {\n        this._observers = [initPropsObserver(this)];\n\n        if (this.$options.computed) {\n          this.registerObserver(initChildListObserver(this));\n        }\n      };\n\n      UIkit.prototype.registerObserver = function () {\n        this._observers.push(...arguments);\n      };\n\n      UIkit.prototype._disconnectObservers = function () {\n        this._observers.forEach((observer) => observer == null ? void 0 : observer.disconnect());\n      };\n    }\n\n    function getProps$1(opts) {\n      const data$1 = {};\n      const { args = [], props = {}, el, id } = opts;\n\n      if (!props) {\n        return data$1;\n      }\n\n      for (const key in props) {\n        const prop = hyphenate(key);\n        let value = data(el, prop);\n\n        if (isUndefined(value)) {\n          continue;\n        }\n\n        value = props[key] === Boolean && value === '' ? true : coerce$1(props[key], value);\n\n        if (prop === 'target' && startsWith(value, '_')) {\n          continue;\n        }\n\n        data$1[key] = value;\n      }\n\n      const options = parseOptions(data(el, id), args);\n\n      for (const key in options) {\n        const prop = camelize(key);\n        if (!isUndefined(props[prop])) {\n          data$1[prop] = coerce$1(props[prop], options[key]);\n        }\n      }\n\n      return data$1;\n    }\n\n    function registerComputed(component, key, cb) {\n      Object.defineProperty(component, key, {\n        enumerable: true,\n\n        get() {\n          const { _computed, $props, $el } = component;\n\n          if (!hasOwn(_computed, key)) {\n            _computed[key] = (cb.get || cb).call(component, $props, $el);\n          }\n\n          return _computed[key];\n        },\n\n        set(value) {\n          const { _computed } = component;\n\n          _computed[key] = cb.set ? cb.set.call(component, value) : value;\n\n          if (isUndefined(_computed[key])) {\n            delete _computed[key];\n          }\n        } });\n\n    }\n\n    function registerEvent(component, event, key) {\n      if (!isPlainObject(event)) {\n        event = { name: key, handler: event };\n      }\n\n      let { name, el, handler, capture, passive, delegate, filter, self } = event;\n      el = isFunction(el) ? el.call(component) : el || component.$el;\n\n      if (isArray(el)) {\n        el.forEach((el) => registerEvent(component, { ...event, el }, key));\n        return;\n      }\n\n      if (!el || filter && !filter.call(component)) {\n        return;\n      }\n\n      component._events.push(\n      on(\n      el,\n      name,\n      delegate ? isString(delegate) ? delegate : delegate.call(component) : null,\n      isString(handler) ? component[handler] : handler.bind(component),\n      { passive, capture, self }));\n\n\n    }\n\n    function notIn(options, key) {\n      return options.every((arr) => !arr || !hasOwn(arr, key));\n    }\n\n    function coerce$1(type, value) {\n      if (type === Boolean) {\n        return toBoolean(value);\n      } else if (type === Number) {\n        return toNumber(value);\n      } else if (type === 'list') {\n        return toList(value);\n      }\n\n      return type ? type(value) : value;\n    }\n\n    function toList(value) {\n      return isArray(value) ?\n      value :\n      isString(value) ?\n      value.\n      split(/,(?![^(]*\\))/).\n      map((value) => isNumeric(value) ? toNumber(value) : toBoolean(value.trim())) :\n      [value];\n    }\n\n    function normalizeData(_ref, _ref2) {let { data = {} } = _ref;let { args = [], props = {} } = _ref2;\n      if (isArray(data)) {\n        data = data.slice(0, args.length).reduce((data, value, index) => {\n          if (isPlainObject(value)) {\n            assign(data, value);\n          } else {\n            data[args[index]] = value;\n          }\n          return data;\n        }, {});\n      }\n\n      for (const key in data) {\n        if (isUndefined(data[key])) {\n          delete data[key];\n        } else if (props[key]) {\n          data[key] = coerce$1(props[key], data[key]);\n        }\n      }\n\n      return data;\n    }\n\n    function initChildListObserver(component) {\n      const { el } = component.$options;\n\n      const observer = new MutationObserver(() => component._callWatches());\n      observer.observe(el, {\n        childList: true,\n        subtree: true });\n\n\n      return observer;\n    }\n\n    function initPropsObserver(component) {\n      const { $options, $props } = component;\n      const { id, attrs, props, el } = $options;\n\n      if (!props || attrs === false) {\n        return;\n      }\n\n      const attributes = isArray(attrs) ? attrs : Object.keys(props);\n      const filter = attributes.map((key) => hyphenate(key)).concat(id);\n\n      const observer = new MutationObserver((records) => {\n        const data = getProps$1($options);\n        if (\n        records.some((_ref3) => {let { attributeName } = _ref3;\n          const prop = attributeName.replace('data-', '');\n          return (prop === id ? attributes : [camelize(prop), camelize(attributeName)]).some(\n          (prop) => !isUndefined(data[prop]) && data[prop] !== $props[prop]);\n\n        }))\n        {\n          component.$reset();\n        }\n      });\n\n      observer.observe(el, {\n        attributes: true,\n        attributeFilter: filter.concat(filter.map((key) => \"data-\" + key)) });\n\n\n      return observer;\n    }\n\n    function instanceAPI (UIkit) {\n      const DATA = UIkit.data;\n\n      UIkit.prototype.$create = function (component, element, data) {\n        return UIkit[component](element, data);\n      };\n\n      UIkit.prototype.$mount = function (el) {\n        const { name } = this.$options;\n\n        if (!el[DATA]) {\n          el[DATA] = {};\n        }\n\n        if (el[DATA][name]) {\n          return;\n        }\n\n        el[DATA][name] = this;\n\n        this.$el = this.$options.el = this.$options.el || el;\n\n        if (within(el, document)) {\n          this._callConnected();\n        }\n      };\n\n      UIkit.prototype.$reset = function () {\n        this._callDisconnected();\n        this._callConnected();\n      };\n\n      UIkit.prototype.$destroy = function (removeEl) {if (removeEl === void 0) {removeEl = false;}\n        const { el, name } = this.$options;\n\n        if (el) {\n          this._callDisconnected();\n        }\n\n        this._callHook('destroy');\n\n        if (!(el != null && el[DATA])) {\n          return;\n        }\n\n        delete el[DATA][name];\n\n        if (!isEmpty(el[DATA])) {\n          delete el[DATA];\n        }\n\n        if (removeEl) {\n          remove$1(this.$el);\n        }\n      };\n\n      UIkit.prototype.$emit = function (e) {\n        this._callUpdate(e);\n      };\n\n      UIkit.prototype.$update = function (element, e) {if (element === void 0) {element = this.$el;}\n        UIkit.update(element, e);\n      };\n\n      UIkit.prototype.$getComponent = UIkit.getComponent;\n\n      Object.defineProperty(\n      UIkit.prototype,\n      '$container',\n      Object.getOwnPropertyDescriptor(UIkit, 'container'));\n\n    }\n\n    const components$3 = {};\n    function componentAPI (UIkit) {\n      const { data: DATA, prefix: PREFIX } = UIkit;\n\n      UIkit.component = function (name, options) {\n        name = hyphenate(name);\n        const id = PREFIX + name;\n\n        if (!options) {\n          if (isPlainObject(components$3[id])) {\n            components$3[id] = components$3[\"data-\" + id] = UIkit.extend(components$3[id]);\n          }\n\n          return components$3[id];\n        }\n\n        name = camelize(name);\n\n        UIkit[name] = function (element, data) {\n          const component = UIkit.component(name);\n\n          return component.options.functional ?\n          new component({ data: isPlainObject(element) ? element : [...arguments] }) :\n          element ?\n          $$(element).map(init)[0] :\n          init();\n\n          function init(element) {\n            const instance = UIkit.getComponent(element, name);\n\n            if (instance) {\n              if (data) {\n                instance.$destroy();\n              } else {\n                return instance;\n              }\n            }\n\n            return new component({ el: element, data });\n          }\n        };\n\n        const opt = isPlainObject(options) ? { ...options } : options.options;\n\n        opt.id = id;\n        opt.name = name;\n\n        opt.install == null ? void 0 : opt.install(UIkit, opt, name);\n\n        if (UIkit._initialized && !opt.functional) {\n          requestAnimationFrame(() => UIkit[name](\"[\" + id + \"],[data-\" + id + \"]\"));\n        }\n\n        return components$3[id] = components$3[\"data-\" + id] = isPlainObject(options) ? opt : options;\n      };\n\n      UIkit.getComponents = (element) => (element == null ? void 0 : element[DATA]) || {};\n      UIkit.getComponent = (element, name) => UIkit.getComponents(element)[name];\n\n      UIkit.connect = (node) => {\n        if (node[DATA]) {\n          for (const name in node[DATA]) {\n            node[DATA][name]._callConnected();\n          }\n        }\n\n        for (const attribute of node.getAttributeNames()) {\n          const name = getComponentName(attribute);\n          name && UIkit[name](node);\n        }\n      };\n\n      UIkit.disconnect = (node) => {\n        for (const name in node[DATA]) {\n          node[DATA][name]._callDisconnected();\n        }\n      };\n    }\n\n    function getComponentName(attribute) {\n      const cmp = components$3[attribute];\n      return cmp && (isPlainObject(cmp) ? cmp : cmp.options).name;\n    }\n\n    const UIkit = function (options) {\n      this._init(options);\n    };\n\n    UIkit.util = util;\n    UIkit.data = '__uikit__';\n    UIkit.prefix = 'uk-';\n    UIkit.options = {};\n    UIkit.version = '3.15.10';\n\n    globalAPI(UIkit);\n    hooksAPI(UIkit);\n    stateAPI(UIkit);\n    componentAPI(UIkit);\n    instanceAPI(UIkit);\n\n    function boot (UIkit) {\n      const { connect, disconnect } = UIkit;\n\n      if (!inBrowser || !window.MutationObserver) {\n        return;\n      }\n\n      requestAnimationFrame(function () {\n        if (document.body) {\n          apply(document.body, connect);\n        }\n\n        new MutationObserver((records) => records.forEach(applyChildListMutation)).observe(\n        document,\n        {\n          childList: true,\n          subtree: true });\n\n\n\n        new MutationObserver((records) => records.forEach(applyAttributeMutation)).observe(\n        document,\n        {\n          attributes: true,\n          subtree: true });\n\n\n\n        UIkit._initialized = true;\n      });\n\n      function applyChildListMutation(_ref) {let { addedNodes, removedNodes } = _ref;\n        for (const node of addedNodes) {\n          apply(node, connect);\n        }\n\n        for (const node of removedNodes) {\n          apply(node, disconnect);\n        }\n      }\n\n      function applyAttributeMutation(_ref2) {let { target, attributeName } = _ref2;\n        const name = getComponentName(attributeName);\n\n        if (name) {var _UIkit$getComponent;\n          if (hasAttr(target, attributeName)) {\n            UIkit[name](target);\n            return;\n          }\n\n          (_UIkit$getComponent = UIkit.getComponent(target, name)) == null ? void 0 : _UIkit$getComponent.$destroy();\n        }\n      }\n    }\n\n    var Class = {\n      connected() {\n        addClass(this.$el, this.$options.id);\n      } };\n\n    var Lazyload = {\n      data: {\n        preload: 5 },\n\n\n      methods: {\n        lazyload(observeTargets, targets) {if (observeTargets === void 0) {observeTargets = this.$el;}if (targets === void 0) {targets = this.$el;}\n          this.registerObserver(\n          observeIntersection(observeTargets, (entries, observer) => {\n            for (const el of toNodes(isFunction(targets) ? targets() : targets)) {\n              $$('[loading=\"lazy\"]', el).\n              slice(0, this.preload - 1).\n              forEach((el) => removeAttr(el, 'loading'));\n            }\n\n            for (const el of entries.\n            filter((_ref) => {let { isIntersecting } = _ref;return isIntersecting;}).\n            map((_ref2) => {let { target } = _ref2;return target;})) {\n              observer.unobserve(el);\n            }\n          }));\n\n        } } };\n\n    var Togglable = {\n      props: {\n        cls: Boolean,\n        animation: 'list',\n        duration: Number,\n        velocity: Number,\n        origin: String,\n        transition: String },\n\n\n      data: {\n        cls: false,\n        animation: [false],\n        duration: 200,\n        velocity: 0.2,\n        origin: false,\n        transition: 'ease',\n        clsEnter: 'uk-togglabe-enter',\n        clsLeave: 'uk-togglabe-leave' },\n\n\n      computed: {\n        hasAnimation(_ref) {let { animation } = _ref;\n          return !!animation[0];\n        },\n\n        hasTransition(_ref2) {let { animation } = _ref2;\n          return ['slide', 'reveal'].some((transition) => startsWith(animation[0], transition));\n        } },\n\n\n      methods: {\n        toggleElement(targets, toggle, animate) {\n          return new Promise((resolve) =>\n          Promise.all(\n          toNodes(targets).map((el) => {\n            const show = isBoolean(toggle) ? toggle : !this.isToggled(el);\n\n            if (!trigger(el, \"before\" + (show ? 'show' : 'hide'), [this])) {\n              return Promise.reject();\n            }\n\n            const promise = (\n            isFunction(animate) ?\n            animate :\n            animate === false || !this.hasAnimation ?\n            toggleInstant :\n            this.hasTransition ?\n            toggleTransition :\n            toggleAnimation)(\n            el, show, this);\n\n            const cls = show ? this.clsEnter : this.clsLeave;\n\n            addClass(el, cls);\n\n            trigger(el, show ? 'show' : 'hide', [this]);\n\n            const done = () => {\n              removeClass(el, cls);\n              trigger(el, show ? 'shown' : 'hidden', [this]);\n            };\n\n            return promise ?\n            promise.then(done, () => {\n              removeClass(el, cls);\n              return Promise.reject();\n            }) :\n            done();\n          })).\n          then(resolve, noop));\n\n        },\n\n        isToggled(el) {if (el === void 0) {el = this.$el;}\n          [el] = toNodes(el);\n          return hasClass(el, this.clsEnter) ?\n          true :\n          hasClass(el, this.clsLeave) ?\n          false :\n          this.cls ?\n          hasClass(el, this.cls.split(' ')[0]) :\n          isVisible(el);\n        },\n\n        _toggle(el, toggled) {\n          if (!el) {\n            return;\n          }\n\n          toggled = Boolean(toggled);\n\n          let changed;\n          if (this.cls) {\n            changed = includes(this.cls, ' ') || toggled !== hasClass(el, this.cls);\n            changed && toggleClass(el, this.cls, includes(this.cls, ' ') ? undefined : toggled);\n          } else {\n            changed = toggled === el.hidden;\n            changed && (el.hidden = !toggled);\n          }\n\n          $$('[autofocus]', el).some((el) => isVisible(el) ? el.focus() || true : el.blur());\n\n          if (changed) {\n            trigger(el, 'toggled', [toggled, this]);\n          }\n        } } };\n\n\n\n    function toggleInstant(el, show, _ref3) {let { _toggle } = _ref3;\n      Animation.cancel(el);\n      Transition.cancel(el);\n      return _toggle(el, show);\n    }\n\n    async function toggleTransition(\n    el,\n    show, _ref4)\n\n    {var _animation$;let { animation, duration, velocity, transition, _toggle } = _ref4;\n      const [mode = 'reveal', startProp = 'top'] = ((_animation$ = animation[0]) == null ? void 0 : _animation$.split('-')) || [];\n\n      const dirs = [\n      ['left', 'right'],\n      ['top', 'bottom']];\n\n      const dir = dirs[includes(dirs[0], startProp) ? 0 : 1];\n      const end = dir[1] === startProp;\n      const props = ['width', 'height'];\n      const dimProp = props[dirs.indexOf(dir)];\n      const marginProp = \"margin-\" + dir[0];\n      const marginStartProp = \"margin-\" + startProp;\n\n      let currentDim = dimensions$1(el)[dimProp];\n\n      const inProgress = Transition.inProgress(el);\n      await Transition.cancel(el);\n\n      if (show) {\n        _toggle(el, true);\n      }\n\n      const prevProps = Object.fromEntries(\n      [\n      'padding',\n      'border',\n      'width',\n      'height',\n      'minWidth',\n      'minHeight',\n      'overflowY',\n      'overflowX',\n      marginProp,\n      marginStartProp].\n      map((key) => [key, el.style[key]]));\n\n\n      const dim = dimensions$1(el);\n      const currentMargin = toFloat(css(el, marginProp));\n      const marginStart = toFloat(css(el, marginStartProp));\n      const endDim = dim[dimProp] + marginStart;\n\n      if (!inProgress && !show) {\n        currentDim += marginStart;\n      }\n\n      const [wrapper] = wrapInner(el, '<div>');\n      css(wrapper, {\n        boxSizing: 'border-box',\n        height: dim.height,\n        width: dim.width,\n        ...css(el, [\n        'overflow',\n        'padding',\n        'borderTop',\n        'borderRight',\n        'borderBottom',\n        'borderLeft',\n        'borderImage',\n        marginStartProp]) });\n\n\n\n      css(el, {\n        padding: 0,\n        border: 0,\n        minWidth: 0,\n        minHeight: 0,\n        [marginStartProp]: 0,\n        width: dim.width,\n        height: dim.height,\n        overflow: 'hidden',\n        [dimProp]: currentDim });\n\n\n      const percent = currentDim / endDim;\n      duration = (velocity * endDim + duration) * (show ? 1 - percent : percent);\n      const endProps = { [dimProp]: show ? endDim : 0 };\n\n      if (end) {\n        css(el, marginProp, endDim - currentDim + currentMargin);\n        endProps[marginProp] = show ? currentMargin : endDim + currentMargin;\n      }\n\n      if (!end ^ mode === 'reveal') {\n        css(wrapper, marginProp, -endDim + currentDim);\n        Transition.start(wrapper, { [marginProp]: show ? 0 : -endDim }, duration, transition);\n      }\n\n      try {\n        await Transition.start(el, endProps, duration, transition);\n      } finally {\n        css(el, prevProps);\n        unwrap(wrapper.firstChild);\n\n        if (!show) {\n          _toggle(el, false);\n        }\n      }\n    }\n\n    function toggleAnimation(el, show, cmp) {\n      Animation.cancel(el);\n\n      const { animation, duration, _toggle } = cmp;\n\n      if (show) {\n        _toggle(el, true);\n        return Animation.in(el, animation[0], duration, cmp.origin);\n      }\n\n      return Animation.out(el, animation[1] || animation[0], duration, cmp.origin).then(() =>\n      _toggle(el, false));\n\n    }\n\n    var Accordion = {\n      mixins: [Class, Lazyload, Togglable],\n\n      props: {\n        animation: Boolean,\n        targets: String,\n        active: null,\n        collapsible: Boolean,\n        multiple: Boolean,\n        toggle: String,\n        content: String,\n        offset: Number },\n\n\n      data: {\n        targets: '> *',\n        active: false,\n        animation: true,\n        collapsible: true,\n        multiple: false,\n        clsOpen: 'uk-open',\n        toggle: '> .uk-accordion-title',\n        content: '> .uk-accordion-content',\n        offset: 0 },\n\n\n      computed: {\n        items: {\n          get(_ref, $el) {let { targets } = _ref;\n            return $$(targets, $el);\n          },\n\n          watch(items, prev) {\n            if (prev || hasClass(items, this.clsOpen)) {\n              return;\n            }\n\n            const active =\n            this.active !== false && items[Number(this.active)] ||\n            !this.collapsible && items[0];\n\n            if (active) {\n              this.toggle(active, false);\n            }\n          },\n\n          immediate: true },\n\n\n        toggles(_ref2) {let { toggle } = _ref2;\n          return this.items.map((item) => $(toggle, item));\n        },\n\n        contents: {\n          get(_ref3) {let { content } = _ref3;\n            return this.items.map((item) => $(content, item));\n          },\n\n          watch(items) {\n            for (const el of items) {\n              hide(\n              el,\n              !hasClass(\n              this.items.find((item) => within(el, item)),\n              this.clsOpen));\n\n\n            }\n          },\n\n          immediate: true } },\n\n\n\n      connected() {\n        this.lazyload();\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return this.targets + \" \" + this.$props.toggle;\n        },\n\n        async handler(e) {var _this$_off;\n          e.preventDefault();\n\n          (_this$_off = this._off) == null ? void 0 : _this$_off.call(this);\n          this._off = keepScrollPosition(e.target);\n          await this.toggle(index(this.toggles, e.current));\n          this._off();\n        } }],\n\n\n\n      methods: {\n        async toggle(item, animate) {\n          item = this.items[getIndex(item, this.items)];\n          let items = [item];\n          const activeItems = filter$1(this.items, \".\" + this.clsOpen);\n\n          if (!this.multiple && !includes(activeItems, items[0])) {\n            items = items.concat(activeItems);\n          }\n\n          if (!this.collapsible && activeItems.length < 2 && includes(activeItems, item)) {\n            return;\n          }\n\n          await Promise.all(\n          items.map((el) =>\n          this.toggleElement(el, !includes(activeItems, el), (el, show) => {\n            toggleClass(el, this.clsOpen, show);\n            attr($(this.$props.toggle, el), 'aria-expanded', show);\n\n            if (animate === false || !this.animation) {\n              hide($(this.content, el), !show);\n              return;\n            }\n\n            return transition(el, show, this);\n          })));\n\n\n        } } };\n\n\n\n    function hide(el, hide) {\n      el && (el.hidden = hide);\n    }\n\n    async function transition(el, show, _ref4) {var _el$_wrapper;let { content, duration, velocity, transition } = _ref4;\n      content = ((_el$_wrapper = el._wrapper) == null ? void 0 : _el$_wrapper.firstElementChild) || $(content, el);\n\n      if (!el._wrapper) {\n        el._wrapper = wrapAll(content, '<div>');\n      }\n\n      const wrapper = el._wrapper;\n      css(wrapper, 'overflow', 'hidden');\n      const currentHeight = toFloat(css(wrapper, 'height'));\n\n      await Transition.cancel(wrapper);\n      hide(content, false);\n\n      const endHeight =\n      toFloat(css(content, 'height')) +\n      toFloat(css(content, 'marginTop')) +\n      toFloat(css(content, 'marginBottom'));\n      const percent = currentHeight / endHeight;\n      duration = (velocity * endHeight + duration) * (show ? 1 - percent : percent);\n      css(wrapper, 'height', currentHeight);\n\n      await Transition.start(wrapper, { height: show ? endHeight : 0 }, duration, transition);\n\n      unwrap(content);\n      delete el._wrapper;\n\n      if (!show) {\n        hide(content, true);\n      }\n    }\n\n    function keepScrollPosition(el) {\n      const scrollParent = scrollParents(el)[0];\n      let frame;\n      (function scroll() {\n        frame = requestAnimationFrame(() => {\n          const { top } = el.getBoundingClientRect();\n          if (top < 0) {\n            scrollParent.scrollTop += top;\n          }\n          scroll();\n        });\n      })();\n\n      return () => requestAnimationFrame(() => cancelAnimationFrame(frame));\n    }\n\n    var alert = {\n      mixins: [Class, Togglable],\n\n      args: 'animation',\n\n      props: {\n        animation: Boolean,\n        close: String },\n\n\n      data: {\n        animation: true,\n        selClose: '.uk-alert-close',\n        duration: 150 },\n\n\n      events: {\n        name: 'click',\n\n        delegate() {\n          return this.selClose;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.close();\n        } },\n\n\n      methods: {\n        async close() {\n          await this.toggleElement(this.$el, false, animate$1);\n          this.$destroy(true);\n        } } };\n\n\n\n    function animate$1(el, show, _ref) {let { duration, transition, velocity } = _ref;\n      const height = toFloat(css(el, 'height'));\n      css(el, 'height', height);\n      return Transition.start(\n      el,\n      {\n        height: 0,\n        marginTop: 0,\n        marginBottom: 0,\n        paddingTop: 0,\n        paddingBottom: 0,\n        borderTop: 0,\n        borderBottom: 0,\n        opacity: 0 },\n\n      velocity * height + duration,\n      transition);\n\n    }\n\n    var Video = {\n      args: 'autoplay',\n\n      props: {\n        automute: Boolean,\n        autoplay: Boolean },\n\n\n      data: {\n        automute: false,\n        autoplay: true },\n\n\n      connected() {\n        this.inView = this.autoplay === 'inview';\n\n        if (this.inView && !hasAttr(this.$el, 'preload')) {\n          this.$el.preload = 'none';\n        }\n\n        if (isTag(this.$el, 'iframe') && !hasAttr(this.$el, 'allow')) {\n          this.$el.allow = 'autoplay';\n        }\n\n        if (this.automute) {\n          mute(this.$el);\n        }\n\n        this.registerObserver(observeIntersection(this.$el, () => this.$emit(), {}, false));\n      },\n\n      update: {\n        read() {\n          if (!isVideo(this.$el)) {\n            return false;\n          }\n\n          return {\n            visible: isVisible(this.$el) && css(this.$el, 'visibility') !== 'hidden',\n            inView: this.inView && isInView(this.$el) };\n\n        },\n\n        write(_ref) {let { visible, inView } = _ref;\n          if (!visible || this.inView && !inView) {\n            pause(this.$el);\n          } else if (this.autoplay === true || this.inView && inView) {\n            play(this.$el);\n          }\n        } } };\n\n    var Resize = {\n      connected() {var _this$$options$resize;\n        this.registerObserver(\n        observeResize(((_this$$options$resize = this.$options.resizeTargets) == null ? void 0 : _this$$options$resize.call(this)) || this.$el, () =>\n        this.$emit('resize')));\n\n\n      } };\n\n    var cover = {\n      mixins: [Resize, Video],\n\n      props: {\n        width: Number,\n        height: Number },\n\n\n      data: {\n        automute: true },\n\n\n      events: {\n        'load loadedmetadata'() {\n          this.$emit('resize');\n        } },\n\n\n      resizeTargets() {\n        return [this.$el, getPositionedParent(this.$el) || parent(this.$el)];\n      },\n\n      update: {\n        read() {\n          const { ratio, cover } = Dimensions;\n          const { $el, width, height } = this;\n\n          let dim = { width, height };\n\n          if (!dim.width || !dim.height) {\n            const intrinsic = {\n              width: $el.naturalWidth || $el.videoWidth || $el.clientWidth,\n              height: $el.naturalHeight || $el.videoHeight || $el.clientHeight };\n\n\n            if (dim.width) {\n              dim = ratio(intrinsic, 'width', dim.width);\n            } else if (height) {\n              dim = ratio(intrinsic, 'height', dim.height);\n            } else {\n              dim = intrinsic;\n            }\n          }\n\n          const { offsetHeight: coverHeight, offsetWidth: coverWidth } =\n          getPositionedParent($el) || parent($el);\n          const coverDim = cover(dim, {\n            width: coverWidth + (coverWidth % 2 ? 1 : 0),\n            height: coverHeight + (coverHeight % 2 ? 1 : 0) });\n\n\n          if (!coverDim.width || !coverDim.height) {\n            return false;\n          }\n\n          return coverDim;\n        },\n\n        write(_ref) {let { height, width } = _ref;\n          css(this.$el, { height, width });\n        },\n\n        events: ['resize'] } };\n\n\n\n    function getPositionedParent(el) {\n      while (el = parent(el)) {\n        if (css(el, 'position') !== 'static') {\n          return el;\n        }\n      }\n    }\n\n    var Container = {\n      props: {\n        container: Boolean },\n\n\n      data: {\n        container: true },\n\n\n      computed: {\n        container(_ref) {let { container } = _ref;\n          return container === true && this.$container || container && $(container);\n        } } };\n\n    var Position = {\n      props: {\n        pos: String,\n        offset: null,\n        flip: Boolean,\n        shift: Boolean,\n        inset: Boolean },\n\n\n      data: {\n        pos: \"bottom-\" + (isRtl ? 'right' : 'left'),\n        offset: false,\n        flip: true,\n        shift: true,\n        inset: false },\n\n\n      connected() {\n        this.pos = this.$props.pos.split('-').concat('center').slice(0, 2);\n        [this.dir, this.align] = this.pos;\n        this.axis = includes(['top', 'bottom'], this.dir) ? 'y' : 'x';\n      },\n\n      methods: {\n        positionAt(element, target, boundary) {\n          let offset = [this.getPositionOffset(element), this.getShiftOffset(element)];\n          const placement = [this.flip && 'flip', this.shift && 'shift'];\n\n          const attach = {\n            element: [this.inset ? this.dir : flipPosition(this.dir), this.align],\n            target: [this.dir, this.align] };\n\n\n          if (this.axis === 'y') {\n            for (const prop in attach) {\n              attach[prop].reverse();\n            }\n            offset.reverse();\n            placement.reverse();\n          }\n\n          const [scrollElement] = scrollParents(element, /auto|scroll/);\n          const { scrollTop, scrollLeft } = scrollElement;\n\n          // Ensure none positioned element does not generate scrollbars\n          const elDim = dimensions$1(element);\n          css(element, { top: -elDim.height, left: -elDim.width });\n\n          positionAt(element, target, {\n            attach,\n            offset,\n            boundary,\n            placement,\n            viewportOffset: this.getViewportOffset(element) });\n\n\n          // Restore scroll position\n          scrollElement.scrollTop = scrollTop;\n          scrollElement.scrollLeft = scrollLeft;\n        },\n\n        getPositionOffset(element) {\n          return (\n            toPx(\n            this.offset === false ? css(element, '--uk-position-offset') : this.offset,\n            this.axis === 'x' ? 'width' : 'height',\n            element) * (\n\n            includes(['left', 'top'], this.dir) ? -1 : 1) * (\n            this.inset ? -1 : 1));\n\n        },\n\n        getShiftOffset(element) {\n          return this.align === 'center' ?\n          0 :\n          toPx(\n          css(element, '--uk-position-shift-offset'),\n          this.axis === 'y' ? 'width' : 'height',\n          element) * (\n          includes(['left', 'top'], this.align) ? 1 : -1);\n        },\n\n        getViewportOffset(element) {\n          return toPx(css(element, '--uk-position-viewport-offset'));\n        } } };\n\n    var Style = {\n      beforeConnect() {\n        this._style = attr(this.$el, 'style');\n      },\n\n      disconnected() {\n        attr(this.$el, 'style', this._style);\n      } };\n\n    const active$1 = [];\n\n    var Modal = {\n      mixins: [Class, Container, Togglable],\n\n      props: {\n        selPanel: String,\n        selClose: String,\n        escClose: Boolean,\n        bgClose: Boolean,\n        stack: Boolean },\n\n\n      data: {\n        cls: 'uk-open',\n        escClose: true,\n        bgClose: true,\n        overlay: true,\n        stack: false },\n\n\n      computed: {\n        panel(_ref, $el) {let { selPanel } = _ref;\n          return $(selPanel, $el);\n        },\n\n        transitionElement() {\n          return this.panel;\n        },\n\n        bgClose(_ref2) {let { bgClose } = _ref2;\n          return bgClose && this.panel;\n        } },\n\n\n      beforeDisconnect() {\n        if (includes(active$1, this)) {\n          this.toggleElement(this.$el, false, false);\n        }\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return this.selClose;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.hide();\n        } },\n\n\n      {\n        name: 'click',\n\n        delegate() {\n          return 'a[href*=\"#\"]';\n        },\n\n        handler(_ref3) {let { current, defaultPrevented } = _ref3;\n          const { hash } = current;\n          if (\n          !defaultPrevented &&\n          hash &&\n          isSameSiteAnchor(current) &&\n          !within(hash, this.$el) &&\n          $(hash, document.body))\n          {\n            this.hide();\n          }\n        } },\n\n\n      {\n        name: 'toggle',\n\n        self: true,\n\n        handler(e) {\n          if (e.defaultPrevented) {\n            return;\n          }\n\n          e.preventDefault();\n\n          if (this.isToggled() === includes(active$1, this)) {\n            this.toggle();\n          }\n        } },\n\n\n      {\n        name: 'beforeshow',\n\n        self: true,\n\n        handler(e) {\n          if (includes(active$1, this)) {\n            return false;\n          }\n\n          if (!this.stack && active$1.length) {\n            Promise.all(active$1.map((modal) => modal.hide())).then(this.show);\n            e.preventDefault();\n          } else {\n            active$1.push(this);\n          }\n        } },\n\n\n      {\n        name: 'show',\n\n        self: true,\n\n        handler() {\n          once(\n          this.$el,\n          'hide',\n          on(document, 'focusin', (e) => {\n            if (last(active$1) === this && !within(e.target, this.$el)) {\n              this.$el.focus();\n            }\n          }));\n\n\n          if (this.overlay) {\n            once(this.$el, 'hidden', preventOverscroll(this.$el), { self: true });\n            once(this.$el, 'hidden', preventBackgroundScroll(), { self: true });\n          }\n\n          if (this.stack) {\n            css(this.$el, 'zIndex', toFloat(css(this.$el, 'zIndex')) + active$1.length);\n          }\n\n          addClass(document.documentElement, this.clsPage);\n\n          if (this.bgClose) {\n            once(\n            this.$el,\n            'hide',\n            on(document, pointerDown$1, (_ref4) => {let { target } = _ref4;\n              if (\n              last(active$1) !== this ||\n              this.overlay && !within(target, this.$el) ||\n              within(target, this.panel))\n              {\n                return;\n              }\n\n              once(\n              document,\n              pointerUp$1 + \" \" + pointerCancel + \" scroll\",\n              (_ref5) => {let { defaultPrevented, type, target: newTarget } = _ref5;\n                if (\n                !defaultPrevented &&\n                type === pointerUp$1 &&\n                target === newTarget)\n                {\n                  this.hide();\n                }\n              },\n              true);\n\n            }),\n            { self: true });\n\n          }\n\n          if (this.escClose) {\n            once(\n            this.$el,\n            'hide',\n            on(document, 'keydown', (e) => {\n              if (e.keyCode === 27 && last(active$1) === this) {\n                this.hide();\n              }\n            }),\n            { self: true });\n\n          }\n        } },\n\n\n      {\n        name: 'shown',\n\n        self: true,\n\n        handler() {\n          if (!isFocusable(this.$el)) {\n            attr(this.$el, 'tabindex', '-1');\n          }\n\n          if (!$(':focus', this.$el)) {\n            this.$el.focus();\n          }\n        } },\n\n\n      {\n        name: 'hidden',\n\n        self: true,\n\n        handler() {\n          if (includes(active$1, this)) {\n            active$1.splice(active$1.indexOf(this), 1);\n          }\n\n          css(this.$el, 'zIndex', '');\n\n          if (!active$1.some((modal) => modal.clsPage === this.clsPage)) {\n            removeClass(document.documentElement, this.clsPage);\n          }\n        } }],\n\n\n\n      methods: {\n        toggle() {\n          return this.isToggled() ? this.hide() : this.show();\n        },\n\n        show() {\n          if (this.container && parent(this.$el) !== this.container) {\n            append(this.container, this.$el);\n            return new Promise((resolve) =>\n            requestAnimationFrame(() => this.show().then(resolve)));\n\n          }\n\n          return this.toggleElement(this.$el, true, animate);\n        },\n\n        hide() {\n          return this.toggleElement(this.$el, false, animate);\n        } } };\n\n\n\n    function animate(el, show, _ref6) {let { transitionElement, _toggle } = _ref6;\n      return new Promise((resolve, reject) =>\n      once(el, 'show hide', () => {\n        el._reject == null ? void 0 : el._reject();\n        el._reject = reject;\n\n        _toggle(el, show);\n\n        const off = once(\n        transitionElement,\n        'transitionstart',\n        () => {\n          once(transitionElement, 'transitionend transitioncancel', resolve, {\n            self: true });\n\n          clearTimeout(timer);\n        },\n        { self: true });\n\n\n        const timer = setTimeout(() => {\n          off();\n          resolve();\n        }, toMs(css(transitionElement, 'transitionDuration')));\n      })).\n      then(() => delete el._reject);\n    }\n\n    function toMs(time) {\n      return time ? endsWith(time, 'ms') ? toFloat(time) : toFloat(time) * 1000 : 0;\n    }\n\n    function preventOverscroll(el) {\n      if (CSS.supports('overscroll-behavior', 'contain')) {\n        const elements = filterChildren(el, (child) => /auto|scroll/.test(css(child, 'overflow')));\n        css(elements, 'overscrollBehavior', 'contain');\n        return () => css(elements, 'overscrollBehavior', '');\n      }\n\n      let startClientY;\n\n      const events = [\n      on(\n      el,\n      'touchstart',\n      (_ref7) => {let { targetTouches } = _ref7;\n        if (targetTouches.length === 1) {\n          startClientY = targetTouches[0].clientY;\n        }\n      },\n      { passive: true }),\n\n\n      on(\n      el,\n      'touchmove',\n      (e) => {\n        if (e.targetTouches.length !== 1) {\n          return;\n        }\n\n        let [scrollParent] = scrollParents(e.target, /auto|scroll/);\n        if (!within(scrollParent, el)) {\n          scrollParent = el;\n        }\n\n        const clientY = e.targetTouches[0].clientY - startClientY;\n        const { scrollTop, scrollHeight, clientHeight } = scrollParent;\n\n        if (\n        clientHeight >= scrollHeight ||\n        scrollTop === 0 && clientY > 0 ||\n        scrollHeight - scrollTop <= clientHeight && clientY < 0)\n        {\n          e.cancelable && e.preventDefault();\n        }\n      },\n      { passive: false })];\n\n\n\n      return () => events.forEach((fn) => fn());\n    }\n\n    let prevented;\n    function preventBackgroundScroll() {\n      if (prevented) {\n        return noop;\n      }\n      prevented = true;\n\n      const { scrollingElement } = document;\n      css(scrollingElement, {\n        overflowY: 'hidden',\n        touchAction: 'none',\n        paddingRight: width(window) - scrollingElement.clientWidth });\n\n      return () => {\n        prevented = false;\n        css(scrollingElement, { overflowY: '', touchAction: '', paddingRight: '' });\n      };\n    }\n\n    function filterChildren(el, fn) {\n      const children = [];\n      apply(el, (node) => {\n        if (fn(node)) {\n          children.push(node);\n        }\n      });\n      return children;\n    }\n\n    function isSameSiteAnchor(a) {\n      return ['origin', 'pathname', 'search'].every((part) => a[part] === location[part]);\n    }\n\n    let active;\n\n    var drop = {\n      mixins: [Container, Lazyload, Position, Style, Togglable],\n\n      args: 'pos',\n\n      props: {\n        mode: 'list',\n        toggle: Boolean,\n        boundary: Boolean,\n        boundaryX: Boolean,\n        boundaryY: Boolean,\n        target: Boolean,\n        targetX: Boolean,\n        targetY: Boolean,\n        stretch: Boolean,\n        delayShow: Number,\n        delayHide: Number,\n        autoUpdate: Boolean,\n        clsDrop: String,\n        animateOut: Boolean,\n        bgScroll: Boolean },\n\n\n      data: {\n        mode: ['click', 'hover'],\n        toggle: '- *',\n        boundary: false,\n        boundaryX: false,\n        boundaryY: false,\n        target: false,\n        targetX: false,\n        targetY: false,\n        stretch: false,\n        delayShow: 0,\n        delayHide: 800,\n        autoUpdate: true,\n        clsDrop: false,\n        animateOut: false,\n        bgScroll: true,\n        animation: ['uk-animation-fade'],\n        cls: 'uk-open',\n        container: false },\n\n\n      computed: {\n        boundary(_ref, $el) {let { boundary, boundaryX, boundaryY } = _ref;\n          return [\n          query(boundaryX || boundary, $el) || window,\n          query(boundaryY || boundary, $el) || window];\n\n        },\n\n        target(_ref2, $el) {let { target, targetX, targetY } = _ref2;\n          targetX = targetX || target || this.targetEl;\n          targetY = targetY || target || this.targetEl;\n\n          return [\n          targetX === true ? window : query(targetX, $el),\n          targetY === true ? window : query(targetY, $el)];\n\n        } },\n\n\n      created() {\n        this.tracker = new MouseTracker();\n      },\n\n      beforeConnect() {\n        this.clsDrop = this.$props.clsDrop || \"uk-\" + this.$options.name;\n      },\n\n      connected() {\n        addClass(this.$el, this.clsDrop);\n\n        if (this.toggle && !this.targetEl) {\n          this.targetEl = this.$create('toggle', query(this.toggle, this.$el), {\n            target: this.$el,\n            mode: this.mode }).\n          $el;\n          attr(this.targetEl, 'aria-haspopup', true);\n          this.lazyload(this.targetEl);\n        }\n      },\n\n      disconnected() {\n        if (this.isActive()) {\n          this.hide(false);\n          active = null;\n        }\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return \".\" + this.clsDrop + \"-close\";\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.hide(false);\n        } },\n\n\n      {\n        name: 'click',\n\n        delegate() {\n          return 'a[href*=\"#\"]';\n        },\n\n        handler(_ref3) {let { defaultPrevented, current } = _ref3;\n          const { hash } = current;\n          if (\n          !defaultPrevented &&\n          hash &&\n          isSameSiteAnchor(current) &&\n          !within(hash, this.$el))\n          {\n            this.hide(false);\n          }\n        } },\n\n\n      {\n        name: 'beforescroll',\n\n        handler() {\n          this.hide(false);\n        } },\n\n\n      {\n        name: 'toggle',\n\n        self: true,\n\n        handler(e, toggle) {\n          e.preventDefault();\n\n          if (this.isToggled()) {\n            this.hide(false);\n          } else {\n            this.show(toggle == null ? void 0 : toggle.$el, false);\n          }\n        } },\n\n\n      {\n        name: 'toggleshow',\n\n        self: true,\n\n        handler(e, toggle) {\n          e.preventDefault();\n          this.show(toggle == null ? void 0 : toggle.$el);\n        } },\n\n\n      {\n        name: 'togglehide',\n\n        self: true,\n\n        handler(e) {\n          e.preventDefault();\n          if (!matches(this.$el, ':focus,:hover')) {\n            this.hide();\n          }\n        } },\n\n\n      {\n        name: pointerEnter + \" focusin\",\n\n        filter() {\n          return includes(this.mode, 'hover');\n        },\n\n        handler(e) {\n          if (!isTouch(e)) {\n            this.clearTimers();\n          }\n        } },\n\n\n      {\n        name: pointerLeave + \" focusout\",\n\n        filter() {\n          return includes(this.mode, 'hover');\n        },\n\n        handler(e) {\n          if (!isTouch(e) && e.relatedTarget) {\n            this.hide();\n          }\n        } },\n\n\n      {\n        name: 'toggled',\n\n        self: true,\n\n        handler(e, toggled) {\n          if (!toggled) {\n            return;\n          }\n\n          this.clearTimers();\n          this.position();\n        } },\n\n\n      {\n        name: 'show',\n\n        self: true,\n\n        handler() {\n          active = this;\n\n          this.tracker.init();\n\n          const update = () => this.$emit();\n          const handlers = [\n          on(\n          document,\n          pointerDown$1,\n          (_ref4) => {let { target } = _ref4;return (\n              !within(target, this.$el) &&\n              once(\n              document,\n              pointerUp$1 + \" \" + pointerCancel + \" scroll\",\n              (_ref5) => {let { defaultPrevented, type, target: newTarget } = _ref5;\n                if (\n                !defaultPrevented &&\n                type === pointerUp$1 &&\n                target === newTarget &&\n                !(this.targetEl && within(target, this.targetEl)))\n                {\n                  this.hide(false);\n                }\n              },\n              true));}),\n\n\n\n          on(document, 'keydown', (e) => {\n            if (e.keyCode === 27) {\n              this.hide(false);\n            }\n          }),\n\n          on(window, 'resize', update),\n\n          (() => {\n            const observer = observeResize(\n            scrollParents(this.$el).concat(this.target),\n            update);\n\n            return () => observer.disconnect();\n          })(),\n\n          ...(this.autoUpdate ?\n          [\n          on([document, scrollParents(this.$el)], 'scroll', update, {\n            passive: true })] :\n\n\n          []),\n\n          ...(this.bgScroll ?\n          [] :\n          [preventOverscroll(this.$el), preventBackgroundScroll()])];\n\n\n          once(this.$el, 'hide', () => handlers.forEach((handler) => handler()), {\n            self: true });\n\n        } },\n\n\n      {\n        name: 'beforehide',\n\n        self: true,\n\n        handler() {\n          this.clearTimers();\n        } },\n\n\n      {\n        name: 'hide',\n\n        handler(_ref6) {let { target } = _ref6;\n          if (this.$el !== target) {\n            active =\n            active === null && within(target, this.$el) && this.isToggled() ?\n            this :\n            active;\n            return;\n          }\n\n          active = this.isActive() ? null : active;\n          this.tracker.cancel();\n        } }],\n\n\n\n      update: {\n        write() {\n          if (this.isToggled() && !hasClass(this.$el, this.clsEnter)) {\n            this.position();\n          }\n        } },\n\n\n      methods: {\n        show(target, delay) {if (target === void 0) {target = this.targetEl;}if (delay === void 0) {delay = true;}\n          if (this.isToggled() && target && this.targetEl && target !== this.targetEl) {\n            this.hide(false, false);\n          }\n\n          this.targetEl = target;\n\n          this.clearTimers();\n\n          if (this.isActive()) {\n            return;\n          }\n\n          if (active) {\n            if (delay && active.isDelaying) {\n              this.showTimer = setTimeout(() => matches(target, ':hover') && this.show(), 10);\n              return;\n            }\n\n            let prev;\n            while (active && prev !== active && !within(this.$el, active.$el)) {\n              prev = active;\n              active.hide(false, false);\n            }\n          }\n\n          if (this.container && parent(this.$el) !== this.container) {\n            append(this.container, this.$el);\n          }\n\n          this.showTimer = setTimeout(\n          () => this.toggleElement(this.$el, true),\n          delay && this.delayShow || 0);\n\n        },\n\n        hide(delay, animate) {if (delay === void 0) {delay = true;}if (animate === void 0) {animate = true;}\n          const hide = () => this.toggleElement(this.$el, false, this.animateOut && animate);\n\n          this.clearTimers();\n\n          this.isDelaying = getPositionedElements(this.$el).some((el) =>\n          this.tracker.movesTo(el));\n\n\n          if (delay && this.isDelaying) {\n            this.hideTimer = setTimeout(this.hide, 50);\n          } else if (delay && this.delayHide) {\n            this.hideTimer = setTimeout(hide, this.delayHide);\n          } else {\n            hide();\n          }\n        },\n\n        clearTimers() {\n          clearTimeout(this.showTimer);\n          clearTimeout(this.hideTimer);\n          this.showTimer = null;\n          this.hideTimer = null;\n          this.isDelaying = false;\n        },\n\n        isActive() {\n          return active === this;\n        },\n\n        position() {\n          removeClass(this.$el, this.clsDrop + \"-stack\");\n          attr(this.$el, 'style', this._style);\n\n          // Ensure none positioned element does not generate scrollbars\n          this.$el.hidden = true;\n\n          const viewports = this.target.map((target) => offsetViewport(scrollParents(target)[0]));\n          const viewportOffset = this.getViewportOffset(this.$el);\n\n          const dirs = [\n          [0, ['x', 'width', 'left', 'right']],\n          [1, ['y', 'height', 'top', 'bottom']]];\n\n\n          for (const [i, [axis, prop]] of dirs) {\n            if (this.axis !== axis && includes([axis, true], this.stretch)) {\n              css(this.$el, {\n                [prop]: Math.min(\n                offset(this.boundary[i])[prop],\n                viewports[i][prop] - 2 * viewportOffset),\n\n                [\"overflow-\" + axis]: 'auto' });\n\n            }\n          }\n\n          const maxWidth = viewports[0].width - 2 * viewportOffset;\n\n          if (this.$el.offsetWidth > maxWidth) {\n            addClass(this.$el, this.clsDrop + \"-stack\");\n          }\n\n          css(this.$el, 'maxWidth', maxWidth);\n\n          this.$el.hidden = false;\n\n          this.positionAt(this.$el, this.target, this.boundary);\n\n          for (const [i, [axis, prop, start, end]] of dirs) {\n            if (this.axis === axis && includes([axis, true], this.stretch)) {\n              const positionOffset = Math.abs(this.getPositionOffset(this.$el));\n              const targetOffset = offset(this.target[i]);\n              const elOffset = offset(this.$el);\n\n              css(this.$el, {\n                [prop]:\n                (targetOffset[start] > elOffset[start] ?\n                targetOffset[start] -\n                Math.max(\n                offset(this.boundary[i])[start],\n                viewports[i][start] + viewportOffset) :\n\n                Math.min(\n                offset(this.boundary[i])[end],\n                viewports[i][end] - viewportOffset) -\n                targetOffset[end]) - positionOffset,\n                [\"overflow-\" + axis]: 'auto' });\n\n\n              this.positionAt(this.$el, this.target, this.boundary);\n            }\n          }\n        } } };\n\n\n\n    function getPositionedElements(el) {\n      const result = [];\n      apply(el, (el) => css(el, 'position') !== 'static' && result.push(el));\n      return result;\n    }\n\n    var formCustom = {\n      mixins: [Class],\n\n      args: 'target',\n\n      props: {\n        target: Boolean },\n\n\n      data: {\n        target: false },\n\n\n      computed: {\n        input(_, $el) {\n          return $(selInput, $el);\n        },\n\n        state() {\n          return this.input.nextElementSibling;\n        },\n\n        target(_ref, $el) {let { target } = _ref;\n          return (\n            target && (\n            target === true && parent(this.input) === $el && this.input.nextElementSibling ||\n            $(target, $el)));\n\n        } },\n\n\n      update() {var _input$files;\n        const { target, input } = this;\n\n        if (!target) {\n          return;\n        }\n\n        let option;\n        const prop = isInput(target) ? 'value' : 'textContent';\n        const prev = target[prop];\n        const value = (_input$files = input.files) != null && _input$files[0] ?\n        input.files[0].name :\n        matches(input, 'select') && (\n        option = $$('option', input).filter((el) => el.selected)[0]) // eslint-disable-line prefer-destructuring\n        ? option.textContent :\n        input.value;\n\n        if (prev !== value) {\n          target[prop] = value;\n        }\n      },\n\n      events: [\n      {\n        name: 'change',\n\n        handler() {\n          this.$emit();\n        } },\n\n\n      {\n        name: 'reset',\n\n        el() {\n          return closest(this.$el, 'form');\n        },\n\n        handler() {\n          this.$emit();\n        } }] };\n\n    var Margin = {\n      mixins: [Resize],\n\n      props: {\n        margin: String,\n        firstColumn: Boolean },\n\n\n      data: {\n        margin: 'uk-margin-small-top',\n        firstColumn: 'uk-first-column' },\n\n\n      resizeTargets() {\n        return [this.$el, ...toArray(this.$el.children)];\n      },\n\n      connected() {\n        this.registerObserver(\n        observeMutation(this.$el, () => this.$reset(), {\n          childList: true }));\n\n\n      },\n\n      update: {\n        read() {\n          const rows = getRows(this.$el.children);\n\n          return {\n            rows,\n            columns: getColumns(rows) };\n\n        },\n\n        write(_ref) {let { columns, rows } = _ref;\n          for (const row of rows) {\n            for (const column of row) {\n              toggleClass(column, this.margin, rows[0] !== row);\n              toggleClass(column, this.firstColumn, columns[0].includes(column));\n            }\n          }\n        },\n\n        events: ['resize'] } };\n\n\n\n    function getRows(items) {\n      return sortBy(items, 'top', 'bottom');\n    }\n\n    function getColumns(rows) {\n      const columns = [];\n\n      for (const row of rows) {\n        const sorted = sortBy(row, 'left', 'right');\n        for (let j = 0; j < sorted.length; j++) {\n          columns[j] = columns[j] ? columns[j].concat(sorted[j]) : sorted[j];\n        }\n      }\n\n      return isRtl ? columns.reverse() : columns;\n    }\n\n    function sortBy(items, startProp, endProp) {\n      const sorted = [[]];\n\n      for (const el of items) {\n        if (!isVisible(el)) {\n          continue;\n        }\n\n        let dim = getOffset(el);\n\n        for (let i = sorted.length - 1; i >= 0; i--) {\n          const current = sorted[i];\n\n          if (!current[0]) {\n            current.push(el);\n            break;\n          }\n\n          let startDim;\n          if (current[0].offsetParent === el.offsetParent) {\n            startDim = getOffset(current[0]);\n          } else {\n            dim = getOffset(el, true);\n            startDim = getOffset(current[0], true);\n          }\n\n          if (dim[startProp] >= startDim[endProp] - 1 && dim[startProp] !== startDim[startProp]) {\n            sorted.push([el]);\n            break;\n          }\n\n          if (dim[endProp] - 1 > startDim[startProp] || dim[startProp] === startDim[startProp]) {\n            current.push(el);\n            break;\n          }\n\n          if (i === 0) {\n            sorted.unshift([el]);\n            break;\n          }\n        }\n      }\n\n      return sorted;\n    }\n\n    function getOffset(element, offset) {if (offset === void 0) {offset = false;}\n      let { offsetTop, offsetLeft, offsetHeight, offsetWidth } = element;\n\n      if (offset) {\n        [offsetTop, offsetLeft] = offsetPosition(element);\n      }\n\n      return {\n        top: offsetTop,\n        left: offsetLeft,\n        bottom: offsetTop + offsetHeight,\n        right: offsetLeft + offsetWidth };\n\n    }\n\n    var Scroll = {\n      connected() {\n        registerScrollListener(this._uid, () => this.$emit('scroll'));\n      },\n\n      disconnected() {\n        unregisterScrollListener(this._uid);\n      } };\n\n\n    const scrollListeners = new Map();\n    let unbindScrollListener;\n    function registerScrollListener(id, listener) {\n      unbindScrollListener =\n      unbindScrollListener ||\n      on(window, 'scroll', () => scrollListeners.forEach((listener) => listener()), {\n        passive: true,\n        capture: true });\n\n\n      scrollListeners.set(id, listener);\n    }\n\n    function unregisterScrollListener(id) {\n      scrollListeners.delete(id);\n      if (unbindScrollListener && !scrollListeners.size) {\n        unbindScrollListener();\n        unbindScrollListener = null;\n      }\n    }\n\n    var grid = {\n      extends: Margin,\n\n      mixins: [Class],\n\n      name: 'grid',\n\n      props: {\n        masonry: Boolean,\n        parallax: Number },\n\n\n      data: {\n        margin: 'uk-grid-margin',\n        clsStack: 'uk-grid-stack',\n        masonry: false,\n        parallax: 0 },\n\n\n      connected() {\n        this.masonry && addClass(this.$el, 'uk-flex-top uk-flex-wrap-top');\n        this.parallax && registerScrollListener(this._uid, () => this.$emit('scroll'));\n      },\n\n      disconnected() {\n        unregisterScrollListener(this._uid);\n      },\n\n      update: [\n      {\n        write(_ref) {let { columns } = _ref;\n          toggleClass(this.$el, this.clsStack, columns.length < 2);\n        },\n\n        events: ['resize'] },\n\n\n      {\n        read(data) {\n          let { columns, rows } = data;\n\n          // Filter component makes elements positioned absolute\n          if (\n          !columns.length ||\n          !this.masonry && !this.parallax ||\n          positionedAbsolute(this.$el))\n          {\n            data.translates = false;\n            return false;\n          }\n\n          let translates = false;\n\n          const nodes = children(this.$el);\n          const columnHeights = getColumnHeights(columns);\n          const margin = getMarginTop(nodes, this.margin) * (rows.length - 1);\n          const elHeight = Math.max(...columnHeights) + margin;\n\n          if (this.masonry) {\n            columns = columns.map((column) => sortBy$1(column, 'offsetTop'));\n            translates = getTranslates(rows, columns);\n          }\n\n          let padding = Math.abs(this.parallax);\n          if (padding) {\n            padding = columnHeights.reduce(\n            (newPadding, hgt, i) =>\n            Math.max(\n            newPadding,\n            hgt + margin + (i % 2 ? padding : padding / 8) - elHeight),\n\n            0);\n\n          }\n\n          return { padding, columns, translates, height: translates ? elHeight : '' };\n        },\n\n        write(_ref2) {let { height, padding } = _ref2;\n          css(this.$el, 'paddingBottom', padding || '');\n          height !== false && css(this.$el, 'height', height);\n        },\n\n        events: ['resize'] },\n\n\n      {\n        read() {\n          if (this.parallax && positionedAbsolute(this.$el)) {\n            return false;\n          }\n\n          return {\n            scrolled: this.parallax ?\n            scrolledOver(this.$el) * Math.abs(this.parallax) :\n            false };\n\n        },\n\n        write(_ref3) {let { columns, scrolled, translates } = _ref3;\n          if (scrolled === false && !translates) {\n            return;\n          }\n\n          columns.forEach((column, i) =>\n          column.forEach((el, j) =>\n          css(\n          el,\n          'transform',\n          !scrolled && !translates ?\n          '' : \"translateY(\" + (\n\n          (translates && -translates[i][j]) + (\n          scrolled ? i % 2 ? scrolled : scrolled / 8 : 0)) + \"px)\")));\n\n\n\n\n        },\n\n        events: ['scroll', 'resize'] }] };\n\n\n\n\n    function positionedAbsolute(el) {\n      return children(el).some((el) => css(el, 'position') === 'absolute');\n    }\n\n    function getTranslates(rows, columns) {\n      const rowHeights = rows.map((row) => Math.max(...row.map((el) => el.offsetHeight)));\n\n      return columns.map((elements) => {\n        let prev = 0;\n        return elements.map(\n        (element, row) =>\n        prev += row ? rowHeights[row - 1] - elements[row - 1].offsetHeight : 0);\n\n      });\n    }\n\n    function getMarginTop(nodes, cls) {\n      const [node] = nodes.filter((el) => hasClass(el, cls));\n\n      return toFloat(node ? css(node, 'marginTop') : css(nodes[0], 'paddingLeft'));\n    }\n\n    function getColumnHeights(columns) {\n      return columns.map((column) => column.reduce((sum, el) => sum + el.offsetHeight, 0));\n    }\n\n    var heightMatch = {\n      mixins: [Resize],\n\n      args: 'target',\n\n      props: {\n        target: String,\n        row: Boolean },\n\n\n      data: {\n        target: '> *',\n        row: true },\n\n\n      computed: {\n        elements: {\n          get(_ref, $el) {let { target } = _ref;\n            return $$(target, $el);\n          },\n\n          watch() {\n            this.$reset();\n          } } },\n\n\n\n      resizeTargets() {\n        return [this.$el, ...this.elements];\n      },\n\n      update: {\n        read() {\n          return {\n            rows: (this.row ? getRows(this.elements) : [this.elements]).map(match$1) };\n\n        },\n\n        write(_ref2) {let { rows } = _ref2;\n          for (const { heights, elements } of rows) {\n            elements.forEach((el, i) => css(el, 'minHeight', heights[i]));\n          }\n        },\n\n        events: ['resize'] } };\n\n\n\n    function match$1(elements) {\n      if (elements.length < 2) {\n        return { heights: [''], elements };\n      }\n\n      css(elements, 'minHeight', '');\n      let heights = elements.map(getHeight);\n      const max = Math.max(...heights);\n\n      return {\n        heights: elements.map((el, i) => heights[i].toFixed(2) === max.toFixed(2) ? '' : max),\n        elements };\n\n    }\n\n    function getHeight(element) {\n      let style = false;\n      if (!isVisible(element)) {\n        style = element.style.display;\n        css(element, 'display', 'block', 'important');\n      }\n\n      const height = dimensions$1(element).height - boxModelAdjust(element, 'height', 'content-box');\n\n      if (style !== false) {\n        css(element, 'display', style);\n      }\n\n      return height;\n    }\n\n    var heightViewport = {\n      mixins: [Resize],\n\n      props: {\n        expand: Boolean,\n        offsetTop: Boolean,\n        offsetBottom: Boolean,\n        minHeight: Number },\n\n\n      data: {\n        expand: false,\n        offsetTop: false,\n        offsetBottom: false,\n        minHeight: 0 },\n\n\n      resizeTargets() {\n        // check for offsetTop change\n        return [this.$el, ...scrollParents(this.$el, /auto|scroll/)];\n      },\n\n      update: {\n        read(_ref) {let { minHeight: prev } = _ref;\n          if (!isVisible(this.$el)) {\n            return false;\n          }\n\n          let minHeight = '';\n          const box = boxModelAdjust(this.$el, 'height', 'content-box');\n\n          const { body, scrollingElement } = document;\n          const [scrollElement] = scrollParents(this.$el, /auto|scroll/);\n          const { height: viewportHeight } = offsetViewport(\n          scrollElement === body ? scrollingElement : scrollElement);\n\n\n          if (this.expand) {\n            minHeight = Math.max(\n            viewportHeight - (\n            dimensions$1(scrollElement).height - dimensions$1(this.$el).height) -\n            box,\n            0);\n\n          } else {\n            const isScrollingElement =\n            scrollingElement === scrollElement || body === scrollElement;\n\n            // on mobile devices (iOS and Android) window.innerHeight !== 100vh\n            minHeight = \"calc(\" + (isScrollingElement ? '100vh' : viewportHeight + \"px\");\n\n            if (this.offsetTop) {\n              if (isScrollingElement) {\n                const top = offsetPosition(this.$el)[0] - offsetPosition(scrollElement)[0];\n                minHeight += top > 0 && top < viewportHeight / 2 ? \" - \" + top + \"px\" : '';\n              } else {\n                minHeight += \" - \" + css(scrollElement, 'paddingTop');\n              }\n            }\n\n            if (this.offsetBottom === true) {\n              minHeight += \" - \" + dimensions$1(this.$el.nextElementSibling).height + \"px\";\n            } else if (isNumeric(this.offsetBottom)) {\n              minHeight += \" - \" + this.offsetBottom + \"vh\";\n            } else if (this.offsetBottom && endsWith(this.offsetBottom, 'px')) {\n              minHeight += \" - \" + toFloat(this.offsetBottom) + \"px\";\n            } else if (isString(this.offsetBottom)) {\n              minHeight += \" - \" + dimensions$1(query(this.offsetBottom, this.$el)).height + \"px\";\n            }\n\n            minHeight += (box ? \" - \" + box + \"px\" : '') + \")\";\n          }\n\n          return { minHeight, prev };\n        },\n\n        write(_ref2) {let { minHeight } = _ref2;\n          css(this.$el, { minHeight });\n\n          if (this.minHeight && toFloat(css(this.$el, 'minHeight')) < this.minHeight) {\n            css(this.$el, 'minHeight', this.minHeight);\n          }\n        },\n\n        events: ['resize'] } };\n\n    var SVG = {\n      args: 'src',\n\n      props: {\n        id: Boolean,\n        icon: String,\n        src: String,\n        style: String,\n        width: Number,\n        height: Number,\n        ratio: Number,\n        class: String,\n        strokeAnimation: Boolean,\n        focusable: Boolean, // IE 11\n        attributes: 'list' },\n\n\n      data: {\n        ratio: 1,\n        include: ['style', 'class', 'focusable'],\n        class: '',\n        strokeAnimation: false },\n\n\n      beforeConnect() {\n        this.class += ' uk-svg';\n      },\n\n      connected() {\n        if (!this.icon && includes(this.src, '#')) {\n          [this.src, this.icon] = this.src.split('#');\n        }\n\n        this.svg = this.getSvg().then((el) => {\n          if (this._connected) {\n            const svg = insertSVG(el, this.$el);\n\n            if (this.svgEl && svg !== this.svgEl) {\n              remove$1(this.svgEl);\n            }\n\n            this.applyAttributes(svg, el);\n\n            return this.svgEl = svg;\n          }\n        }, noop);\n\n        if (this.strokeAnimation) {\n          this.svg.then((el) => {\n            if (this._connected) {\n              applyAnimation(el);\n              this.registerObserver(\n              observeIntersection(el, (records, observer) => {\n                applyAnimation(el);\n                observer.disconnect();\n              }));\n\n            }\n          });\n        }\n      },\n\n      disconnected() {\n        this.svg.then((svg) => {\n          if (this._connected) {\n            return;\n          }\n\n          if (isVoidElement(this.$el)) {\n            this.$el.hidden = false;\n          }\n\n          remove$1(svg);\n          this.svgEl = null;\n        });\n\n        this.svg = null;\n      },\n\n      methods: {\n        async getSvg() {\n          if (isTag(this.$el, 'img') && !this.$el.complete && this.$el.loading === 'lazy') {\n            return new Promise((resolve) =>\n            once(this.$el, 'load', () => resolve(this.getSvg())));\n\n          }\n\n          return parseSVG(await loadSVG(this.src), this.icon) || Promise.reject('SVG not found.');\n        },\n\n        applyAttributes(el, ref) {\n          for (const prop in this.$options.props) {\n            if (includes(this.include, prop) && prop in this) {\n              attr(el, prop, this[prop]);\n            }\n          }\n\n          for (const attribute in this.attributes) {\n            const [prop, value] = this.attributes[attribute].split(':', 2);\n            attr(el, prop, value);\n          }\n\n          if (!this.id) {\n            removeAttr(el, 'id');\n          }\n\n          const props = ['width', 'height'];\n          let dimensions = props.map((prop) => this[prop]);\n\n          if (!dimensions.some((val) => val)) {\n            dimensions = props.map((prop) => attr(ref, prop));\n          }\n\n          const viewBox = attr(ref, 'viewBox');\n          if (viewBox && !dimensions.some((val) => val)) {\n            dimensions = viewBox.split(' ').slice(2);\n          }\n\n          dimensions.forEach((val, i) => attr(el, props[i], toFloat(val) * this.ratio || null));\n        } } };\n\n\n\n    const loadSVG = memoize(async (src) => {\n      if (src) {\n        if (startsWith(src, 'data:')) {\n          return decodeURIComponent(src.split(',')[1]);\n        } else {\n          return (await fetch(src)).text();\n        }\n      } else {\n        return Promise.reject();\n      }\n    });\n\n    function parseSVG(svg, icon) {var _svg;\n      if (icon && includes(svg, '<symbol')) {\n        svg = parseSymbols(svg, icon) || svg;\n      }\n\n      svg = $(svg.substr(svg.indexOf('<svg')));\n      return ((_svg = svg) == null ? void 0 : _svg.hasChildNodes()) && svg;\n    }\n\n    const symbolRe = /<symbol([^]*?id=(['\"])(.+?)\\2[^]*?<\\/)symbol>/g;\n    const symbols = {};\n\n    function parseSymbols(svg, icon) {\n      if (!symbols[svg]) {\n        symbols[svg] = {};\n\n        symbolRe.lastIndex = 0;\n\n        let match;\n        while (match = symbolRe.exec(svg)) {\n          symbols[svg][match[3]] = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\" + match[1] + \"svg>\";\n        }\n      }\n\n      return symbols[svg][icon];\n    }\n\n    function applyAnimation(el) {\n      const length = getMaxPathLength(el);\n\n      if (length) {\n        el.style.setProperty('--uk-animation-stroke', length);\n      }\n    }\n\n    function getMaxPathLength(el) {\n      return Math.ceil(\n      Math.max(\n      0,\n      ...$$('[stroke]', el).map((stroke) => {\n        try {\n          return stroke.getTotalLength();\n        } catch (e) {\n          return 0;\n        }\n      })));\n\n\n    }\n\n    function insertSVG(el, root) {\n      if (isVoidElement(root) || isTag(root, 'canvas')) {\n        root.hidden = true;\n\n        const next = root.nextElementSibling;\n        return equals(el, next) ? next : after(root, el);\n      }\n\n      const last = root.lastElementChild;\n      return equals(el, last) ? last : append(root, el);\n    }\n\n    function equals(el, other) {\n      return isTag(el, 'svg') && isTag(other, 'svg') && innerHTML(el) === innerHTML(other);\n    }\n\n    function innerHTML(el) {\n      return (\n      el.innerHTML ||\n      new XMLSerializer().serializeToString(el).replace(/<svg.*?>(.*?)<\\/svg>/g, '$1')).\n      replace(/\\s/g, '');\n    }\n\n    var closeIcon = \"<svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 14 14\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"1\\\" y1=\\\"1\\\" x2=\\\"13\\\" y2=\\\"13\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"13\\\" y1=\\\"1\\\" x2=\\\"1\\\" y2=\\\"13\\\"/></svg>\";\n\n    var closeLarge = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" x1=\\\"1\\\" y1=\\\"1\\\" x2=\\\"19\\\" y2=\\\"19\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" x1=\\\"19\\\" y1=\\\"1\\\" x2=\\\"1\\\" y2=\\\"19\\\"/></svg>\";\n\n    var marker = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"9\\\" y=\\\"4\\\" width=\\\"1\\\" height=\\\"11\\\"/><rect x=\\\"4\\\" y=\\\"9\\\" width=\\\"11\\\" height=\\\"1\\\"/></svg>\";\n\n    var navParentIcon = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"12\\\" height=\\\"12\\\" viewBox=\\\"0 0 12 12\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" points=\\\"1 3.5 6 8.5 11 3.5\\\"/></svg>\";\n\n    var navParentIconLarge = \"<svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 14 14\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" points=\\\"1 4 7 10 13 4\\\"/></svg>\";\n\n    var navbarParentIcon = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"12\\\" height=\\\"12\\\" viewBox=\\\"0 0 12 12\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" points=\\\"1 3.5 6 8.5 11 3.5\\\"/></svg>\";\n\n    var navbarToggleIcon = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><style>.uk-navbar-toggle-animate svg > [class*='line-'] {\\n            transition: 0.2s ease-in-out;\\n            transition-property: transform, opacity,;\\n            transform-origin: center;\\n            opacity: 1;\\n        }\\n\\n        .uk-navbar-toggle svg > .line-3 { opacity: 0; }\\n        .uk-navbar-toggle-animate[aria-expanded=\\\"true\\\"] svg > .line-3 { opacity: 1; }\\n\\n        .uk-navbar-toggle-animate[aria-expanded=\\\"true\\\"] svg > .line-2 { transform: rotate(45deg); }\\n        .uk-navbar-toggle-animate[aria-expanded=\\\"true\\\"] svg > .line-3 { transform: rotate(-45deg); }\\n\\n        .uk-navbar-toggle-animate[aria-expanded=\\\"true\\\"] svg > .line-1,\\n        .uk-navbar-toggle-animate[aria-expanded=\\\"true\\\"] svg > .line-4 { opacity: 0; }\\n        .uk-navbar-toggle-animate[aria-expanded=\\\"true\\\"] svg > .line-1 { transform: translateY(6px) scaleX(0); }\\n        .uk-navbar-toggle-animate[aria-expanded=\\\"true\\\"] svg > .line-4 { transform: translateY(-6px) scaleX(0); }</style><rect class=\\\"line-1\\\" y=\\\"3\\\" width=\\\"20\\\" height=\\\"2\\\"/><rect class=\\\"line-2\\\" y=\\\"9\\\" width=\\\"20\\\" height=\\\"2\\\"/><rect class=\\\"line-3\\\" y=\\\"9\\\" width=\\\"20\\\" height=\\\"2\\\"/><rect class=\\\"line-4\\\" y=\\\"15\\\" width=\\\"20\\\" height=\\\"2\\\"/></svg>\";\n\n    var overlayIcon = \"<svg width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"19\\\" y=\\\"0\\\" width=\\\"1\\\" height=\\\"40\\\"/><rect x=\\\"0\\\" y=\\\"19\\\" width=\\\"40\\\" height=\\\"1\\\"/></svg>\";\n\n    var paginationNext = \"<svg width=\\\"7\\\" height=\\\"12\\\" viewBox=\\\"0 0 7 12\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" points=\\\"1 1 6 6 1 11\\\"/></svg>\";\n\n    var paginationPrevious = \"<svg width=\\\"7\\\" height=\\\"12\\\" viewBox=\\\"0 0 7 12\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" points=\\\"6 1 1 6 6 11\\\"/></svg>\";\n\n    var searchIcon = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"9\\\" cy=\\\"9\\\" r=\\\"7\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M14,14 L18,18 L14,14 Z\\\"/></svg>\";\n\n    var searchLarge = \"<svg width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.8\\\" cx=\\\"17.5\\\" cy=\\\"17.5\\\" r=\\\"16.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.8\\\" x1=\\\"38\\\" y1=\\\"39\\\" x2=\\\"29\\\" y2=\\\"30\\\"/></svg>\";\n\n    var searchNavbar = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10.5\\\" cy=\\\"10.5\\\" r=\\\"9.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"23\\\" y1=\\\"23\\\" x2=\\\"17\\\" y2=\\\"17\\\"/></svg>\";\n\n    var slidenavNext = \"<svg width=\\\"14\\\" height=\\\"24\\\" viewBox=\\\"0 0 14 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" points=\\\"1.225,23 12.775,12 1.225,1 \\\"/></svg>\";\n\n    var slidenavNextLarge = \"<svg width=\\\"25\\\" height=\\\"40\\\" viewBox=\\\"0 0 25 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"2\\\" points=\\\"4.002,38.547 22.527,20.024 4,1.5 \\\"/></svg>\";\n\n    var slidenavPrevious = \"<svg width=\\\"14\\\" height=\\\"24\\\" viewBox=\\\"0 0 14 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" points=\\\"12.775,1 1.225,12 12.775,23 \\\"/></svg>\";\n\n    var slidenavPreviousLarge = \"<svg width=\\\"25\\\" height=\\\"40\\\" viewBox=\\\"0 0 25 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"2\\\" points=\\\"20.527,1.5 2,20.024 20.525,38.547 \\\"/></svg>\";\n\n    var spinner = \"<svg width=\\\"30\\\" height=\\\"30\\\" viewBox=\\\"0 0 30 30\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"15\\\" cy=\\\"15\\\" r=\\\"14\\\"/></svg>\";\n\n    var totop = \"<svg width=\\\"18\\\" height=\\\"10\\\" viewBox=\\\"0 0 18 10\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" points=\\\"1 9 9 1 17 9 \\\"/></svg>\";\n\n    const icons = {\n      spinner,\n      totop,\n      marker,\n      'close-icon': closeIcon,\n      'close-large': closeLarge,\n      'nav-parent-icon': navParentIcon,\n      'nav-parent-icon-large': navParentIconLarge,\n      'navbar-parent-icon': navbarParentIcon,\n      'navbar-toggle-icon': navbarToggleIcon,\n      'overlay-icon': overlayIcon,\n      'pagination-next': paginationNext,\n      'pagination-previous': paginationPrevious,\n      'search-icon': searchIcon,\n      'search-large': searchLarge,\n      'search-navbar': searchNavbar,\n      'slidenav-next': slidenavNext,\n      'slidenav-next-large': slidenavNextLarge,\n      'slidenav-previous': slidenavPrevious,\n      'slidenav-previous-large': slidenavPreviousLarge };\n\n\n    const Icon = {\n      install: install$3,\n\n      extends: SVG,\n\n      args: 'icon',\n\n      props: ['icon'],\n\n      data: {\n        include: ['focusable'] },\n\n\n      isIcon: true,\n\n      beforeConnect() {\n        addClass(this.$el, 'uk-icon');\n      },\n\n      methods: {\n        async getSvg() {\n          const icon = getIcon(this.icon);\n\n          if (!icon) {\n            throw 'Icon not found.';\n          }\n\n          return icon;\n        } } };\n\n    const IconComponent = {\n      args: false,\n\n      extends: Icon,\n\n      data: (vm) => ({\n        icon: hyphenate(vm.constructor.options.name) }),\n\n\n      beforeConnect() {\n        addClass(this.$el, this.$options.id);\n      } };\n\n\n    const NavParentIcon = {\n      extends: IconComponent,\n\n      beforeConnect() {\n        const icon = this.$props.icon;\n        this.icon = closest(this.$el, '.uk-nav-primary') ? icon + \"-large\" : icon;\n      } };\n\n\n    const Slidenav = {\n      extends: IconComponent,\n\n      beforeConnect() {\n        addClass(this.$el, 'uk-slidenav');\n        const icon = this.$props.icon;\n        this.icon = hasClass(this.$el, 'uk-slidenav-large') ? icon + \"-large\" : icon;\n      } };\n\n\n    const Search = {\n      extends: IconComponent,\n\n      beforeConnect() {\n        this.icon =\n        hasClass(this.$el, 'uk-search-icon') && parents(this.$el, '.uk-search-large').length ?\n        'search-large' :\n        parents(this.$el, '.uk-search-navbar').length ?\n        'search-navbar' :\n        this.$props.icon;\n      } };\n\n\n    const Close = {\n      extends: IconComponent,\n\n      beforeConnect() {\n        this.icon = \"close-\" + (hasClass(this.$el, 'uk-close-large') ? 'large' : 'icon');\n      } };\n\n\n    const Spinner = {\n      extends: IconComponent,\n\n      methods: {\n        async getSvg() {\n          const icon = await Icon.methods.getSvg.call(this);\n\n          if (this.ratio !== 1) {\n            css($('circle', icon), 'strokeWidth', 1 / this.ratio);\n          }\n\n          return icon;\n        } } };\n\n\n\n    const parsed = {};\n    function install$3(UIkit) {\n      UIkit.icon.add = (name, svg) => {\n        const added = isString(name) ? { [name]: svg } : name;\n        each(added, (svg, name) => {\n          icons[name] = svg;\n          delete parsed[name];\n        });\n\n        if (UIkit._initialized) {\n          apply(document.body, (el) =>\n          each(UIkit.getComponents(el), (cmp) => {\n            cmp.$options.isIcon && cmp.icon in added && cmp.$reset();\n          }));\n\n        }\n      };\n    }\n\n    function getIcon(icon) {\n      if (!icons[icon]) {\n        return null;\n      }\n\n      if (!parsed[icon]) {\n        parsed[icon] = $((icons[applyRtl(icon)] || icons[icon]).trim());\n      }\n\n      return parsed[icon].cloneNode(true);\n    }\n\n    function applyRtl(icon) {\n      return isRtl ? swap(swap(icon, 'left', 'right'), 'previous', 'next') : icon;\n    }\n\n    const nativeLazyLoad = inBrowser && 'loading' in HTMLImageElement.prototype;\n\n    var img = {\n      args: 'dataSrc',\n\n      props: {\n        dataSrc: String,\n        sources: String,\n        offsetTop: String,\n        offsetLeft: String,\n        target: String,\n        loading: String },\n\n\n      data: {\n        dataSrc: '',\n        sources: false,\n        offsetTop: '50vh',\n        offsetLeft: '50vw',\n        target: false,\n        loading: 'lazy' },\n\n\n      connected() {\n        if (this.loading !== 'lazy') {\n          this.load();\n          return;\n        }\n\n        const target = [this.$el, ...queryAll(this.$props.target, this.$el)];\n\n        if (nativeLazyLoad && isImg(this.$el)) {\n          this.$el.loading = 'lazy';\n          setSrcAttrs(this.$el);\n\n          if (target.length === 1) {\n            return;\n          }\n        }\n\n        ensureSrcAttribute(this.$el);\n\n        this.registerObserver(\n        observeIntersection(\n        target,\n        (entries, observer) => {\n          this.load();\n          observer.disconnect();\n        },\n        {\n          rootMargin: toPx(this.offsetTop, 'height') + \"px \" + toPx(\n          this.offsetLeft,\n          'width') + \"px\" }));\n\n\n\n\n      },\n\n      disconnected() {\n        if (this._data.image) {\n          this._data.image.onload = '';\n        }\n      },\n\n      methods: {\n        load() {\n          if (this._data.image) {\n            return this._data.image;\n          }\n\n          const image = isImg(this.$el) ?\n          this.$el :\n          getImageFromElement(this.$el, this.dataSrc, this.sources);\n\n          removeAttr(image, 'loading');\n          setSrcAttrs(this.$el, image.currentSrc);\n          return this._data.image = image;\n        } } };\n\n\n\n    function setSrcAttrs(el, src) {\n      if (isImg(el)) {\n        const parentNode = parent(el);\n        const elements = isPicture(parentNode) ? children(parentNode) : [el];\n        elements.forEach((el) => setSourceProps(el, el));\n      } else if (src) {\n        const change = !includes(el.style.backgroundImage, src);\n        if (change) {\n          css(el, 'backgroundImage', \"url(\" + escape(src) + \")\");\n          trigger(el, createEvent('load', false));\n        }\n      }\n    }\n\n    const srcProps = ['data-src', 'data-srcset', 'sizes'];\n    function setSourceProps(sourceEl, targetEl) {\n      srcProps.forEach((prop) => {\n        const value = data(sourceEl, prop);\n        if (value) {\n          attr(targetEl, prop.replace(/^(data-)+/, ''), value);\n        }\n      });\n    }\n\n    function getImageFromElement(el, src, sources) {\n      const img = new Image();\n\n      wrapInPicture(img, sources);\n      setSourceProps(el, img);\n      img.onload = () => {\n        setSrcAttrs(el, img.currentSrc);\n      };\n      attr(img, 'src', src);\n      return img;\n    }\n\n    function wrapInPicture(img, sources) {\n      sources = parseSources(sources);\n\n      if (sources.length) {\n        const picture = fragment('<picture>');\n        for (const attrs of sources) {\n          const source = fragment('<source>');\n          attr(source, attrs);\n          append(picture, source);\n        }\n        append(picture, img);\n      }\n    }\n\n    function parseSources(sources) {\n      if (!sources) {\n        return [];\n      }\n\n      if (startsWith(sources, '[')) {\n        try {\n          sources = JSON.parse(sources);\n        } catch (e) {\n          sources = [];\n        }\n      } else {\n        sources = parseOptions(sources);\n      }\n\n      if (!isArray(sources)) {\n        sources = [sources];\n      }\n\n      return sources.filter((source) => !isEmpty(source));\n    }\n\n    function ensureSrcAttribute(el) {\n      if (isImg(el) && !hasAttr(el, 'src')) {\n        attr(el, 'src', 'data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>');\n      }\n    }\n\n    function isPicture(el) {\n      return isTag(el, 'picture');\n    }\n\n    function isImg(el) {\n      return isTag(el, 'img');\n    }\n\n    var Media = {\n      props: {\n        media: Boolean },\n\n\n      data: {\n        media: false },\n\n\n      connected() {\n        const media = toMedia(this.media, this.$el);\n        this.matchMedia = true;\n        if (media) {\n          this.mediaObj = window.matchMedia(media);\n          const handler = () => {\n            this.matchMedia = this.mediaObj.matches;\n            trigger(this.$el, createEvent('mediachange', false, true, [this.mediaObj]));\n          };\n          this.offMediaObj = on(this.mediaObj, 'change', () => {\n            handler();\n            this.$emit('resize');\n          });\n          handler();\n        }\n      },\n\n      disconnected() {var _this$offMediaObj;\n        (_this$offMediaObj = this.offMediaObj) == null ? void 0 : _this$offMediaObj.call(this);\n      } };\n\n\n    function toMedia(value, element) {\n      if (isString(value)) {\n        if (startsWith(value, '@')) {\n          value = toFloat(css(element, \"--uk-breakpoint-\" + value.substr(1)));\n        } else if (isNaN(value)) {\n          return value;\n        }\n      }\n\n      return value && isNumeric(value) ? \"(min-width: \" + value + \"px)\" : '';\n    }\n\n    var leader = {\n      mixins: [Class, Media, Resize],\n\n      props: {\n        fill: String },\n\n\n      data: {\n        fill: '',\n        clsWrapper: 'uk-leader-fill',\n        clsHide: 'uk-leader-hide',\n        attrFill: 'data-fill' },\n\n\n      computed: {\n        fill(_ref) {let { fill } = _ref;\n          return fill || css(this.$el, '--uk-leader-fill-content');\n        } },\n\n\n      connected() {\n        [this.wrapper] = wrapInner(this.$el, \"<span class=\\\"\" + this.clsWrapper + \"\\\">\");\n      },\n\n      disconnected() {\n        unwrap(this.wrapper.childNodes);\n      },\n\n      update: {\n        read() {\n          const width = Math.trunc(this.$el.offsetWidth / 2);\n\n          return {\n            width,\n            fill: this.fill,\n            hide: !this.matchMedia };\n\n        },\n\n        write(_ref2) {let { width, fill, hide } = _ref2;\n          toggleClass(this.wrapper, this.clsHide, hide);\n          attr(this.wrapper, this.attrFill, new Array(width).join(fill));\n        },\n\n        events: ['resize'] } };\n\n    var modal = {\n      install: install$2,\n\n      mixins: [Modal],\n\n      data: {\n        clsPage: 'uk-modal-page',\n        selPanel: '.uk-modal-dialog',\n        selClose:\n        '.uk-modal-close, .uk-modal-close-default, .uk-modal-close-outside, .uk-modal-close-full' },\n\n\n      events: [\n      {\n        name: 'show',\n\n        self: true,\n\n        handler() {\n          if (hasClass(this.panel, 'uk-margin-auto-vertical')) {\n            addClass(this.$el, 'uk-flex');\n          } else {\n            css(this.$el, 'display', 'block');\n          }\n\n          height(this.$el); // force reflow\n        } },\n\n\n      {\n        name: 'hidden',\n\n        self: true,\n\n        handler() {\n          css(this.$el, 'display', '');\n          removeClass(this.$el, 'uk-flex');\n        } }] };\n\n\n\n\n    function install$2(_ref) {let { modal } = _ref;\n      modal.dialog = function (content, options) {\n        const dialog = modal(\"<div class=\\\"uk-modal\\\"> <div class=\\\"uk-modal-dialog\\\">\" +\n\n        content + \"</div> </div>\",\n\n        options);\n\n\n        dialog.show();\n\n        on(\n        dialog.$el,\n        'hidden',\n        async () => {\n          await Promise.resolve();\n          dialog.$destroy(true);\n        },\n        { self: true });\n\n\n        return dialog;\n      };\n\n      modal.alert = function (message, options) {\n        return openDialog(\n        (_ref2) => {let { labels } = _ref2;return \"<div class=\\\"uk-modal-body\\\">\" + (\n          isString(message) ? message : html(message)) + \"</div> <div class=\\\"uk-modal-footer uk-text-right\\\"> <button class=\\\"uk-button uk-button-primary uk-modal-close\\\" autofocus>\" +\n\n\n\n          labels.ok + \"</button> </div>\";},\n\n\n        options,\n        (deferred) => deferred.resolve());\n\n      };\n\n      modal.confirm = function (message, options) {\n        return openDialog(\n        (_ref3) => {let { labels } = _ref3;return \"<form> <div class=\\\"uk-modal-body\\\">\" + (\n          isString(message) ? message : html(message)) + \"</div> <div class=\\\"uk-modal-footer uk-text-right\\\"> <button class=\\\"uk-button uk-button-default uk-modal-close\\\" type=\\\"button\\\">\" +\n\n\n          labels.cancel + \"</button> <button class=\\\"uk-button uk-button-primary\\\" autofocus>\" +\n\n          labels.ok + \"</button> </div> </form>\";},\n\n\n        options,\n        (deferred) => deferred.reject());\n\n      };\n\n      modal.prompt = function (message, value, options) {\n        return openDialog(\n        (_ref4) => {let { labels } = _ref4;return \"<form class=\\\"uk-form-stacked\\\"> <div class=\\\"uk-modal-body\\\"> <label>\" + (\n\n          isString(message) ? message : html(message)) + \"</label> <input class=\\\"uk-input\\\" value=\\\"\" + (\n          value || '') + \"\\\" autofocus> </div> <div class=\\\"uk-modal-footer uk-text-right\\\"> <button class=\\\"uk-button uk-button-default uk-modal-close\\\" type=\\\"button\\\">\" +\n\n\n\n          labels.cancel + \"</button> <button class=\\\"uk-button uk-button-primary\\\">\" +\n\n          labels.ok + \"</button> </div> </form>\";},\n\n\n        options,\n        (deferred) => deferred.resolve(null),\n        (dialog) => $('input', dialog.$el).value);\n\n      };\n\n      modal.labels = {\n        ok: 'Ok',\n        cancel: 'Cancel' };\n\n\n      function openDialog(tmpl, options, hideFn, submitFn) {\n        options = { bgClose: false, escClose: true, labels: modal.labels, ...options };\n\n        const dialog = modal.dialog(tmpl(options), options);\n        const deferred = new Deferred();\n\n        let resolved = false;\n\n        on(dialog.$el, 'submit', 'form', (e) => {\n          e.preventDefault();\n          deferred.resolve(submitFn == null ? void 0 : submitFn(dialog));\n          resolved = true;\n          dialog.hide();\n        });\n\n        on(dialog.$el, 'hide', () => !resolved && hideFn(deferred));\n\n        deferred.promise.dialog = dialog;\n\n        return deferred.promise;\n      }\n    }\n\n    var nav = {\n      extends: Accordion,\n\n      data: {\n        targets: '> .uk-parent',\n        toggle: '> a',\n        content: '> ul' } };\n\n    var navbar = {\n      mixins: [Class, Container],\n\n      props: {\n        dropdown: String,\n        align: String,\n        clsDrop: String,\n        boundary: Boolean,\n        dropbar: Boolean,\n        dropbarAnchor: Boolean,\n        duration: Number,\n        mode: Boolean,\n        offset: Boolean,\n        stretch: Boolean,\n        delayShow: Boolean,\n        delayHide: Boolean,\n        target: Boolean,\n        targetX: Boolean,\n        targetY: Boolean,\n        animation: Boolean,\n        animateOut: Boolean },\n\n\n      data: {\n        dropdown: '.uk-navbar-nav > li > a, .uk-navbar-item, .uk-navbar-toggle',\n        align: isRtl ? 'right' : 'left',\n        clsDrop: 'uk-navbar-dropdown',\n        boundary: true,\n        dropbar: false,\n        dropbarAnchor: false,\n        duration: 200,\n        container: false },\n\n\n      computed: {\n        dropbarAnchor(_ref, $el) {let { dropbarAnchor } = _ref;\n          return query(dropbarAnchor, $el) || $el;\n        },\n\n        dropbar: {\n          get(_ref2) {let { dropbar } = _ref2;\n            if (!dropbar) {\n              return null;\n            }\n\n            dropbar =\n            this._dropbar ||\n            query(dropbar, this.$el) ||\n            $('+ .uk-navbar-dropbar', this.$el);\n\n            return dropbar ? dropbar : this._dropbar = $('<div></div>');\n          },\n\n          watch(dropbar) {\n            addClass(dropbar, 'uk-dropbar', 'uk-dropbar-top', 'uk-navbar-dropbar');\n          },\n\n          immediate: true },\n\n\n        dropContainer(_, $el) {\n          return this.container || $el;\n        },\n\n        dropdowns: {\n          get(_ref3, $el) {let { clsDrop } = _ref3;\n            const dropdowns = $$(\".\" + clsDrop, $el);\n\n            if (this.dropContainer !== $el) {\n              for (const el of $$(\".\" + clsDrop, this.dropContainer)) {var _this$getDropdown;\n                const target = (_this$getDropdown = this.getDropdown(el)) == null ? void 0 : _this$getDropdown.targetEl;\n                if (!includes(dropdowns, el) && target && within(target, this.$el)) {\n                  dropdowns.push(el);\n                }\n              }\n            }\n\n            return dropdowns;\n          },\n\n          watch(dropdowns) {\n            this.$create(\n            'drop',\n            dropdowns.filter((el) => !this.getDropdown(el)),\n            {\n              ...this.$props,\n              flip: false,\n              shift: true,\n              pos: \"bottom-\" + this.align,\n              boundary: this.boundary === true ? this.$el : this.boundary });\n\n\n          },\n\n          immediate: true },\n\n\n        toggles: {\n          get(_ref4, $el) {let { dropdown } = _ref4;\n            return $$(dropdown, $el);\n          },\n\n          watch() {\n            const justify = hasClass(this.$el, 'uk-navbar-justify');\n            for (const container of $$(\n            '.uk-navbar-nav, .uk-navbar-left, .uk-navbar-right',\n            this.$el))\n            {\n              css(container, 'flexGrow', justify ? $$(this.dropdown, container).length : '');\n            }\n          },\n\n          immediate: true } },\n\n\n\n      disconnected() {\n        this.dropbar && remove$1(this.dropbar);\n        delete this._dropbar;\n      },\n\n      events: [\n      {\n        name: 'mouseover focusin',\n\n        delegate() {\n          return this.dropdown;\n        },\n\n        handler(_ref5) {let { current } = _ref5;\n          const active = this.getActive();\n          if (\n          active &&\n          includes(active.mode, 'hover') &&\n          active.targetEl &&\n          !within(active.targetEl, current) &&\n          !active.isDelaying)\n          {\n            active.hide(false);\n          }\n        } },\n\n\n      {\n        name: 'keydown',\n\n        delegate() {\n          return this.dropdown;\n        },\n\n        handler(e) {\n          const { current, keyCode } = e;\n          const active = this.getActive();\n\n          if (keyCode === keyMap.DOWN && hasAttr(current, 'aria-expanded')) {\n            e.preventDefault();\n\n            if (!active || active.targetEl !== current) {\n              current.click();\n              once(this.dropContainer, 'show', (_ref6) => {let { target } = _ref6;return (\n                  focusFirstFocusableElement(target));});\n\n            } else {\n              focusFirstFocusableElement(active.$el);\n            }\n          }\n\n          handleNavItemNavigation(e, this.toggles, active);\n        } },\n\n\n      {\n        name: 'keydown',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        delegate() {\n          return \".\" + this.clsDrop;\n        },\n\n        handler(e) {\n          const { current, keyCode } = e;\n\n          if (!includes(this.dropdowns, current)) {\n            return;\n          }\n\n          const active = this.getActive();\n          const elements = $$(selFocusable, current);\n          const i = findIndex(elements, (el) => matches(el, ':focus'));\n\n          if (keyCode === keyMap.UP) {\n            e.preventDefault();\n            if (i > 0) {\n              elements[i - 1].focus();\n            }\n          }\n\n          if (keyCode === keyMap.DOWN) {\n            e.preventDefault();\n            if (i < elements.length - 1) {\n              elements[i + 1].focus();\n            }\n          }\n\n          if (keyCode === keyMap.ESC) {var _active$targetEl;\n            active == null ? void 0 : (_active$targetEl = active.targetEl) == null ? void 0 : _active$targetEl.focus();\n          }\n\n          handleNavItemNavigation(e, this.toggles, active);\n        } },\n\n\n      {\n        name: 'mouseleave',\n\n        el() {\n          return this.dropbar;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler() {\n          const active = this.getActive();\n\n          if (\n          active &&\n          includes(active.mode, 'hover') &&\n          !this.dropdowns.some((el) => matches(el, ':hover')))\n          {\n            active.hide();\n          }\n        } },\n\n\n      {\n        name: 'beforeshow',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler(_ref7) {let { target } = _ref7;\n          if (!this.isDropbarDrop(target)) {\n            return;\n          }\n\n          if (this.dropbar.previousElementSibling !== this.dropbarAnchor) {\n            after(this.dropbarAnchor, this.dropbar);\n          }\n\n          addClass(target, this.clsDrop + \"-dropbar\");\n        } },\n\n\n      {\n        name: 'show',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler(_ref8) {let { target } = _ref8;\n          if (!this.isDropbarDrop(target)) {\n            return;\n          }\n\n          const drop = this.getDropdown(target);\n          this._observer = observeResize([drop.$el, ...drop.target], () => {\n            const targetOffsets = parents(target, \".\" + this.clsDrop).\n            concat(target).\n            map((el) => offset(el));\n            const minTop = Math.min(...targetOffsets.map((_ref9) => {let { top } = _ref9;return top;}));\n            const maxBottom = Math.max(...targetOffsets.map((_ref10) => {let { bottom } = _ref10;return bottom;}));\n            const dropbarOffset = offset(this.dropbar);\n            css(this.dropbar, 'top', this.dropbar.offsetTop - (dropbarOffset.top - minTop));\n            this.transitionTo(\n            maxBottom - minTop + toFloat(css(target, 'marginBottom')),\n            target);\n\n          });\n        } },\n\n\n      {\n        name: 'beforehide',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler(e) {\n          const active = this.getActive();\n\n          if (\n          matches(this.dropbar, ':hover') &&\n          (active == null ? void 0 : active.$el) === e.target &&\n          !this.toggles.some((el) => active.targetEl !== el && matches(el, ':focus')))\n          {\n            e.preventDefault();\n          }\n        } },\n\n\n      {\n        name: 'hide',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler(_ref11) {var _this$_observer;let { target } = _ref11;\n          if (!this.isDropbarDrop(target)) {\n            return;\n          }\n\n          (_this$_observer = this._observer) == null ? void 0 : _this$_observer.disconnect();\n\n          const active = this.getActive();\n\n          if (!active || (active == null ? void 0 : active.$el) === target) {\n            this.transitionTo(0);\n          }\n        } }],\n\n\n\n      methods: {\n        getActive() {\n          return includes(this.dropdowns, active == null ? void 0 : active.$el) && active;\n        },\n\n        transitionTo(newHeight, el) {\n          const { dropbar } = this;\n          const oldHeight = height(dropbar);\n\n          el = oldHeight < newHeight && el;\n\n          css(el, 'clipPath', \"polygon(0 0,100% 0,100% \" + oldHeight + \"px,0 \" + oldHeight + \"px)\");\n\n          height(dropbar, oldHeight);\n\n          Transition.cancel([el, dropbar]);\n          Promise.all([\n          Transition.start(dropbar, { height: newHeight }, this.duration),\n          Transition.start(\n          el,\n          {\n            clipPath: \"polygon(0 0,100% 0,100% \" + newHeight + \"px,0 \" + newHeight + \"px)\" },\n\n          this.duration)]).\n\n\n          catch(noop).\n          then(() => css(el, { clipPath: '' }));\n        },\n\n        getDropdown(el) {\n          return this.$getComponent(el, 'drop') || this.$getComponent(el, 'dropdown');\n        },\n\n        isDropbarDrop(el) {\n          return this.getDropdown(el) && hasClass(el, this.clsDrop);\n        } } };\n\n\n\n    function handleNavItemNavigation(e, toggles, active) {\n      const { current, keyCode } = e;\n      const target = (active == null ? void 0 : active.targetEl) || current;\n      const i = toggles.indexOf(target);\n\n      // Left\n      if (keyCode === keyMap.LEFT && i > 0) {\n        active == null ? void 0 : active.hide(false);\n        toggles[i - 1].focus();\n      }\n\n      // Right\n      if (keyCode === keyMap.RIGHT && i < toggles.length - 1) {\n        active == null ? void 0 : active.hide(false);\n        toggles[i + 1].focus();\n      }\n\n      if (keyCode === keyMap.TAB) {\n        target.focus();\n        active == null ? void 0 : active.hide(false);\n      }\n    }\n\n    function focusFirstFocusableElement(el) {\n      if (!$(':focus', el)) {var _$;\n        (_$ = $(selFocusable, el)) == null ? void 0 : _$.focus();\n      }\n    }\n\n    const keyMap = {\n      TAB: 9,\n      ESC: 27,\n      LEFT: 37,\n      UP: 38,\n      RIGHT: 39,\n      DOWN: 40 };\n\n    var Swipe = {\n      props: {\n        swiping: Boolean },\n\n\n      data: {\n        swiping: true },\n\n\n      computed: {\n        swipeTarget(props, $el) {\n          return $el;\n        } },\n\n\n      connected() {\n        if (!this.swiping) {\n          return;\n        }\n\n        registerEvent(this, {\n          el: this.swipeTarget,\n          name: pointerDown$1,\n          passive: true,\n          handler(e) {\n            if (!isTouch(e)) {\n              return;\n            }\n\n            // Handle Swipe Gesture\n            const pos = getEventPos(e);\n            const target = 'tagName' in e.target ? e.target : parent(e.target);\n            once(document, pointerUp$1 + \" \" + pointerCancel + \" scroll\", (e) => {\n              const { x, y } = getEventPos(e);\n\n              // swipe\n              if (\n              e.type !== 'scroll' && target && x && Math.abs(pos.x - x) > 100 ||\n              y && Math.abs(pos.y - y) > 100)\n              {\n                setTimeout(() => {\n                  trigger(target, 'swipe');\n                  trigger(target, \"swipe\" + swipeDirection(pos.x, pos.y, x, y));\n                });\n              }\n            });\n          } });\n\n      } };\n\n\n    function swipeDirection(x1, y1, x2, y2) {\n      return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ?\n      x1 - x2 > 0 ?\n      'Left' :\n      'Right' :\n      y1 - y2 > 0 ?\n      'Up' :\n      'Down';\n    }\n\n    var offcanvas = {\n      mixins: [Modal, Swipe],\n\n      args: 'mode',\n\n      props: {\n        mode: String,\n        flip: Boolean,\n        overlay: Boolean },\n\n\n      data: {\n        mode: 'slide',\n        flip: false,\n        overlay: false,\n        clsPage: 'uk-offcanvas-page',\n        clsContainer: 'uk-offcanvas-container',\n        selPanel: '.uk-offcanvas-bar',\n        clsFlip: 'uk-offcanvas-flip',\n        clsContainerAnimation: 'uk-offcanvas-container-animation',\n        clsSidebarAnimation: 'uk-offcanvas-bar-animation',\n        clsMode: 'uk-offcanvas',\n        clsOverlay: 'uk-offcanvas-overlay',\n        selClose: '.uk-offcanvas-close',\n        container: false },\n\n\n      computed: {\n        clsFlip(_ref) {let { flip, clsFlip } = _ref;\n          return flip ? clsFlip : '';\n        },\n\n        clsOverlay(_ref2) {let { overlay, clsOverlay } = _ref2;\n          return overlay ? clsOverlay : '';\n        },\n\n        clsMode(_ref3) {let { mode, clsMode } = _ref3;\n          return clsMode + \"-\" + mode;\n        },\n\n        clsSidebarAnimation(_ref4) {let { mode, clsSidebarAnimation } = _ref4;\n          return mode === 'none' || mode === 'reveal' ? '' : clsSidebarAnimation;\n        },\n\n        clsContainerAnimation(_ref5) {let { mode, clsContainerAnimation } = _ref5;\n          return mode !== 'push' && mode !== 'reveal' ? '' : clsContainerAnimation;\n        },\n\n        transitionElement(_ref6) {let { mode } = _ref6;\n          return mode === 'reveal' ? parent(this.panel) : this.panel;\n        } },\n\n\n      update: {\n        read() {\n          if (this.isToggled() && !isVisible(this.$el)) {\n            this.hide();\n          }\n        },\n\n        events: ['resize'] },\n\n\n      events: [\n      {\n        name: 'touchmove',\n\n        self: true,\n        passive: false,\n\n        filter() {\n          return this.overlay;\n        },\n\n        handler(e) {\n          e.cancelable && e.preventDefault();\n        } },\n\n\n      {\n        name: 'show',\n\n        self: true,\n\n        handler() {\n          if (this.mode === 'reveal' && !hasClass(parent(this.panel), this.clsMode)) {\n            wrapAll(this.panel, '<div>');\n            addClass(parent(this.panel), this.clsMode);\n          }\n\n          const { body, scrollingElement } = document;\n\n          addClass(body, this.clsContainer, this.clsFlip);\n          css(body, 'touch-action', 'pan-y pinch-zoom');\n          css(this.$el, 'display', 'block');\n          css(this.panel, 'maxWidth', scrollingElement.clientWidth);\n          addClass(this.$el, this.clsOverlay);\n          addClass(\n          this.panel,\n          this.clsSidebarAnimation,\n          this.mode === 'reveal' ? '' : this.clsMode);\n\n\n          height(body); // force reflow\n          addClass(body, this.clsContainerAnimation);\n\n          this.clsContainerAnimation && suppressUserScale();\n        } },\n\n\n      {\n        name: 'hide',\n\n        self: true,\n\n        handler() {\n          removeClass(document.body, this.clsContainerAnimation);\n          css(document.body, 'touch-action', '');\n        } },\n\n\n      {\n        name: 'hidden',\n\n        self: true,\n\n        handler() {\n          this.clsContainerAnimation && resumeUserScale();\n\n          if (this.mode === 'reveal') {\n            unwrap(this.panel);\n          }\n\n          removeClass(this.panel, this.clsSidebarAnimation, this.clsMode);\n          removeClass(this.$el, this.clsOverlay);\n          css(this.$el, 'display', '');\n          css(this.panel, 'maxWidth', '');\n          removeClass(document.body, this.clsContainer, this.clsFlip);\n        } },\n\n\n      {\n        name: 'swipeLeft swipeRight',\n\n        handler(e) {\n          if (this.isToggled() && endsWith(e.type, 'Left') ^ this.flip) {\n            this.hide();\n          }\n        } }] };\n\n\n\n\n    // Chrome in responsive mode zooms page upon opening offcanvas\n    function suppressUserScale() {\n      getViewport().content += ',user-scalable=0';\n    }\n\n    function resumeUserScale() {\n      const viewport = getViewport();\n      viewport.content = viewport.content.replace(/,user-scalable=0$/, '');\n    }\n\n    function getViewport() {\n      return (\n        $('meta[name=\"viewport\"]', document.head) || append(document.head, '<meta name=\"viewport\">'));\n\n    }\n\n    var overflowAuto = {\n      mixins: [Class, Resize],\n\n      props: {\n        selContainer: String,\n        selContent: String,\n        minHeight: Number },\n\n\n      data: {\n        selContainer: '.uk-modal',\n        selContent: '.uk-modal-dialog',\n        minHeight: 150 },\n\n\n      computed: {\n        container(_ref, $el) {let { selContainer } = _ref;\n          return closest($el, selContainer);\n        },\n\n        content(_ref2, $el) {let { selContent } = _ref2;\n          return closest($el, selContent);\n        } },\n\n\n      resizeTargets() {\n        return [this.container, this.content];\n      },\n\n      update: {\n        read() {\n          if (!this.content || !this.container || !isVisible(this.$el)) {\n            return false;\n          }\n\n          return {\n            max: Math.max(\n            this.minHeight,\n            height(this.container) - (dimensions$1(this.content).height - height(this.$el))) };\n\n\n        },\n\n        write(_ref3) {let { max } = _ref3;\n          css(this.$el, { minHeight: this.minHeight, maxHeight: max });\n        },\n\n        events: ['resize'] } };\n\n    var responsive = {\n      mixins: [Resize],\n\n      props: ['width', 'height'],\n\n      resizeTargets() {\n        return [this.$el, parent(this.$el)];\n      },\n\n      connected() {\n        addClass(this.$el, 'uk-responsive-width');\n      },\n\n      update: {\n        read() {\n          return isVisible(this.$el) && this.width && this.height ?\n          { width: width(parent(this.$el)), height: this.height } :\n          false;\n        },\n\n        write(dim) {\n          height(\n          this.$el,\n          Dimensions.contain(\n          {\n            height: this.height,\n            width: this.width },\n\n          dim).\n          height);\n\n        },\n\n        events: ['resize'] } };\n\n    var scroll = {\n      props: {\n        offset: Number },\n\n\n      data: {\n        offset: 0 },\n\n\n      connected() {\n        registerClick(this);\n      },\n\n      disconnected() {\n        unregisterClick(this);\n      },\n\n      methods: {\n        async scrollTo(el) {\n          el = el && $(el) || document.body;\n\n          if (trigger(this.$el, 'beforescroll', [this, el])) {\n            await scrollIntoView(el, { offset: this.offset });\n            trigger(this.$el, 'scrolled', [this, el]);\n          }\n        } } };\n\n\n\n    const components$2 = new Set();\n    function registerClick(cmp) {\n      if (!components$2.size) {\n        on(document, 'click', clickHandler);\n      }\n\n      components$2.add(cmp);\n    }\n\n    function unregisterClick(cmp) {\n      components$2.delete(cmp);\n\n      if (!components$2.size) {\n        off(document, 'click', clickHandler);\n      }\n    }\n\n    function clickHandler(e) {\n      if (e.defaultPrevented) {\n        return;\n      }\n\n      for (const component of components$2) {\n        if (within(e.target, component.$el)) {\n          e.preventDefault();\n          component.scrollTo(getTargetElement(component.$el));\n        }\n      }\n    }\n\n    function getTargetElement(el) {\n      return document.getElementById(decodeURIComponent(el.hash).substring(1));\n    }\n\n    var scrollspy = {\n      mixins: [Scroll],\n\n      args: 'cls',\n\n      props: {\n        cls: String,\n        target: String,\n        hidden: Boolean,\n        offsetTop: Number,\n        offsetLeft: Number,\n        repeat: Boolean,\n        delay: Number },\n\n\n      data: () => ({\n        cls: '',\n        target: false,\n        hidden: true,\n        offsetTop: 0,\n        offsetLeft: 0,\n        repeat: false,\n        delay: 0,\n        inViewClass: 'uk-scrollspy-inview' }),\n\n\n      computed: {\n        elements: {\n          get(_ref, $el) {let { target } = _ref;\n            return target ? $$(target, $el) : [$el];\n          },\n\n          watch(elements, prev) {\n            if (this.hidden) {\n              css(filter$1(elements, \":not(.\" + this.inViewClass + \")\"), 'visibility', 'hidden');\n            }\n\n            if (!isEqual(elements, prev)) {\n              this.$reset();\n            }\n          },\n\n          immediate: true } },\n\n\n\n      connected() {\n        this._data.elements = new Map();\n        this.registerObserver(\n        observeIntersection(\n        this.elements,\n        (records) => {\n          const elements = this._data.elements;\n          for (const { target: el, isIntersecting } of records) {\n            if (!elements.has(el)) {\n              elements.set(el, {\n                cls: data(el, 'uk-scrollspy-class') || this.cls });\n\n            }\n\n            const state = elements.get(el);\n            if (!this.repeat && state.show) {\n              continue;\n            }\n\n            state.show = isIntersecting;\n          }\n\n          this.$emit();\n        },\n        {\n          rootMargin: toPx(this.offsetTop, 'height') - 1 + \"px \" + (\n          toPx(this.offsetLeft, 'width') - 1) + \"px\" },\n\n\n        false));\n\n\n      },\n\n      disconnected() {\n        for (const [el, state] of this._data.elements.entries()) {\n          removeClass(el, this.inViewClass, (state == null ? void 0 : state.cls) || '');\n        }\n      },\n\n      update: [\n      {\n        write(data) {\n          for (const [el, state] of data.elements.entries()) {\n            if (state.show && !state.inview && !state.queued) {\n              state.queued = true;\n\n              data.promise = (data.promise || Promise.resolve()).\n              then(() => new Promise((resolve) => setTimeout(resolve, this.delay))).\n              then(() => {\n                this.toggle(el, true);\n                setTimeout(() => {\n                  state.queued = false;\n                  this.$emit();\n                }, 300);\n              });\n            } else if (!state.show && state.inview && !state.queued && this.repeat) {\n              this.toggle(el, false);\n            }\n          }\n        } }],\n\n\n\n      methods: {\n        toggle(el, inview) {\n          const state = this._data.elements.get(el);\n\n          if (!state) {\n            return;\n          }\n\n          state.off == null ? void 0 : state.off();\n\n          css(el, 'visibility', !inview && this.hidden ? 'hidden' : '');\n\n          toggleClass(el, this.inViewClass, inview);\n          toggleClass(el, state.cls);\n\n          if (/\\buk-animation-/.test(state.cls)) {\n            const removeAnimationClasses = () => removeClasses(el, 'uk-animation-[\\\\w-]+');\n            if (inview) {\n              state.off = once(el, 'animationcancel animationend', removeAnimationClasses);\n            } else {\n              removeAnimationClasses();\n            }\n          }\n\n          trigger(el, inview ? 'inview' : 'outview');\n\n          state.inview = inview;\n\n          // change to `visibility: hidden` does not trigger observers\n          this.$update(el);\n        } } };\n\n    var scrollspyNav = {\n      mixins: [Scroll],\n\n      props: {\n        cls: String,\n        closest: String,\n        scroll: Boolean,\n        overflow: Boolean,\n        offset: Number },\n\n\n      data: {\n        cls: 'uk-active',\n        closest: false,\n        scroll: false,\n        overflow: true,\n        offset: 0 },\n\n\n      computed: {\n        links: {\n          get(_, $el) {\n            return $$('a[href*=\"#\"]', $el).filter((el) => el.hash && isSameSiteAnchor(el));\n          },\n\n          watch(links) {\n            if (this.scroll) {\n              this.$create('scroll', links, { offset: this.offset || 0 });\n            }\n          },\n\n          immediate: true },\n\n\n        elements(_ref) {let { closest: selector } = _ref;\n          return closest(this.links, selector || '*');\n        } },\n\n\n      update: [\n      {\n        read() {\n          const targets = this.links.map(getTargetElement).filter(Boolean);\n\n          const { length } = targets;\n\n          if (!length || !isVisible(this.$el)) {\n            return false;\n          }\n\n          const [scrollElement] = scrollParents(targets, /auto|scroll/, true);\n          const { scrollTop, scrollHeight } = scrollElement;\n          const viewport = offsetViewport(scrollElement);\n          const max = scrollHeight - viewport.height;\n          let active = false;\n\n          if (scrollTop === max) {\n            active = length - 1;\n          } else {\n            for (let i = 0; i < targets.length; i++) {\n              if (offset(targets[i]).top - viewport.top - this.offset > 0) {\n                break;\n              }\n              active = +i;\n            }\n\n            if (active === false && this.overflow) {\n              active = 0;\n            }\n          }\n\n          return { active };\n        },\n\n        write(_ref2) {let { active } = _ref2;\n          const changed = active !== false && !hasClass(this.elements[active], this.cls);\n\n          this.links.forEach((el) => el.blur());\n          for (let i = 0; i < this.elements.length; i++) {\n            toggleClass(this.elements[i], this.cls, +i === active);\n          }\n\n          if (changed) {\n            trigger(this.$el, 'active', [active, this.elements[active]]);\n          }\n        },\n\n        events: ['scroll', 'resize'] }] };\n\n    var sticky = {\n      mixins: [Class, Media, Resize, Scroll],\n\n      props: {\n        position: String,\n        top: null,\n        bottom: null,\n        start: null,\n        end: null,\n        offset: String,\n        overflowFlip: Boolean,\n        animation: String,\n        clsActive: String,\n        clsInactive: String,\n        clsFixed: String,\n        clsBelow: String,\n        selTarget: String,\n        showOnUp: Boolean,\n        targetOffset: Number },\n\n\n      data: {\n        position: 'top',\n        top: false,\n        bottom: false,\n        start: false,\n        end: false,\n        offset: 0,\n        overflowFlip: false,\n        animation: '',\n        clsActive: 'uk-active',\n        clsInactive: '',\n        clsFixed: 'uk-sticky-fixed',\n        clsBelow: 'uk-sticky-below',\n        selTarget: '',\n        showOnUp: false,\n        targetOffset: false },\n\n\n      computed: {\n        selTarget(_ref, $el) {let { selTarget } = _ref;\n          return selTarget && $(selTarget, $el) || $el;\n        } },\n\n\n      resizeTargets() {\n        return document.documentElement;\n      },\n\n      connected() {\n        this.start = coerce(this.start || this.top);\n        this.end = coerce(this.end || this.bottom);\n\n        this.placeholder =\n        $('+ .uk-sticky-placeholder', this.$el) ||\n        $('<div class=\"uk-sticky-placeholder\"></div>');\n        this.isFixed = false;\n        this.setActive(false);\n      },\n\n      disconnected() {\n        if (this.isFixed) {\n          this.hide();\n          removeClass(this.selTarget, this.clsInactive);\n        }\n\n        remove$1(this.placeholder);\n        this.placeholder = null;\n      },\n\n      events: [\n      {\n        name: 'resize',\n\n        el() {\n          return window;\n        },\n\n        handler() {\n          this.$emit('resize');\n        } },\n\n      {\n        name: 'load hashchange popstate',\n\n        el() {\n          return window;\n        },\n\n        filter() {\n          return this.targetOffset !== false;\n        },\n\n        handler() {\n          const { scrollingElement } = document;\n\n          if (!location.hash || scrollingElement.scrollTop === 0) {\n            return;\n          }\n\n          setTimeout(() => {\n            const targetOffset = offset($(location.hash));\n            const elOffset = offset(this.$el);\n\n            if (this.isFixed && intersectRect(targetOffset, elOffset)) {\n              scrollingElement.scrollTop =\n              targetOffset.top -\n              elOffset.height -\n              toPx(this.targetOffset, 'height', this.placeholder) -\n              toPx(this.offset, 'height', this.placeholder);\n            }\n          });\n        } }],\n\n\n\n      update: [\n      {\n        read(_ref2, types) {let { height: height$1, margin } = _ref2;\n          this.inactive = !this.matchMedia || !isVisible(this.$el);\n\n          if (this.inactive) {\n            return false;\n          }\n\n          const hide = this.active && types.has('resize');\n          if (hide) {\n            css(this.selTarget, 'transition', '0s');\n            this.hide();\n          }\n\n          if (!this.active) {\n            height$1 = offset(this.$el).height;\n            margin = css(this.$el, 'margin');\n          }\n\n          if (hide) {\n            this.show();\n            requestAnimationFrame(() => css(this.selTarget, 'transition', ''));\n          }\n\n          const referenceElement = this.isFixed ? this.placeholder : this.$el;\n          const windowHeight = height(window);\n\n          let position = this.position;\n          if (this.overflowFlip && height$1 > windowHeight) {\n            position = position === 'top' ? 'bottom' : 'top';\n          }\n\n          let offset$1 = toPx(this.offset, 'height', referenceElement);\n          if (position === 'bottom' && (height$1 < windowHeight || this.overflowFlip)) {\n            offset$1 += windowHeight - height$1;\n          }\n\n          const overflow = this.overflowFlip ?\n          0 :\n          Math.max(0, height$1 + offset$1 - windowHeight);\n          const topOffset = offset(referenceElement).top;\n\n          const start =\n          (this.start === false ?\n          topOffset :\n          parseProp(this.start, this.$el, topOffset)) - offset$1;\n          const end =\n          this.end === false ?\n          document.scrollingElement.scrollHeight - windowHeight :\n          parseProp(this.end, this.$el, topOffset + height$1, true) -\n          offset(this.$el).height +\n          overflow -\n          offset$1;\n\n          return {\n            start,\n            end,\n            offset: offset$1,\n            overflow,\n            topOffset,\n            height: height$1,\n            margin,\n            width: dimensions$1(referenceElement).width,\n            top: offsetPosition(referenceElement)[0] };\n\n        },\n\n        write(_ref3) {let { height, margin } = _ref3;\n          const { placeholder } = this;\n\n          css(placeholder, { height, margin });\n\n          if (!within(placeholder, document)) {\n            after(this.$el, placeholder);\n            placeholder.hidden = true;\n          }\n        },\n\n        events: ['resize'] },\n\n\n      {\n        read(_ref4)\n\n\n\n\n\n\n        {let { scroll: prevScroll = 0, dir: prevDir = 'down', overflow, overflowScroll = 0, start, end } = _ref4;\n          const scroll = document.scrollingElement.scrollTop;\n          const dir = prevScroll <= scroll ? 'down' : 'up';\n\n          return {\n            dir,\n            prevDir,\n            scroll,\n            prevScroll,\n            offsetParentTop: offset(\n            (this.isFixed ? this.placeholder : this.$el).offsetParent).\n            top,\n            overflowScroll: clamp(\n            overflowScroll + clamp(scroll, start, end) - clamp(prevScroll, start, end),\n            0,\n            overflow) };\n\n\n        },\n\n        write(data, types) {\n          const isScrollUpdate = types.has('scroll');\n          const {\n            initTimestamp = 0,\n            dir,\n            prevDir,\n            scroll,\n            prevScroll = 0,\n            top,\n            start,\n            topOffset,\n            height } =\n          data;\n\n          if (\n          scroll < 0 ||\n          scroll === prevScroll && isScrollUpdate ||\n          this.showOnUp && !isScrollUpdate && !this.isFixed)\n          {\n            return;\n          }\n\n          const now = Date.now();\n          if (now - initTimestamp > 300 || dir !== prevDir) {\n            data.initScroll = scroll;\n            data.initTimestamp = now;\n          }\n\n          if (\n          this.showOnUp &&\n          !this.isFixed &&\n          Math.abs(data.initScroll - scroll) <= 30 &&\n          Math.abs(prevScroll - scroll) <= 10)\n          {\n            return;\n          }\n\n          if (\n          this.inactive ||\n          scroll < start ||\n          this.showOnUp && (\n          scroll <= start ||\n          dir === 'down' && isScrollUpdate ||\n          dir === 'up' && !this.isFixed && scroll <= topOffset + height))\n          {\n            if (!this.isFixed) {\n              if (Animation.inProgress(this.$el) && top > scroll) {\n                Animation.cancel(this.$el);\n                this.hide();\n              }\n\n              return;\n            }\n\n            this.isFixed = false;\n\n            if (this.animation && scroll > topOffset) {\n              Animation.cancel(this.$el);\n              Animation.out(this.$el, this.animation).then(() => this.hide(), noop);\n            } else {\n              this.hide();\n            }\n          } else if (this.isFixed) {\n            this.update();\n          } else if (this.animation && scroll > topOffset) {\n            Animation.cancel(this.$el);\n            this.show();\n            Animation.in(this.$el, this.animation).catch(noop);\n          } else {\n            this.show();\n          }\n        },\n\n        events: ['resize', 'scroll'] }],\n\n\n\n      methods: {\n        show() {\n          this.isFixed = true;\n          this.update();\n          this.placeholder.hidden = false;\n        },\n\n        hide() {\n          this.setActive(false);\n          removeClass(this.$el, this.clsFixed, this.clsBelow);\n          css(this.$el, { position: '', top: '', width: '' });\n          this.placeholder.hidden = true;\n        },\n\n        update() {\n          let {\n            width,\n            scroll = 0,\n            overflow,\n            overflowScroll = 0,\n            start,\n            end,\n            offset,\n            topOffset,\n            height,\n            offsetParentTop } =\n          this._data;\n          const active = start !== 0 || scroll > start;\n          let position = 'fixed';\n\n          if (scroll > end) {\n            offset += end - offsetParentTop;\n            position = 'absolute';\n          }\n\n          if (overflow) {\n            offset -= overflowScroll;\n          }\n\n          css(this.$el, {\n            position,\n            top: offset + \"px\",\n            width });\n\n\n          this.setActive(active);\n          toggleClass(this.$el, this.clsBelow, scroll > topOffset + height);\n          addClass(this.$el, this.clsFixed);\n        },\n\n        setActive(active) {\n          const prev = this.active;\n          this.active = active;\n          if (active) {\n            replaceClass(this.selTarget, this.clsInactive, this.clsActive);\n            prev !== active && trigger(this.$el, 'active');\n          } else {\n            replaceClass(this.selTarget, this.clsActive, this.clsInactive);\n            prev !== active && trigger(this.$el, 'inactive');\n          }\n        } } };\n\n\n\n    function parseProp(value, el, propOffset, padding) {\n      if (!value) {\n        return 0;\n      }\n\n      if (isNumeric(value) || isString(value) && value.match(/^-?\\d/)) {\n        return propOffset + toPx(value, 'height', el, true);\n      } else {\n        const refElement = value === true ? parent(el) : query(value, el);\n        return (\n          offset(refElement).bottom - (\n          padding && refElement && within(el, refElement) ?\n          toFloat(css(refElement, 'paddingBottom')) :\n          0));\n\n      }\n    }\n\n    function coerce(value) {\n      if (value === 'true') {\n        return true;\n      } else if (value === 'false') {\n        return false;\n      }\n      return value;\n    }\n\n    var Switcher = {\n      mixins: [Lazyload, Swipe, Togglable],\n\n      args: 'connect',\n\n      props: {\n        connect: String,\n        toggle: String,\n        itemNav: String,\n        active: Number },\n\n\n      data: {\n        connect: '~.uk-switcher',\n        toggle: '> * > :first-child',\n        itemNav: false,\n        active: 0,\n        cls: 'uk-active',\n        attrItem: 'uk-switcher-item' },\n\n\n      computed: {\n        connects: {\n          get(_ref, $el) {let { connect } = _ref;\n            return queryAll(connect, $el);\n          },\n\n          watch(connects) {var _this$_observer;\n            if (this.swiping) {\n              css(connects, 'touchAction', 'pan-y pinch-zoom');\n            }\n\n            (_this$_observer = this._observer) == null ? void 0 : _this$_observer.disconnect();\n            this.registerObserver(\n            this._observer = observeMutation(\n            connects,\n            (records) => {\n              const index = this.index();\n              for (const { target: el } of records) {\n                children(el).forEach((child, i) =>\n                toggleClass(child, this.cls, i === index));\n\n                this.lazyload(this.$el, children(el));\n              }\n            },\n            { childList: true }));\n\n\n          },\n\n          immediate: true },\n\n\n        toggles: {\n          get(_ref2, $el) {let { toggle } = _ref2;\n            return $$(toggle, $el).filter(\n            (el) => !matches(el, '.uk-disabled *, .uk-disabled, [disabled]'));\n\n          },\n\n          watch(toggles) {\n            const active = this.index();\n            this.show(~active ? active : toggles[this.active] || toggles[0]);\n          },\n\n          immediate: true },\n\n\n        children() {\n          return children(this.$el).filter((child) =>\n          this.toggles.some((toggle) => within(toggle, child)));\n\n        },\n\n        swipeTarget() {\n          return this.connects;\n        } },\n\n\n      connected() {\n        // check for connects\n        ready(() => this.$emit());\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return this.toggle;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.show(e.current);\n        } },\n\n\n      {\n        name: 'click',\n\n        el() {\n          return this.connects.concat(this.itemNav ? queryAll(this.itemNav, this.$el) : []);\n        },\n\n        delegate() {\n          return \"[\" + this.attrItem + \"],[data-\" + this.attrItem + \"]\";\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.show(data(e.current, this.attrItem));\n        } },\n\n\n      {\n        name: 'swipeRight swipeLeft',\n\n        filter() {\n          return this.swiping;\n        },\n\n        el() {\n          return this.connects;\n        },\n\n        handler(_ref3) {let { type } = _ref3;\n          this.show(endsWith(type, 'Left') ? 'next' : 'previous');\n        } }],\n\n\n\n      methods: {\n        index() {\n          return findIndex(this.children, (el) => hasClass(el, this.cls));\n        },\n\n        show(item) {\n          const prev = this.index();\n          const next = getIndex(item, this.toggles, prev);\n          const active = getIndex(this.children[next], children(this.$el));\n          children(this.$el).forEach((child, i) => {\n            toggleClass(child, this.cls, active === i);\n            attr(this.toggles[i], 'aria-expanded', active === i);\n          });\n\n          const animate = prev >= 0 && prev !== next;\n          this.connects.forEach(async (_ref4) => {let { children } = _ref4;\n            await this.toggleElement(\n            toNodes(children).filter((child) => hasClass(child, this.cls)),\n            false,\n            animate);\n\n            await this.toggleElement(children[active], true, animate);\n          });\n        } } };\n\n    var tab = {\n      mixins: [Class],\n\n      extends: Switcher,\n\n      props: {\n        media: Boolean },\n\n\n      data: {\n        media: 960,\n        attrItem: 'uk-tab-item' },\n\n\n      connected() {\n        const cls = hasClass(this.$el, 'uk-tab-left') ?\n        'uk-tab-left' :\n        hasClass(this.$el, 'uk-tab-right') ?\n        'uk-tab-right' :\n        false;\n\n        if (cls) {\n          this.$create('toggle', this.$el, { cls, mode: 'media', media: this.media });\n        }\n      } };\n\n    const KEY_SPACE = 32;\n\n    var toggle = {\n      mixins: [Lazyload, Media, Togglable],\n\n      args: 'target',\n\n      props: {\n        href: String,\n        target: null,\n        mode: 'list',\n        queued: Boolean },\n\n\n      data: {\n        href: false,\n        target: false,\n        mode: 'click',\n        queued: true },\n\n\n      computed: {\n        target: {\n          get(_ref, $el) {let { href, target } = _ref;\n            target = queryAll(target || href, $el);\n            return target.length && target || [$el];\n          },\n\n          watch() {\n            this.updateAria();\n            this.lazyload(this.$el, this.target);\n          },\n\n          immediate: true } },\n\n\n\n      connected() {\n        if (!includes(this.mode, 'media') && !isFocusable(this.$el)) {\n          attr(this.$el, 'tabindex', '0');\n        }\n\n        // check for target\n        ready(() => this.$emit());\n      },\n\n      events: [\n      {\n        name: pointerDown$1,\n\n        filter() {\n          return includes(this.mode, 'hover');\n        },\n\n        handler(e) {\n          this._preventClick = null;\n\n          if (!isTouch(e) || this._showState) {\n            return;\n          }\n\n          // Clicking a button does not give it focus on all browsers and platforms\n          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus\n          trigger(this.$el, 'focus');\n          once(\n          document,\n          pointerDown$1,\n          () => trigger(this.$el, 'blur'),\n          true,\n          (e) => !within(e.target, this.$el));\n\n\n          // Prevent initial click to prevent double toggle through focus + click\n          if (includes(this.mode, 'click')) {\n            this._preventClick = true;\n          }\n        } },\n\n\n      {\n        name: pointerEnter + \" \" + pointerLeave + \" focus blur\",\n\n        filter() {\n          return includes(this.mode, 'hover');\n        },\n\n        handler(e) {\n          if (isTouch(e)) {\n            return;\n          }\n\n          const show = includes([pointerEnter, 'focus'], e.type);\n          const expanded = attr(this.$el, 'aria-expanded');\n\n          // Skip hide if still hovered or focused\n          if (\n          !show && (\n          e.type === pointerLeave && matches(this.$el, ':focus') ||\n          e.type === 'blur' && matches(this.$el, ':hover')))\n          {\n            return;\n          }\n\n          // Skip if state does not change e.g. hover + focus received\n          if (this._showState && show && expanded !== this._showState) {\n            // Ensure reset if state has changed through click\n            if (!show) {\n              this._showState = null;\n            }\n            return;\n          }\n\n          this._showState = show ? expanded : null;\n\n          this.toggle(\"toggle\" + (show ? 'show' : 'hide'));\n        } },\n\n\n      {\n        name: 'keydown',\n\n        filter() {\n          return includes(this.mode, 'click') && !isTag(this.$el, 'input');\n        },\n\n        handler(e) {\n          if (e.keyCode === KEY_SPACE) {\n            e.preventDefault();\n            this.$el.click();\n          }\n        } },\n\n\n      {\n        name: 'click',\n\n        filter() {\n          return ['click', 'hover'].some((mode) => includes(this.mode, mode));\n        },\n\n        handler(e) {\n          let link;\n          if (\n          this._preventClick ||\n          closest(e.target, 'a[href=\"#\"], a[href=\"\"]') ||\n          (link = closest(e.target, 'a[href]')) && (\n          attr(this.$el, 'aria-expanded') !== 'true' ||\n          link.hash && matches(this.target, link.hash)))\n          {\n            e.preventDefault();\n          }\n\n          if (!this._preventClick && includes(this.mode, 'click')) {\n            this.toggle();\n          }\n        } },\n\n\n      {\n        name: 'hide show',\n\n        self: true,\n\n        el() {\n          return this.target;\n        },\n\n        handler(_ref2) {let { target, type } = _ref2;\n          this.updateAria(target === this.target[0] && type === 'show');\n        } },\n\n\n      {\n        name: 'mediachange',\n\n        filter() {\n          return includes(this.mode, 'media');\n        },\n\n        el() {\n          return this.target;\n        },\n\n        handler(e, mediaObj) {\n          if (mediaObj.matches ^ this.isToggled(this.target)) {\n            this.toggle();\n          }\n        } }],\n\n\n\n      methods: {\n        async toggle(type) {\n          if (!trigger(this.target, type || 'toggle', [this])) {\n            return;\n          }\n\n          if (!this.queued) {\n            return this.toggleElement(this.target);\n          }\n\n          const leaving = this.target.filter((el) => hasClass(el, this.clsLeave));\n\n          if (leaving.length) {\n            for (const el of this.target) {\n              const isLeaving = includes(leaving, el);\n              this.toggleElement(el, isLeaving, isLeaving);\n            }\n            return;\n          }\n\n          const toggled = this.target.filter(this.isToggled);\n          await this.toggleElement(toggled, false);\n          await this.toggleElement(\n          this.target.filter((el) => !includes(toggled, el)),\n          true);\n\n        },\n\n        updateAria(toggled) {\n          if (includes(this.mode, 'media')) {\n            return;\n          }\n\n          attr(\n          this.$el,\n          'aria-expanded',\n          isBoolean(toggled) ? toggled : this.isToggled(this.target));\n\n        } } };\n\n    var components$1 = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        Accordion: Accordion,\n        Alert: alert,\n        Cover: cover,\n        Drop: drop,\n        Dropdown: drop,\n        FormCustom: formCustom,\n        Grid: grid,\n        HeightMatch: heightMatch,\n        HeightViewport: heightViewport,\n        Icon: Icon,\n        Img: img,\n        Leader: leader,\n        Margin: Margin,\n        Modal: modal,\n        Nav: nav,\n        Navbar: navbar,\n        Offcanvas: offcanvas,\n        OverflowAuto: overflowAuto,\n        Responsive: responsive,\n        Scroll: scroll,\n        Scrollspy: scrollspy,\n        ScrollspyNav: scrollspyNav,\n        Sticky: sticky,\n        Svg: SVG,\n        Switcher: Switcher,\n        Tab: tab,\n        Toggle: toggle,\n        Video: Video,\n        Close: Close,\n        Spinner: Spinner,\n        NavParentIcon: NavParentIcon,\n        SlidenavNext: Slidenav,\n        SlidenavPrevious: Slidenav,\n        SearchIcon: Search,\n        Marker: IconComponent,\n        NavbarParentIcon: IconComponent,\n        NavbarToggleIcon: IconComponent,\n        OverlayIcon: IconComponent,\n        PaginationNext: IconComponent,\n        PaginationPrevious: IconComponent,\n        Totop: IconComponent\n    });\n\n    // register components\n    each(components$1, (component, name) => UIkit.component(name, component));\n\n    boot(UIkit);\n\n    const units = ['days', 'hours', 'minutes', 'seconds'];\n\n    var countdown = {\n      mixins: [Class],\n\n      props: {\n        date: String,\n        clsWrapper: String },\n\n\n      data: {\n        date: '',\n        clsWrapper: '.uk-countdown-%unit%' },\n\n\n      connected() {\n        this.date = Date.parse(this.$props.date);\n        this.start();\n      },\n\n      disconnected() {\n        this.stop();\n      },\n\n      events: [\n      {\n        name: 'visibilitychange',\n\n        el() {\n          return document;\n        },\n\n        handler() {\n          if (document.hidden) {\n            this.stop();\n          } else {\n            this.start();\n          }\n        } }],\n\n\n\n      methods: {\n        start() {\n          this.stop();\n          this.update();\n          this.timer = setInterval(this.update, 1000);\n        },\n\n        stop() {\n          clearInterval(this.timer);\n        },\n\n        update() {\n          const timespan = getTimeSpan(this.date);\n\n          if (!this.date || timespan.total <= 0) {\n            this.stop();\n\n            timespan.days = timespan.hours = timespan.minutes = timespan.seconds = 0;\n          }\n\n          for (const unit of units) {\n            const el = $(this.clsWrapper.replace('%unit%', unit), this.$el);\n\n            if (!el) {\n              continue;\n            }\n\n            let digits = String(Math.trunc(timespan[unit]));\n\n            digits = digits.length < 2 ? \"0\" + digits : digits;\n\n            if (el.textContent !== digits) {\n              digits = digits.split('');\n\n              if (digits.length !== el.children.length) {\n                html(el, digits.map(() => '<span></span>').join(''));\n              }\n\n              digits.forEach((digit, i) => el.children[i].textContent = digit);\n            }\n          }\n        } } };\n\n\n\n    function getTimeSpan(date) {\n      const total = date - Date.now();\n\n      return {\n        total,\n        seconds: total / 1000 % 60,\n        minutes: total / 1000 / 60 % 60,\n        hours: total / 1000 / 60 / 60 % 24,\n        days: total / 1000 / 60 / 60 / 24 };\n\n    }\n\n    const clsLeave = 'uk-transition-leave';\n    const clsEnter = 'uk-transition-enter';\n\n    function fade(action, target, duration, stagger) {if (stagger === void 0) {stagger = 0;}\n      const index = transitionIndex(target, true);\n      const propsIn = { opacity: 1 };\n      const propsOut = { opacity: 0 };\n\n      const wrapIndexFn = (fn) => () => index === transitionIndex(target) ? fn() : Promise.reject();\n\n      const leaveFn = wrapIndexFn(async () => {\n        addClass(target, clsLeave);\n\n        await Promise.all(\n        getTransitionNodes(target).map(\n        (child, i) =>\n        new Promise((resolve) =>\n        setTimeout(\n        () =>\n        Transition.start(child, propsOut, duration / 2, 'ease').then(\n        resolve),\n\n        i * stagger))));\n\n\n\n\n\n        removeClass(target, clsLeave);\n      });\n\n      const enterFn = wrapIndexFn(async () => {\n        const oldHeight = height(target);\n\n        addClass(target, clsEnter);\n        action();\n\n        css(children(target), { opacity: 0 });\n\n        // Ensure UIkit updates have propagated\n        await awaitFrame$1();\n\n        const nodes = children(target);\n        const newHeight = height(target);\n\n        // Ensure Grid cells do not stretch when height is applied\n        css(target, 'alignContent', 'flex-start');\n        height(target, oldHeight);\n\n        const transitionNodes = getTransitionNodes(target);\n        css(nodes, propsOut);\n\n        const transitions = transitionNodes.map(async (child, i) => {\n          await awaitTimeout(i * stagger);\n          await Transition.start(child, propsIn, duration / 2, 'ease');\n        });\n\n        if (oldHeight !== newHeight) {\n          transitions.push(\n          Transition.start(\n          target,\n          { height: newHeight },\n          duration / 2 + transitionNodes.length * stagger,\n          'ease'));\n\n\n        }\n\n        await Promise.all(transitions).then(() => {\n          removeClass(target, clsEnter);\n          if (index === transitionIndex(target)) {\n            css(target, { height: '', alignContent: '' });\n            css(nodes, { opacity: '' });\n            delete target.dataset.transition;\n          }\n        });\n      });\n\n      return hasClass(target, clsLeave) ?\n      waitTransitionend(target).then(enterFn) :\n      hasClass(target, clsEnter) ?\n      waitTransitionend(target).then(leaveFn).then(enterFn) :\n      leaveFn().then(enterFn);\n    }\n\n    function transitionIndex(target, next) {\n      if (next) {\n        target.dataset.transition = 1 + transitionIndex(target);\n      }\n\n      return toNumber(target.dataset.transition) || 0;\n    }\n\n    function waitTransitionend(target) {\n      return Promise.all(\n      children(target).\n      filter(Transition.inProgress).\n      map(\n      (el) =>\n      new Promise((resolve) => once(el, 'transitionend transitioncanceled', resolve))));\n\n\n    }\n\n    function getTransitionNodes(target) {\n      return getRows(children(target)).reduce(\n      (nodes, row) =>\n      nodes.concat(\n      sortBy$1(\n      row.filter((el) => isInView(el)),\n      'offsetLeft')),\n\n\n      []);\n\n    }\n\n    function awaitFrame$1() {\n      return new Promise((resolve) => requestAnimationFrame(resolve));\n    }\n\n    function awaitTimeout(timeout) {\n      return new Promise((resolve) => setTimeout(resolve, timeout));\n    }\n\n    async function slide (action, target, duration) {\n      await awaitFrame();\n\n      let nodes = children(target);\n\n      // Get current state\n      const currentProps = nodes.map((el) => getProps(el, true));\n      const targetProps = { ...css(target, ['height', 'padding']), display: 'block' };\n\n      // Cancel previous animations\n      await Promise.all(nodes.concat(target).map(Transition.cancel));\n\n      // Adding, sorting, removing nodes\n      action();\n\n      // Find new nodes\n      nodes = nodes.concat(children(target).filter((el) => !includes(nodes, el)));\n\n      // Wait for update to propagate\n      await Promise.resolve();\n\n      // Force update\n      fastdom.flush();\n\n      // Get new state\n      const targetStyle = attr(target, 'style');\n      const targetPropsTo = css(target, ['height', 'padding']);\n      const [propsTo, propsFrom] = getTransitionProps(target, nodes, currentProps);\n      const attrsTo = nodes.map((el) => ({\n        class: attr(el, 'class'),\n        style: attr(el, 'style') }));\n\n\n      // Reset to previous state\n      nodes.forEach((el, i) => propsFrom[i] && css(el, propsFrom[i]));\n      css(target, targetProps);\n\n      // Start transitions on next frame\n      await awaitFrame();\n\n      const transitions = nodes.\n      map((el, i) => parent(el) === target && Transition.start(el, propsTo[i], duration, 'ease')).\n      concat(Transition.start(target, targetPropsTo, duration, 'ease'));\n\n      try {\n        await Promise.all(transitions);\n        nodes.forEach((el, i) => {\n          attr(el, attrsTo[i]);\n          if (parent(el) === target) {\n            css(el, 'display', propsTo[i].opacity === 0 ? 'none' : '');\n          }\n        });\n        attr(target, 'style', targetStyle);\n      } catch (e) {\n        attr(nodes, 'style', '');\n        resetProps(target, targetProps);\n      }\n    }\n\n    function getProps(el, opacity) {\n      const zIndex = css(el, 'zIndex');\n\n      return isVisible(el) ?\n      {\n        display: '',\n        opacity: opacity ? css(el, 'opacity') : '0',\n        pointerEvents: 'none',\n        position: 'absolute',\n        zIndex: zIndex === 'auto' ? index(el) : zIndex,\n        ...getPositionWithMargin(el) } :\n\n      false;\n    }\n\n    function getTransitionProps(target, nodes, currentProps) {\n      const propsTo = nodes.map((el, i) =>\n      parent(el) && i in currentProps ?\n      currentProps[i] ?\n      isVisible(el) ?\n      getPositionWithMargin(el) :\n      { opacity: 0 } :\n      { opacity: isVisible(el) ? 1 : 0 } :\n      false);\n\n\n      const propsFrom = propsTo.map((props, i) => {\n        const from = parent(nodes[i]) === target && (currentProps[i] || getProps(nodes[i]));\n\n        if (!from) {\n          return false;\n        }\n\n        if (!props) {\n          delete from.opacity;\n        } else if (!('opacity' in props)) {\n          const { opacity } = from;\n\n          if (opacity % 1) {\n            props.opacity = 1;\n          } else {\n            delete from.opacity;\n          }\n        }\n\n        return from;\n      });\n\n      return [propsTo, propsFrom];\n    }\n\n    function resetProps(el, props) {\n      for (const prop in props) {\n        css(el, prop, '');\n      }\n    }\n\n    function getPositionWithMargin(el) {\n      const { height, width } = offset(el);\n\n      return {\n        height,\n        width,\n        transform: '',\n        ...position(el),\n        ...css(el, ['marginTop', 'marginLeft']) };\n\n    }\n\n    function awaitFrame() {\n      return new Promise((resolve) => requestAnimationFrame(resolve));\n    }\n\n    var Animate = {\n      props: {\n        duration: Number,\n        animation: Boolean },\n\n\n      data: {\n        duration: 150,\n        animation: 'slide' },\n\n\n      methods: {\n        animate(action, target) {if (target === void 0) {target = this.$el;}\n          const name = this.animation;\n          const animationFn =\n          name === 'fade' ?\n          fade :\n          name === 'delayed-fade' ?\n          function () {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}return fade(...args, 40);} :\n          name ?\n          slide :\n          () => {\n            action();\n            return Promise.resolve();\n          };\n\n          return animationFn(action, target, this.duration).catch(noop);\n        } } };\n\n    var filter = {\n      mixins: [Animate],\n\n      args: 'target',\n\n      props: {\n        target: Boolean,\n        selActive: Boolean },\n\n\n      data: {\n        target: null,\n        selActive: false,\n        attrItem: 'uk-filter-control',\n        cls: 'uk-active',\n        duration: 250 },\n\n\n      computed: {\n        toggles: {\n          get(_ref, $el) {let { attrItem } = _ref;\n            return $$(\"[\" + attrItem + \"],[data-\" + attrItem + \"]\", $el);\n          },\n\n          watch() {\n            this.updateState();\n\n            if (this.selActive !== false) {\n              const actives = $$(this.selActive, this.$el);\n              this.toggles.forEach((el) => toggleClass(el, this.cls, includes(actives, el)));\n            }\n          },\n\n          immediate: true },\n\n\n        children: {\n          get(_ref2, $el) {let { target } = _ref2;\n            return $$(target + \" > *\", $el);\n          },\n\n          watch(list, old) {\n            if (old && !isEqualList(list, old)) {\n              this.updateState();\n            }\n          },\n\n          immediate: true } },\n\n\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return \"[\" + this.attrItem + \"],[data-\" + this.attrItem + \"]\";\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.apply(e.current);\n        } }],\n\n\n\n      methods: {\n        apply(el) {\n          const prevState = this.getState();\n          const newState = mergeState(el, this.attrItem, this.getState());\n\n          if (!isEqualState(prevState, newState)) {\n            this.setState(newState);\n          }\n        },\n\n        getState() {\n          return this.toggles.\n          filter((item) => hasClass(item, this.cls)).\n          reduce((state, el) => mergeState(el, this.attrItem, state), {\n            filter: { '': '' },\n            sort: [] });\n\n        },\n\n        async setState(state, animate) {if (animate === void 0) {animate = true;}\n          state = { filter: { '': '' }, sort: [], ...state };\n\n          trigger(this.$el, 'beforeFilter', [this, state]);\n\n          this.toggles.forEach((el) =>\n          toggleClass(el, this.cls, !!matchFilter(el, this.attrItem, state)));\n\n\n          await Promise.all(\n          $$(this.target, this.$el).map((target) => {\n            const filterFn = () => {\n              applyState(state, target, children(target));\n              this.$update(this.$el);\n            };\n            return animate ? this.animate(filterFn, target) : filterFn();\n          }));\n\n\n          trigger(this.$el, 'afterFilter', [this]);\n        },\n\n        updateState() {\n          fastdom.write(() => this.setState(this.getState(), false));\n        } } };\n\n\n\n    function getFilter(el, attr) {\n      return parseOptions(data(el, attr), ['filter']);\n    }\n\n    function isEqualState(stateA, stateB) {\n      return ['filter', 'sort'].every((prop) => isEqual(stateA[prop], stateB[prop]));\n    }\n\n    function applyState(state, target, children) {\n      const selector = getSelector(state);\n\n      children.forEach((el) => css(el, 'display', selector && !matches(el, selector) ? 'none' : ''));\n\n      const [sort, order] = state.sort;\n\n      if (sort) {\n        const sorted = sortItems(children, sort, order);\n        if (!isEqual(sorted, children)) {\n          append(target, sorted);\n        }\n      }\n    }\n\n    function mergeState(el, attr, state) {\n      const { filter, group, sort, order = 'asc' } = getFilter(el, attr);\n\n      if (filter || isUndefined(sort)) {\n        if (group) {\n          if (filter) {\n            delete state.filter[''];\n            state.filter[group] = filter;\n          } else {\n            delete state.filter[group];\n\n            if (isEmpty(state.filter) || '' in state.filter) {\n              state.filter = { '': filter || '' };\n            }\n          }\n        } else {\n          state.filter = { '': filter || '' };\n        }\n      }\n\n      if (!isUndefined(sort)) {\n        state.sort = [sort, order];\n      }\n\n      return state;\n    }\n\n    function matchFilter(\n    el,\n    attr, _ref3)\n\n    {let { filter: stateFilter = { '': '' }, sort: [stateSort, stateOrder] } = _ref3;\n      const { filter = '', group = '', sort, order = 'asc' } = getFilter(el, attr);\n\n      return isUndefined(sort) ?\n      group in stateFilter && filter === stateFilter[group] ||\n      !filter && group && !(group in stateFilter) && !stateFilter[''] :\n      stateSort === sort && stateOrder === order;\n    }\n\n    function isEqualList(listA, listB) {\n      return listA.length === listB.length && listA.every((el) => listB.includes(el));\n    }\n\n    function getSelector(_ref4) {let { filter } = _ref4;\n      let selector = '';\n      each(filter, (value) => selector += value || '');\n      return selector;\n    }\n\n    function sortItems(nodes, sort, order) {\n      return [...nodes].sort(\n      (a, b) =>\n      data(a, sort).localeCompare(data(b, sort), undefined, { numeric: true }) * (\n      order === 'asc' || -1));\n\n    }\n\n    var Animations$2 = {\n      slide: {\n        show(dir) {\n          return [{ transform: translate(dir * -100) }, { transform: translate() }];\n        },\n\n        percent(current) {\n          return translated(current);\n        },\n\n        translate(percent, dir) {\n          return [\n          { transform: translate(dir * -100 * percent) },\n          { transform: translate(dir * 100 * (1 - percent)) }];\n\n        } } };\n\n\n\n    function translated(el) {\n      return Math.abs(css(el, 'transform').split(',')[4] / el.offsetWidth) || 0;\n    }\n\n    function translate(value, unit) {if (value === void 0) {value = 0;}if (unit === void 0) {unit = '%';}\n      value += value ? unit : '';\n      return \"translate3d(\" + value + \", 0, 0)\";\n    }\n\n    function scale3d(value) {\n      return \"scale3d(\" + value + \", \" + value + \", 1)\";\n    }\n\n    var Animations$1 = {\n      ...Animations$2,\n      fade: {\n        show() {\n          return [{ opacity: 0 }, { opacity: 1 }];\n        },\n\n        percent(current) {\n          return 1 - css(current, 'opacity');\n        },\n\n        translate(percent) {\n          return [{ opacity: 1 - percent }, { opacity: percent }];\n        } },\n\n\n      scale: {\n        show() {\n          return [\n          { opacity: 0, transform: scale3d(1 - 0.2) },\n          { opacity: 1, transform: scale3d(1) }];\n\n        },\n\n        percent(current) {\n          return 1 - css(current, 'opacity');\n        },\n\n        translate(percent) {\n          return [\n          { opacity: 1 - percent, transform: scale3d(1 - 0.2 * percent) },\n          { opacity: percent, transform: scale3d(1 - 0.2 + 0.2 * percent) }];\n\n        } } };\n\n    function Transitioner$1(prev, next, dir, _ref) {let { animation, easing } = _ref;\n      const { percent, translate, show = noop } = animation;\n      const props = show(dir);\n      const deferred = new Deferred();\n\n      return {\n        dir,\n\n        show(duration, percent, linear) {if (percent === void 0) {percent = 0;}\n          const timing = linear ? 'linear' : easing;\n          duration -= Math.round(duration * clamp(percent, -1, 1));\n\n          this.translate(percent);\n\n          triggerUpdate$1(next, 'itemin', { percent, duration, timing, dir });\n          triggerUpdate$1(prev, 'itemout', { percent: 1 - percent, duration, timing, dir });\n\n          Promise.all([\n          Transition.start(next, props[1], duration, timing),\n          Transition.start(prev, props[0], duration, timing)]).\n          then(() => {\n            this.reset();\n            deferred.resolve();\n          }, noop);\n\n          return deferred.promise;\n        },\n\n        cancel() {\n          Transition.cancel([next, prev]);\n        },\n\n        reset() {\n          for (const prop in props[0]) {\n            css([next, prev], prop, '');\n          }\n        },\n\n        forward(duration, percent) {if (percent === void 0) {percent = this.percent();}\n          Transition.cancel([next, prev]);\n          return this.show(duration, percent, true);\n        },\n\n        translate(percent) {\n          this.reset();\n\n          const props = translate(percent, dir);\n          css(next, props[1]);\n          css(prev, props[0]);\n          triggerUpdate$1(next, 'itemtranslatein', { percent, dir });\n          triggerUpdate$1(prev, 'itemtranslateout', { percent: 1 - percent, dir });\n        },\n\n        percent() {\n          return percent(prev || next, next, dir);\n        },\n\n        getDistance() {\n          return prev == null ? void 0 : prev.offsetWidth;\n        } };\n\n    }\n\n    function triggerUpdate$1(el, type, data) {\n      trigger(el, createEvent(type, false, false, data));\n    }\n\n    var SliderAutoplay = {\n      props: {\n        autoplay: Boolean,\n        autoplayInterval: Number,\n        pauseOnHover: Boolean },\n\n\n      data: {\n        autoplay: false,\n        autoplayInterval: 7000,\n        pauseOnHover: true },\n\n\n      connected() {\n        this.autoplay && this.startAutoplay();\n      },\n\n      disconnected() {\n        this.stopAutoplay();\n      },\n\n      update() {\n        attr(this.slides, 'tabindex', '-1');\n      },\n\n      events: [\n      {\n        name: 'visibilitychange',\n\n        el() {\n          return document;\n        },\n\n        filter() {\n          return this.autoplay;\n        },\n\n        handler() {\n          if (document.hidden) {\n            this.stopAutoplay();\n          } else {\n            this.startAutoplay();\n          }\n        } }],\n\n\n\n      methods: {\n        startAutoplay() {\n          this.stopAutoplay();\n\n          this.interval = setInterval(\n          () =>\n          (!this.draggable || !$(':focus', this.$el)) && (\n          !this.pauseOnHover || !matches(this.$el, ':hover')) &&\n          !this.stack.length &&\n          this.show('next'),\n          this.autoplayInterval);\n\n        },\n\n        stopAutoplay() {\n          this.interval && clearInterval(this.interval);\n        } } };\n\n    const pointerOptions = { passive: false, capture: true };\n    const pointerUpOptions = { passive: true, capture: true };\n    const pointerDown = 'touchstart mousedown';\n    const pointerMove = 'touchmove mousemove';\n    const pointerUp = 'touchend touchcancel mouseup click input scroll';\n\n    var SliderDrag = {\n      props: {\n        draggable: Boolean },\n\n\n      data: {\n        draggable: true,\n        threshold: 10 },\n\n\n      created() {\n        for (const key of ['start', 'move', 'end']) {\n          const fn = this[key];\n          this[key] = (e) => {\n            const pos = getEventPos(e).x * (isRtl ? -1 : 1);\n\n            this.prevPos = pos === this.pos ? this.prevPos : this.pos;\n            this.pos = pos;\n\n            fn(e);\n          };\n        }\n      },\n\n      events: [\n      {\n        name: pointerDown,\n\n        passive: true,\n\n        delegate() {\n          return this.selSlides;\n        },\n\n        handler(e) {\n          if (\n          !this.draggable ||\n          !isTouch(e) && hasSelectableText(e.target) ||\n          closest(e.target, selInput) ||\n          e.button > 0 ||\n          this.length < 2)\n          {\n            return;\n          }\n\n          this.start(e);\n        } },\n\n\n      {\n        name: 'dragstart',\n\n        handler(e) {\n          e.preventDefault();\n        } },\n\n\n      {\n        // iOS workaround for slider stopping if swiping fast\n        name: pointerMove,\n        el() {\n          return this.list;\n        },\n        handler: noop,\n        ...pointerOptions }],\n\n\n\n      methods: {\n        start() {\n          this.drag = this.pos;\n\n          if (this._transitioner) {\n            this.percent = this._transitioner.percent();\n            this.drag += this._transitioner.getDistance() * this.percent * this.dir;\n\n            this._transitioner.cancel();\n            this._transitioner.translate(this.percent);\n\n            this.dragging = true;\n\n            this.stack = [];\n          } else {\n            this.prevIndex = this.index;\n          }\n\n          on(document, pointerMove, this.move, pointerOptions);\n\n          // 'input' event is triggered by video controls\n          on(document, pointerUp, this.end, pointerUpOptions);\n\n          css(this.list, 'userSelect', 'none');\n        },\n\n        move(e) {\n          const distance = this.pos - this.drag;\n\n          if (\n          distance === 0 ||\n          this.prevPos === this.pos ||\n          !this.dragging && Math.abs(distance) < this.threshold)\n          {\n            return;\n          }\n\n          // prevent click event\n          css(this.list, 'pointerEvents', 'none');\n\n          e.cancelable && e.preventDefault();\n\n          this.dragging = true;\n          this.dir = distance < 0 ? 1 : -1;\n\n          const { slides } = this;\n          let { prevIndex } = this;\n          let dis = Math.abs(distance);\n          let nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);\n          let width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;\n\n          while (nextIndex !== prevIndex && dis > width) {\n            this.drag -= width * this.dir;\n\n            prevIndex = nextIndex;\n            dis -= width;\n            nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);\n            width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;\n          }\n\n          this.percent = dis / width;\n\n          const prev = slides[prevIndex];\n          const next = slides[nextIndex];\n          const changed = this.index !== nextIndex;\n          const edge = prevIndex === nextIndex;\n\n          let itemShown;\n\n          [this.index, this.prevIndex].\n          filter((i) => !includes([nextIndex, prevIndex], i)).\n          forEach((i) => {\n            trigger(slides[i], 'itemhidden', [this]);\n\n            if (edge) {\n              itemShown = true;\n              this.prevIndex = prevIndex;\n            }\n          });\n\n          if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) {\n            trigger(slides[this.index], 'itemshown', [this]);\n          }\n\n          if (changed) {\n            this.prevIndex = prevIndex;\n            this.index = nextIndex;\n\n            !edge && trigger(prev, 'beforeitemhide', [this]);\n            trigger(next, 'beforeitemshow', [this]);\n          }\n\n          this._transitioner = this._translate(Math.abs(this.percent), prev, !edge && next);\n\n          if (changed) {\n            !edge && trigger(prev, 'itemhide', [this]);\n            trigger(next, 'itemshow', [this]);\n          }\n        },\n\n        end() {\n          off(document, pointerMove, this.move, pointerOptions);\n          off(document, pointerUp, this.end, pointerUpOptions);\n\n          if (this.dragging) {\n            this.dragging = null;\n\n            if (this.index === this.prevIndex) {\n              this.percent = 1 - this.percent;\n              this.dir *= -1;\n              this._show(false, this.index, true);\n              this._transitioner = null;\n            } else {\n              const dirChange =\n              (isRtl ? this.dir * (isRtl ? 1 : -1) : this.dir) < 0 ===\n              this.prevPos > this.pos;\n              this.index = dirChange ? this.index : this.prevIndex;\n\n              if (dirChange) {\n                this.percent = 1 - this.percent;\n              }\n\n              this.show(\n              this.dir > 0 && !dirChange || this.dir < 0 && dirChange ?\n              'next' :\n              'previous',\n              true);\n\n            }\n          }\n\n          css(this.list, { userSelect: '', pointerEvents: '' });\n\n          this.drag = this.percent = null;\n        } } };\n\n\n\n    function hasSelectableText(el) {\n      return (\n        css(el, 'userSelect') !== 'none' &&\n        toNodes(el.childNodes).some((el) => el.nodeType === 3 && el.textContent.trim()));\n\n    }\n\n    var SliderNav = {\n      data: {\n        selNav: false },\n\n\n      computed: {\n        nav(_ref, $el) {let { selNav } = _ref;\n          return $(selNav, $el);\n        },\n\n        selNavItem(_ref2) {let { attrItem } = _ref2;\n          return \"[\" + attrItem + \"],[data-\" + attrItem + \"]\";\n        },\n\n        navItems(_, $el) {\n          return $$(this.selNavItem, $el);\n        } },\n\n\n      update: {\n        write() {\n          if (this.nav && this.length !== this.nav.children.length) {\n            html(\n            this.nav,\n            this.slides.\n            map((_, i) => \"<li \" + this.attrItem + \"=\\\"\" + i + \"\\\"><a href></a></li>\").\n            join(''));\n\n          }\n\n          this.navItems.concat(this.nav).forEach((el) => el && (el.hidden = !this.maxIndex));\n\n          this.updateNav();\n        },\n\n        events: ['resize'] },\n\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return this.selNavItem;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.show(data(e.current, this.attrItem));\n        } },\n\n\n      {\n        name: 'itemshow',\n        handler: 'updateNav' }],\n\n\n\n      methods: {\n        updateNav() {\n          const i = this.getValidIndex();\n          for (const el of this.navItems) {\n            const cmd = data(el, this.attrItem);\n\n            toggleClass(el, this.clsActive, toNumber(cmd) === i);\n            toggleClass(\n            el,\n            'uk-invisible',\n            this.finite && (\n            cmd === 'previous' && i === 0 || cmd === 'next' && i >= this.maxIndex));\n\n          }\n        } } };\n\n    var Slider = {\n      mixins: [SliderAutoplay, SliderDrag, SliderNav, Resize],\n\n      props: {\n        clsActivated: Boolean,\n        easing: String,\n        index: Number,\n        finite: Boolean,\n        velocity: Number,\n        selSlides: String },\n\n\n      data: () => ({\n        easing: 'ease',\n        finite: false,\n        velocity: 1,\n        index: 0,\n        prevIndex: -1,\n        stack: [],\n        percent: 0,\n        clsActive: 'uk-active',\n        clsActivated: false,\n        Transitioner: false,\n        transitionOptions: {} }),\n\n\n      connected() {\n        this.prevIndex = -1;\n        this.index = this.getValidIndex(this.$props.index);\n        this.stack = [];\n      },\n\n      disconnected() {\n        removeClass(this.slides, this.clsActive);\n      },\n\n      computed: {\n        duration(_ref, $el) {let { velocity } = _ref;\n          return speedUp($el.offsetWidth / velocity);\n        },\n\n        list(_ref2, $el) {let { selList } = _ref2;\n          return $(selList, $el);\n        },\n\n        maxIndex() {\n          return this.length - 1;\n        },\n\n        selSlides(_ref3) {let { selList, selSlides } = _ref3;\n          return selList + \" \" + (selSlides || '> *');\n        },\n\n        slides: {\n          get() {\n            return $$(this.selSlides, this.$el);\n          },\n\n          watch() {\n            this.$emit('resize');\n          } },\n\n\n        length() {\n          return this.slides.length;\n        } },\n\n\n      methods: {\n        show(index, force) {if (force === void 0) {force = false;}\n          if (this.dragging || !this.length) {\n            return;\n          }\n\n          const { stack } = this;\n          const queueIndex = force ? 0 : stack.length;\n          const reset = () => {\n            stack.splice(queueIndex, 1);\n\n            if (stack.length) {\n              this.show(stack.shift(), true);\n            }\n          };\n\n          stack[force ? 'unshift' : 'push'](index);\n\n          if (!force && stack.length > 1) {\n            if (stack.length === 2) {\n              this._transitioner.forward(Math.min(this.duration, 200));\n            }\n\n            return;\n          }\n\n          const prevIndex = this.getIndex(this.index);\n          const prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex];\n          const nextIndex = this.getIndex(index, this.index);\n          const next = this.slides[nextIndex];\n\n          if (prev === next) {\n            reset();\n            return;\n          }\n\n          this.dir = getDirection(index, prevIndex);\n          this.prevIndex = prevIndex;\n          this.index = nextIndex;\n\n          if (\n          prev && !trigger(prev, 'beforeitemhide', [this]) ||\n          !trigger(next, 'beforeitemshow', [this, prev]))\n          {\n            this.index = this.prevIndex;\n            reset();\n            return;\n          }\n\n          const promise = this._show(prev, next, force).then(() => {\n            prev && trigger(prev, 'itemhidden', [this]);\n            trigger(next, 'itemshown', [this]);\n\n            return new Promise((resolve) => {\n              requestAnimationFrame(() => {\n                stack.shift();\n                if (stack.length) {\n                  this.show(stack.shift(), true);\n                } else {\n                  this._transitioner = null;\n                }\n                resolve();\n              });\n            });\n          });\n\n          prev && trigger(prev, 'itemhide', [this]);\n          trigger(next, 'itemshow', [this]);\n\n          return promise;\n        },\n\n        getIndex(index, prev) {if (index === void 0) {index = this.index;}if (prev === void 0) {prev = this.index;}\n          return clamp(getIndex(index, this.slides, prev, this.finite), 0, this.maxIndex);\n        },\n\n        getValidIndex(index, prevIndex) {if (index === void 0) {index = this.index;}if (prevIndex === void 0) {prevIndex = this.prevIndex;}\n          return this.getIndex(index, prevIndex);\n        },\n\n        _show(prev, next, force) {\n          this._transitioner = this._getTransitioner(prev, next, this.dir, {\n            easing: force ?\n            next.offsetWidth < 600 ?\n            'cubic-bezier(0.25, 0.46, 0.45, 0.94)' /* easeOutQuad */ :\n            'cubic-bezier(0.165, 0.84, 0.44, 1)' /* easeOutQuart */ :\n            this.easing,\n            ...this.transitionOptions });\n\n\n          if (!force && !prev) {\n            this._translate(1);\n            return Promise.resolve();\n          }\n\n          const { length } = this.stack;\n          return this._transitioner[length > 1 ? 'forward' : 'show'](\n          length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration,\n          this.percent);\n\n        },\n\n        _getDistance(prev, next) {\n          return this._getTransitioner(prev, prev !== next && next).getDistance();\n        },\n\n        _translate(percent, prev, next) {if (prev === void 0) {prev = this.prevIndex;}if (next === void 0) {next = this.index;}\n          const transitioner = this._getTransitioner(prev !== next ? prev : false, next);\n          transitioner.translate(percent);\n          return transitioner;\n        },\n\n        _getTransitioner(\n        prev,\n        next,\n        dir,\n        options)\n        {if (prev === void 0) {prev = this.prevIndex;}if (next === void 0) {next = this.index;}if (dir === void 0) {dir = this.dir || 1;}if (options === void 0) {options = this.transitionOptions;}\n          return new this.Transitioner(\n          isNumber(prev) ? this.slides[prev] : prev,\n          isNumber(next) ? this.slides[next] : next,\n          dir * (isRtl ? -1 : 1),\n          options);\n\n        } } };\n\n\n\n    function getDirection(index, prevIndex) {\n      return index === 'next' ? 1 : index === 'previous' ? -1 : index < prevIndex ? -1 : 1;\n    }\n\n    function speedUp(x) {\n      return 0.5 * x + 300; // parabola through (400,500; 600,600; 1800,1200)\n    }\n\n    var Slideshow = {\n      mixins: [Slider],\n\n      props: {\n        animation: String },\n\n\n      data: {\n        animation: 'slide',\n        clsActivated: 'uk-transition-active',\n        Animations: Animations$2,\n        Transitioner: Transitioner$1 },\n\n\n      computed: {\n        animation(_ref) {let { animation, Animations } = _ref;\n          return { ...(Animations[animation] || Animations.slide), name: animation };\n        },\n\n        transitionOptions() {\n          return { animation: this.animation };\n        } },\n\n\n      events: {\n        beforeitemshow(_ref2) {let { target } = _ref2;\n          addClass(target, this.clsActive);\n        },\n\n        itemshown(_ref3) {let { target } = _ref3;\n          addClass(target, this.clsActivated);\n        },\n\n        itemhidden(_ref4) {let { target } = _ref4;\n          removeClass(target, this.clsActive, this.clsActivated);\n        } } };\n\n    var LightboxPanel = {\n      mixins: [Container, Modal, Togglable, Slideshow],\n\n      functional: true,\n\n      props: {\n        delayControls: Number,\n        preload: Number,\n        videoAutoplay: Boolean,\n        template: String },\n\n\n      data: () => ({\n        preload: 1,\n        videoAutoplay: false,\n        delayControls: 3000,\n        items: [],\n        cls: 'uk-open',\n        clsPage: 'uk-lightbox-page',\n        selList: '.uk-lightbox-items',\n        attrItem: 'uk-lightbox-item',\n        selClose: '.uk-close-large',\n        selCaption: '.uk-lightbox-caption',\n        pauseOnHover: false,\n        velocity: 2,\n        Animations: Animations$1,\n        template: \"<div class=\\\"uk-lightbox uk-overflow-hidden\\\"> <ul class=\\\"uk-lightbox-items\\\"></ul> <div class=\\\"uk-lightbox-toolbar uk-position-top uk-text-right uk-transition-slide-top uk-transition-opaque\\\"> <button class=\\\"uk-lightbox-toolbar-icon uk-close-large\\\" type=\\\"button\\\" uk-close></button> </div> <a class=\\\"uk-lightbox-button uk-position-center-left uk-position-medium uk-transition-fade\\\" href uk-slidenav-previous uk-lightbox-item=\\\"previous\\\"></a> <a class=\\\"uk-lightbox-button uk-position-center-right uk-position-medium uk-transition-fade\\\" href uk-slidenav-next uk-lightbox-item=\\\"next\\\"></a> <div class=\\\"uk-lightbox-toolbar uk-lightbox-caption uk-position-bottom uk-text-center uk-transition-slide-bottom uk-transition-opaque\\\"></div> </div>\" }),\n\n\n\n\n\n\n\n\n\n\n      created() {\n        const $el = $(this.template);\n        const list = $(this.selList, $el);\n        this.items.forEach(() => append(list, '<li>'));\n\n        this.$mount(append(this.container, $el));\n      },\n\n      computed: {\n        caption(_ref, $el) {let { selCaption } = _ref;\n          return $(selCaption, $el);\n        } },\n\n\n      events: [\n      {\n        name: pointerMove$1 + \" \" + pointerDown$1 + \" keydown\",\n\n        handler: 'showControls' },\n\n\n      {\n        name: 'click',\n\n        self: true,\n\n        delegate() {\n          return this.selSlides;\n        },\n\n        handler(e) {\n          if (e.defaultPrevented) {\n            return;\n          }\n\n          this.hide();\n        } },\n\n\n      {\n        name: 'shown',\n\n        self: true,\n\n        handler() {\n          this.showControls();\n        } },\n\n\n      {\n        name: 'hide',\n\n        self: true,\n\n        handler() {\n          this.hideControls();\n\n          removeClass(this.slides, this.clsActive);\n          Transition.stop(this.slides);\n        } },\n\n\n      {\n        name: 'hidden',\n\n        self: true,\n\n        handler() {\n          this.$destroy(true);\n        } },\n\n\n      {\n        name: 'keyup',\n\n        el() {\n          return document;\n        },\n\n        handler(e) {\n          if (!this.isToggled(this.$el) || !this.draggable) {\n            return;\n          }\n\n          switch (e.keyCode) {\n            case 37:\n              this.show('previous');\n              break;\n            case 39:\n              this.show('next');\n              break;}\n\n        } },\n\n\n      {\n        name: 'beforeitemshow',\n\n        handler(e) {\n          if (this.isToggled()) {\n            return;\n          }\n\n          this.draggable = false;\n\n          e.preventDefault();\n\n          this.toggleElement(this.$el, true, false);\n\n          this.animation = Animations$1['scale'];\n          removeClass(e.target, this.clsActive);\n          this.stack.splice(1, 0, this.index);\n        } },\n\n\n      {\n        name: 'itemshow',\n\n        handler() {\n          html(this.caption, this.getItem().caption || '');\n\n          for (let j = -this.preload; j <= this.preload; j++) {\n            this.loadItem(this.index + j);\n          }\n        } },\n\n\n      {\n        name: 'itemshown',\n\n        handler() {\n          this.draggable = this.$props.draggable;\n        } },\n\n\n      {\n        name: 'itemload',\n\n        async handler(_, item) {\n          const { source: src, type, alt = '', poster, attrs = {} } = item;\n\n          this.setItem(item, '<span uk-spinner></span>');\n\n          if (!src) {\n            return;\n          }\n\n          let matches;\n          const iframeAttrs = {\n            allowfullscreen: '',\n            style: 'max-width: 100%; box-sizing: border-box;',\n            'uk-responsive': '',\n            'uk-video': \"\" + this.videoAutoplay };\n\n\n          // Image\n          if (\n          type === 'image' ||\n          src.match(/\\.(avif|jpe?g|jfif|a?png|gif|svg|webp)($|\\?)/i))\n          {\n            try {\n              const { width, height } = await getImage(src, attrs.srcset, attrs.size);\n              this.setItem(item, createEl('img', { src, width, height, alt, ...attrs }));\n            } catch (e) {\n              this.setError(item);\n            }\n\n            // Video\n          } else if (type === 'video' || src.match(/\\.(mp4|webm|ogv)($|\\?)/i)) {\n            const video = createEl('video', {\n              src,\n              poster,\n              controls: '',\n              playsinline: '',\n              'uk-video': \"\" + this.videoAutoplay,\n              ...attrs });\n\n\n            on(video, 'loadedmetadata', () => {\n              attr(video, { width: video.videoWidth, height: video.videoHeight });\n              this.setItem(item, video);\n            });\n            on(video, 'error', () => this.setError(item));\n\n            // Iframe\n          } else if (type === 'iframe' || src.match(/\\.(html|php)($|\\?)/i)) {\n            this.setItem(\n            item,\n            createEl('iframe', {\n              src,\n              allowfullscreen: '',\n              class: 'uk-lightbox-iframe',\n              ...attrs }));\n\n\n\n            // YouTube\n          } else if (\n          matches = src.match(\n          /\\/\\/(?:.*?youtube(-nocookie)?\\..*?[?&]v=|youtu\\.be\\/)([\\w-]{11})[&?]?(.*)?/))\n\n          {\n            this.setItem(\n            item,\n            createEl('iframe', {\n              src: \"https://www.youtube\" + (matches[1] || '') + \".com/embed/\" + matches[2] + (\n              matches[3] ? \"?\" + matches[3] : ''),\n\n              width: 1920,\n              height: 1080,\n              ...iframeAttrs,\n              ...attrs }));\n\n\n\n            // Vimeo\n          } else if (matches = src.match(/\\/\\/.*?vimeo\\.[a-z]+\\/(\\d+)[&?]?(.*)?/)) {\n            try {\n              const { height, width } = await (\n              await fetch(\"https://vimeo.com/api/oembed.json?maxwidth=1920&url=\" +\n              encodeURI(\n              src),\n\n              {\n                credentials: 'omit' })).\n\n\n              json();\n\n              this.setItem(\n              item,\n              createEl('iframe', {\n                src: \"https://player.vimeo.com/video/\" + matches[1] + (\n                matches[2] ? \"?\" + matches[2] : ''),\n\n                width,\n                height,\n                ...iframeAttrs,\n                ...attrs }));\n\n\n            } catch (e) {\n              this.setError(item);\n            }\n          }\n        } }],\n\n\n\n      methods: {\n        loadItem(index) {if (index === void 0) {index = this.index;}\n          const item = this.getItem(index);\n\n          if (!this.getSlide(item).childElementCount) {\n            trigger(this.$el, 'itemload', [item]);\n          }\n        },\n\n        getItem(index) {if (index === void 0) {index = this.index;}\n          return this.items[getIndex(index, this.slides)];\n        },\n\n        setItem(item, content) {\n          trigger(this.$el, 'itemloaded', [this, html(this.getSlide(item), content)]);\n        },\n\n        getSlide(item) {\n          return this.slides[this.items.indexOf(item)];\n        },\n\n        setError(item) {\n          this.setItem(item, '<span uk-icon=\"icon: bolt; ratio: 2\"></span>');\n        },\n\n        showControls() {\n          clearTimeout(this.controlsTimer);\n          this.controlsTimer = setTimeout(this.hideControls, this.delayControls);\n\n          addClass(this.$el, 'uk-active', 'uk-transition-active');\n        },\n\n        hideControls() {\n          removeClass(this.$el, 'uk-active', 'uk-transition-active');\n        } } };\n\n\n\n    function createEl(tag, attrs) {\n      const el = fragment(\"<\" + tag + \">\");\n      attr(el, attrs);\n      return el;\n    }\n\n    var lightbox = {\n      install: install$1,\n\n      props: { toggle: String },\n\n      data: { toggle: 'a' },\n\n      computed: {\n        toggles: {\n          get(_ref, $el) {let { toggle } = _ref;\n            return $$(toggle, $el);\n          },\n\n          watch() {\n            this.hide();\n          } } },\n\n\n\n      disconnected() {\n        this.hide();\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return this.toggle + \":not(.uk-disabled)\";\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.show(e.current);\n        } }],\n\n\n\n      methods: {\n        show(index) {\n          const items = uniqueBy(this.toggles.map(toItem), 'source');\n\n          if (isElement(index)) {\n            const { source } = toItem(index);\n            index = findIndex(items, (_ref2) => {let { source: src } = _ref2;return source === src;});\n          }\n\n          this.panel = this.panel || this.$create('lightboxPanel', { ...this.$props, items });\n\n          on(this.panel.$el, 'hidden', () => this.panel = false);\n\n          return this.panel.show(index);\n        },\n\n        hide() {var _this$panel;\n          return (_this$panel = this.panel) == null ? void 0 : _this$panel.hide();\n        } } };\n\n\n\n    function install$1(UIkit, Lightbox) {\n      if (!UIkit.lightboxPanel) {\n        UIkit.component('lightboxPanel', LightboxPanel);\n      }\n\n      assign(Lightbox.props, UIkit.component('lightboxPanel').options.props);\n    }\n\n    function toItem(el) {\n      const item = {};\n\n      for (const attr of ['href', 'caption', 'type', 'poster', 'alt', 'attrs']) {\n        item[attr === 'href' ? 'source' : attr] = data(el, attr);\n      }\n\n      item.attrs = parseOptions(item.attrs);\n\n      return item;\n    }\n\n    var notification = {\n      mixins: [Container],\n\n      functional: true,\n\n      args: ['message', 'status'],\n\n      data: {\n        message: '',\n        status: '',\n        timeout: 5000,\n        group: null,\n        pos: 'top-center',\n        clsContainer: 'uk-notification',\n        clsClose: 'uk-notification-close',\n        clsMsg: 'uk-notification-message' },\n\n\n      install,\n\n      computed: {\n        marginProp(_ref) {let { pos } = _ref;\n          return \"margin\" + (startsWith(pos, 'top') ? 'Top' : 'Bottom');\n        },\n\n        startProps() {\n          return { opacity: 0, [this.marginProp]: -this.$el.offsetHeight };\n        } },\n\n\n      created() {\n        const container =\n        $(\".\" + this.clsContainer + \"-\" + this.pos, this.container) ||\n        append(\n        this.container, \"<div class=\\\"\" +\n        this.clsContainer + \" \" + this.clsContainer + \"-\" + this.pos + \"\\\" style=\\\"display: block\\\"></div>\");\n\n\n        this.$mount(\n        append(\n        container, \"<div class=\\\"\" +\n        this.clsMsg + (\n        this.status ? \" \" + this.clsMsg + \"-\" + this.status : '') + \"\\\" role=\\\"alert\\\"> <a href class=\\\"\" +\n\n        this.clsClose + \"\\\" data-uk-close></a> <div>\" +\n        this.message + \"</div> </div>\"));\n\n\n\n      },\n\n      async connected() {\n        const margin = toFloat(css(this.$el, this.marginProp));\n        await Transition.start(css(this.$el, this.startProps), {\n          opacity: 1,\n          [this.marginProp]: margin });\n\n\n        if (this.timeout) {\n          this.timer = setTimeout(this.close, this.timeout);\n        }\n      },\n\n      events: {\n        click(e) {\n          if (closest(e.target, 'a[href=\"#\"],a[href=\"\"]')) {\n            e.preventDefault();\n          }\n          this.close();\n        },\n\n        [pointerEnter]() {\n          if (this.timer) {\n            clearTimeout(this.timer);\n          }\n        },\n\n        [pointerLeave]() {\n          if (this.timeout) {\n            this.timer = setTimeout(this.close, this.timeout);\n          }\n        } },\n\n\n      methods: {\n        async close(immediate) {\n          const removeFn = (el) => {\n            const container = parent(el);\n\n            trigger(el, 'close', [this]);\n            remove$1(el);\n\n            if (!(container != null && container.hasChildNodes())) {\n              remove$1(container);\n            }\n          };\n\n          if (this.timer) {\n            clearTimeout(this.timer);\n          }\n\n          if (!immediate) {\n            await Transition.start(this.$el, this.startProps);\n          }\n\n          removeFn(this.$el);\n        } } };\n\n\n\n    function install(UIkit) {\n      UIkit.notification.closeAll = function (group, immediate) {\n        apply(document.body, (el) => {\n          const notification = UIkit.getComponent(el, 'notification');\n          if (notification && (!group || group === notification.group)) {\n            notification.close(immediate);\n          }\n        });\n      };\n    }\n\n    const props = {\n      x: transformFn,\n      y: transformFn,\n      rotate: transformFn,\n      scale: transformFn,\n      color: colorFn,\n      backgroundColor: colorFn,\n      borderColor: colorFn,\n      blur: filterFn,\n      hue: filterFn,\n      fopacity: filterFn,\n      grayscale: filterFn,\n      invert: filterFn,\n      saturate: filterFn,\n      sepia: filterFn,\n      opacity: cssPropFn,\n      stroke: strokeFn,\n      bgx: backgroundFn,\n      bgy: backgroundFn };\n\n\n    const { keys } = Object;\n\n    var Parallax = {\n      mixins: [Media],\n\n      props: fillObject(keys(props), 'list'),\n\n      data: fillObject(keys(props), undefined),\n\n      computed: {\n        props(properties, $el) {\n          const stops = {};\n          for (const prop in properties) {\n            if (prop in props && !isUndefined(properties[prop])) {\n              stops[prop] = properties[prop].slice();\n            }\n          }\n          const result = {};\n          for (const prop in stops) {\n            result[prop] = props[prop](prop, $el, stops[prop], stops);\n          }\n          return result;\n        } },\n\n\n      events: {\n        load() {\n          this.$emit();\n        } },\n\n\n      methods: {\n        reset() {\n          for (const prop in this.getCss(0)) {\n            css(this.$el, prop, '');\n          }\n        },\n\n        getCss(percent) {\n          const css = { transform: '', filter: '' };\n          for (const prop in this.props) {\n            this.props[prop](css, percent);\n          }\n          return css;\n        } } };\n\n\n\n    function transformFn(prop, el, stops) {\n      let unit = getUnit(stops) || { x: 'px', y: 'px', rotate: 'deg' }[prop] || '';\n      let transformFn;\n\n      if (prop === 'x' || prop === 'y') {\n        prop = \"translate\" + ucfirst(prop);\n        transformFn = (stop) => toFloat(toFloat(stop).toFixed(unit === 'px' ? 0 : 6));\n      } else if (prop === 'scale') {\n        unit = '';\n        transformFn = (stop) =>\n        getUnit([stop]) ? toPx(stop, 'width', el, true) / el.offsetWidth : stop;\n      }\n\n      if (stops.length === 1) {\n        stops.unshift(prop === 'scale' ? 1 : 0);\n      }\n\n      stops = parseStops(stops, transformFn);\n\n      return (css, percent) => {\n        css.transform += \" \" + prop + \"(\" + getValue(stops, percent) + unit + \")\";\n      };\n    }\n\n    function colorFn(prop, el, stops) {\n      if (stops.length === 1) {\n        stops.unshift(getCssValue(el, prop, ''));\n      }\n\n      stops = parseStops(stops, (stop) => parseColor(el, stop));\n\n      return (css, percent) => {\n        const [start, end, p] = getStop(stops, percent);\n        const value = start.\n        map((value, i) => {\n          value += p * (end[i] - value);\n          return i === 3 ? toFloat(value) : parseInt(value, 10);\n        }).\n        join(',');\n        css[prop] = \"rgba(\" + value + \")\";\n      };\n    }\n\n    function parseColor(el, color) {\n      return getCssValue(el, 'color', color).\n      split(/[(),]/g).\n      slice(1, -1).\n      concat(1).\n      slice(0, 4).\n      map(toFloat);\n    }\n\n    function filterFn(prop, el, stops) {\n      if (stops.length === 1) {\n        stops.unshift(0);\n      }\n\n      const unit = getUnit(stops) || { blur: 'px', hue: 'deg' }[prop] || '%';\n      prop = { fopacity: 'opacity', hue: 'hue-rotate' }[prop] || prop;\n      stops = parseStops(stops);\n\n      return (css, percent) => {\n        const value = getValue(stops, percent);\n        css.filter += \" \" + prop + \"(\" + (value + unit) + \")\";\n      };\n    }\n\n    function cssPropFn(prop, el, stops) {\n      if (stops.length === 1) {\n        stops.unshift(getCssValue(el, prop, ''));\n      }\n\n      stops = parseStops(stops);\n\n      return (css, percent) => {\n        css[prop] = getValue(stops, percent);\n      };\n    }\n\n    function strokeFn(prop, el, stops) {\n      if (stops.length === 1) {\n        stops.unshift(0);\n      }\n\n      const unit = getUnit(stops);\n      const length = getMaxPathLength(el);\n      stops = parseStops(stops.reverse(), (stop) => {\n        stop = toFloat(stop);\n        return unit === '%' ? stop * length / 100 : stop;\n      });\n\n      if (!stops.some((_ref) => {let [value] = _ref;return value;})) {\n        return noop;\n      }\n\n      css(el, 'strokeDasharray', length);\n\n      return (css, percent) => {\n        css.strokeDashoffset = getValue(stops, percent);\n      };\n    }\n\n    function backgroundFn(prop, el, stops, props) {\n      if (stops.length === 1) {\n        stops.unshift(0);\n      }\n\n      const attr = prop === 'bgy' ? 'height' : 'width';\n      props[prop] = parseStops(stops, (stop) => toPx(stop, attr, el));\n\n      const bgProps = ['bgx', 'bgy'].filter((prop) => prop in props);\n      if (bgProps.length === 2 && prop === 'bgx') {\n        return noop;\n      }\n\n      if (getCssValue(el, 'backgroundSize', '') === 'cover') {\n        return backgroundCoverFn(prop, el, stops, props);\n      }\n\n      const positions = {};\n      for (const prop of bgProps) {\n        positions[prop] = getBackgroundPos(el, prop);\n      }\n\n      return setBackgroundPosFn(bgProps, positions, props);\n    }\n\n    function backgroundCoverFn(prop, el, stops, props) {\n      const dimImage = getBackgroundImageDimensions(el);\n\n      if (!dimImage.width) {\n        return noop;\n      }\n\n      const dimEl = {\n        width: el.offsetWidth,\n        height: el.offsetHeight };\n\n\n      const bgProps = ['bgx', 'bgy'].filter((prop) => prop in props);\n\n      const positions = {};\n      for (const prop of bgProps) {\n        const values = props[prop].map((_ref2) => {let [value] = _ref2;return value;});\n        const min = Math.min(...values);\n        const max = Math.max(...values);\n        const down = values.indexOf(min) < values.indexOf(max);\n        const diff = max - min;\n\n        positions[prop] = (down ? -diff : 0) - (down ? min : max) + \"px\";\n        dimEl[prop === 'bgy' ? 'height' : 'width'] += diff;\n      }\n\n      const dim = Dimensions.cover(dimImage, dimEl);\n\n      for (const prop of bgProps) {\n        const attr = prop === 'bgy' ? 'height' : 'width';\n        const overflow = dim[attr] - dimEl[attr];\n        positions[prop] = \"max(\" + getBackgroundPos(el, prop) + \",-\" + overflow + \"px) + \" + positions[prop];\n      }\n\n      const fn = setBackgroundPosFn(bgProps, positions, props);\n      return (css, percent) => {\n        fn(css, percent);\n        css.backgroundSize = dim.width + \"px \" + dim.height + \"px\";\n        css.backgroundRepeat = 'no-repeat';\n      };\n    }\n\n    function getBackgroundPos(el, prop) {\n      return getCssValue(el, \"background-position-\" + prop.substr(-1), '');\n    }\n\n    function setBackgroundPosFn(bgProps, positions, props) {\n      return function (css, percent) {\n        for (const prop of bgProps) {\n          const value = getValue(props[prop], percent);\n          css[\"background-position-\" + prop.substr(-1)] = \"calc(\" + positions[prop] + \" + \" + value + \"px)\";\n        }\n      };\n    }\n\n    const dimensions = {};\n    function getBackgroundImageDimensions(el) {\n      const src = css(el, 'backgroundImage').replace(/^none|url\\([\"']?(.+?)[\"']?\\)$/, '$1');\n\n      if (dimensions[src]) {\n        return dimensions[src];\n      }\n\n      const image = new Image();\n      if (src) {\n        image.src = src;\n\n        if (!image.naturalWidth) {\n          image.onload = () => {\n            dimensions[src] = toDimensions(image);\n            trigger(el, createEvent('load', false));\n          };\n          return toDimensions(image);\n        }\n      }\n\n      return dimensions[src] = toDimensions(image);\n    }\n\n    function toDimensions(image) {\n      return {\n        width: image.naturalWidth,\n        height: image.naturalHeight };\n\n    }\n\n    function parseStops(stops, fn) {if (fn === void 0) {fn = toFloat;}\n      const result = [];\n      const { length } = stops;\n      let nullIndex = 0;\n      for (let i = 0; i < length; i++) {\n        let [value, percent] = isString(stops[i]) ? stops[i].trim().split(' ') : [stops[i]];\n        value = fn(value);\n        percent = percent ? toFloat(percent) / 100 : null;\n\n        if (i === 0) {\n          if (percent === null) {\n            percent = 0;\n          } else if (percent) {\n            result.push([value, 0]);\n          }\n        } else if (i === length - 1) {\n          if (percent === null) {\n            percent = 1;\n          } else if (percent !== 1) {\n            result.push([value, percent]);\n            percent = 1;\n          }\n        }\n\n        result.push([value, percent]);\n\n        if (percent === null) {\n          nullIndex++;\n        } else if (nullIndex) {\n          const leftPercent = result[i - nullIndex - 1][1];\n          const p = (percent - leftPercent) / (nullIndex + 1);\n          for (let j = nullIndex; j > 0; j--) {\n            result[i - j][1] = leftPercent + p * (nullIndex - j + 1);\n          }\n\n          nullIndex = 0;\n        }\n      }\n\n      return result;\n    }\n\n    function getStop(stops, percent) {\n      const index = findIndex(stops.slice(1), (_ref3) => {let [, targetPercent] = _ref3;return percent <= targetPercent;}) + 1;\n      return [\n      stops[index - 1][0],\n      stops[index][0],\n      (percent - stops[index - 1][1]) / (stops[index][1] - stops[index - 1][1])];\n\n    }\n\n    function getValue(stops, percent) {\n      const [start, end, p] = getStop(stops, percent);\n      return isNumber(start) ? start + Math.abs(start - end) * p * (start < end ? 1 : -1) : +end;\n    }\n\n    const unitRe = /^-?\\d+(\\S+)/;\n    function getUnit(stops, defaultUnit) {\n      for (const stop of stops) {\n        const match = stop.match == null ? void 0 : stop.match(unitRe);\n        if (match) {\n          return match[1];\n        }\n      }\n      return defaultUnit;\n    }\n\n    function getCssValue(el, prop, value) {\n      const prev = el.style[prop];\n      const val = css(css(el, prop, value), prop);\n      el.style[prop] = prev;\n      return val;\n    }\n\n    function fillObject(keys, value) {\n      return keys.reduce((data, prop) => {\n        data[prop] = value;\n        return data;\n      }, {});\n    }\n\n    var parallax = {\n      mixins: [Parallax, Resize, Scroll],\n\n      props: {\n        target: String,\n        viewport: Number, // Deprecated\n        easing: Number,\n        start: String,\n        end: String },\n\n\n      data: {\n        target: false,\n        viewport: 1,\n        easing: 1,\n        start: 0,\n        end: 0 },\n\n\n      computed: {\n        target(_ref, $el) {let { target } = _ref;\n          return getOffsetElement(target && query(target, $el) || $el);\n        },\n\n        start(_ref2) {let { start } = _ref2;\n          return toPx(start, 'height', this.target, true);\n        },\n\n        end(_ref3) {let { end, viewport } = _ref3;\n          return toPx(\n          end || (viewport = (1 - viewport) * 100) && viewport + \"vh+\" + viewport + \"%\",\n          'height',\n          this.target,\n          true);\n\n        } },\n\n\n      update: {\n        read(_ref4, types) {let { percent } = _ref4;\n          if (!types.has('scroll')) {\n            percent = false;\n          }\n\n          if (!this.matchMedia) {\n            return;\n          }\n\n          const prev = percent;\n          percent = ease(scrolledOver(this.target, this.start, this.end), this.easing);\n\n          return {\n            percent,\n            style: prev === percent ? false : this.getCss(percent) };\n\n        },\n\n        write(_ref5) {let { style } = _ref5;\n          if (!this.matchMedia) {\n            this.reset();\n            return;\n          }\n\n          style && css(this.$el, style);\n        },\n\n        events: ['scroll', 'resize'] } };\n\n\n\n    /*\n     * Inspired by https://gist.github.com/gre/1650294?permalink_comment_id=3477425#gistcomment-3477425\n     *\n     * linear: 0\n     * easeInSine: 0.5\n     * easeOutSine: -0.5\n     * easeInQuad: 1\n     * easeOutQuad: -1\n     * easeInCubic: 2\n     * easeOutCubic: -2\n     * easeInQuart: 3\n     * easeOutQuart: -3\n     * easeInQuint: 4\n     * easeOutQuint: -4\n     */\n    function ease(percent, easing) {\n      return easing >= 0 ? Math.pow(percent, easing + 1) : 1 - Math.pow(1 - percent, 1 - easing);\n    }\n\n    // SVG elements do not inherit from HTMLElement\n    function getOffsetElement(el) {\n      return el ? 'offsetTop' in el ? el : getOffsetElement(parent(el)) : document.documentElement;\n    }\n\n    var SliderReactive = {\n      update: {\n        write() {\n          if (this.stack.length || this.dragging) {\n            return;\n          }\n\n          const index = this.getValidIndex(this.index);\n\n          if (!~this.prevIndex || this.index !== index) {\n            this.show(index);\n          } else {\n            this._translate(1, this.prevIndex, this.index);\n          }\n        },\n\n        events: ['resize'] } };\n\n    var SliderPreload = {\n      mixins: [Lazyload],\n\n      connected() {\n        this.lazyload(this.slides, this.getAdjacentSlides);\n      } };\n\n    function Transitioner (prev, next, dir, _ref) {let { center, easing, list } = _ref;\n      const deferred = new Deferred();\n\n      const from = prev ?\n      getLeft(prev, list, center) :\n      getLeft(next, list, center) + dimensions$1(next).width * dir;\n      const to = next ?\n      getLeft(next, list, center) :\n      from + dimensions$1(prev).width * dir * (isRtl ? -1 : 1);\n\n      return {\n        dir,\n\n        show(duration, percent, linear) {if (percent === void 0) {percent = 0;}\n          const timing = linear ? 'linear' : easing;\n          duration -= Math.round(duration * clamp(percent, -1, 1));\n\n          this.translate(percent);\n\n          percent = prev ? percent : clamp(percent, 0, 1);\n          triggerUpdate(this.getItemIn(), 'itemin', { percent, duration, timing, dir });\n          prev &&\n          triggerUpdate(this.getItemIn(true), 'itemout', {\n            percent: 1 - percent,\n            duration,\n            timing,\n            dir });\n\n\n          Transition.start(\n          list,\n          { transform: translate(-to * (isRtl ? -1 : 1), 'px') },\n          duration,\n          timing).\n          then(deferred.resolve, noop);\n\n          return deferred.promise;\n        },\n\n        cancel() {\n          Transition.cancel(list);\n        },\n\n        reset() {\n          css(list, 'transform', '');\n        },\n\n        forward(duration, percent) {if (percent === void 0) {percent = this.percent();}\n          Transition.cancel(list);\n          return this.show(duration, percent, true);\n        },\n\n        translate(percent) {\n          const distance = this.getDistance() * dir * (isRtl ? -1 : 1);\n\n          css(\n          list,\n          'transform',\n          translate(\n          clamp(\n          -to + (distance - distance * percent),\n          -getWidth(list),\n          dimensions$1(list).width) * (\n          isRtl ? -1 : 1),\n          'px'));\n\n\n\n          const actives = this.getActives();\n          const itemIn = this.getItemIn();\n          const itemOut = this.getItemIn(true);\n\n          percent = prev ? clamp(percent, -1, 1) : 0;\n\n          for (const slide of children(list)) {\n            const isActive = includes(actives, slide);\n            const isIn = slide === itemIn;\n            const isOut = slide === itemOut;\n            const translateIn =\n            isIn ||\n            !isOut && (\n            isActive ||\n            dir * (isRtl ? -1 : 1) === -1 ^\n            getElLeft(slide, list) > getElLeft(prev || next));\n\n            triggerUpdate(slide, \"itemtranslate\" + (translateIn ? 'in' : 'out'), {\n              dir,\n              percent: isOut ? 1 - percent : isIn ? percent : isActive ? 1 : 0 });\n\n          }\n        },\n\n        percent() {\n          return Math.abs(\n          (css(list, 'transform').split(',')[4] * (isRtl ? -1 : 1) + from) / (to - from));\n\n        },\n\n        getDistance() {\n          return Math.abs(to - from);\n        },\n\n        getItemIn(out) {if (out === void 0) {out = false;}\n          let actives = this.getActives();\n          let nextActives = inView(list, getLeft(next || prev, list, center));\n\n          if (out) {\n            const temp = actives;\n            actives = nextActives;\n            nextActives = temp;\n          }\n\n          return nextActives[findIndex(nextActives, (el) => !includes(actives, el))];\n        },\n\n        getActives() {\n          return inView(list, getLeft(prev || next, list, center));\n        } };\n\n    }\n\n    function getLeft(el, list, center) {\n      const left = getElLeft(el, list);\n\n      return center ? left - centerEl(el, list) : Math.min(left, getMax(list));\n    }\n\n    function getMax(list) {\n      return Math.max(0, getWidth(list) - dimensions$1(list).width);\n    }\n\n    function getWidth(list) {\n      return children(list).reduce((right, el) => dimensions$1(el).width + right, 0);\n    }\n\n    function centerEl(el, list) {\n      return dimensions$1(list).width / 2 - dimensions$1(el).width / 2;\n    }\n\n    function getElLeft(el, list) {\n      return (\n        el &&\n        (position(el).left + (isRtl ? dimensions$1(el).width - dimensions$1(list).width : 0)) * (\n        isRtl ? -1 : 1) ||\n        0);\n\n    }\n\n    function inView(list, listLeft) {\n      listLeft -= 1;\n      const listWidth = dimensions$1(list).width;\n      const listRight = listLeft + listWidth + 2;\n\n      return children(list).filter((slide) => {\n        const slideLeft = getElLeft(slide, list);\n        const slideRight = slideLeft + Math.min(dimensions$1(slide).width, listWidth);\n\n        return slideLeft >= listLeft && slideRight <= listRight;\n      });\n    }\n\n    function triggerUpdate(el, type, data) {\n      trigger(el, createEvent(type, false, false, data));\n    }\n\n    var slider = {\n      mixins: [Class, Slider, SliderReactive, SliderPreload],\n\n      props: {\n        center: Boolean,\n        sets: Boolean },\n\n\n      data: {\n        center: false,\n        sets: false,\n        attrItem: 'uk-slider-item',\n        selList: '.uk-slider-items',\n        selNav: '.uk-slider-nav',\n        clsContainer: 'uk-slider-container',\n        Transitioner },\n\n\n      computed: {\n        avgWidth() {\n          return getWidth(this.list) / this.length;\n        },\n\n        finite(_ref) {let { finite } = _ref;\n          return (\n            finite ||\n            Math.ceil(getWidth(this.list)) <\n            Math.trunc(dimensions$1(this.list).width + getMaxElWidth(this.list) + this.center));\n\n        },\n\n        maxIndex() {\n          if (!this.finite || this.center && !this.sets) {\n            return this.length - 1;\n          }\n\n          if (this.center) {\n            return last(this.sets);\n          }\n\n          let lft = 0;\n          const max = getMax(this.list);\n          const index = findIndex(this.slides, (el) => {\n            if (lft >= max) {\n              return true;\n            }\n\n            lft += dimensions$1(el).width;\n          });\n\n          return ~index ? index : this.length - 1;\n        },\n\n        sets(_ref2) {let { sets: enabled } = _ref2;\n          if (!enabled) {\n            return;\n          }\n\n          let left = 0;\n          const sets = [];\n          const width = dimensions$1(this.list).width;\n          for (let i = 0; i < this.slides.length; i++) {\n            const slideWidth = dimensions$1(this.slides[i]).width;\n\n            if (left + slideWidth > width) {\n              left = 0;\n            }\n\n            if (this.center) {\n              if (\n              left < width / 2 &&\n              left + slideWidth + dimensions$1(this.slides[+i + 1]).width / 2 > width / 2)\n              {\n                sets.push(+i);\n                left = width / 2 - slideWidth / 2;\n              }\n            } else if (left === 0) {\n              sets.push(Math.min(+i, this.maxIndex));\n            }\n\n            left += slideWidth;\n          }\n\n          if (sets.length) {\n            return sets;\n          }\n        },\n\n        transitionOptions() {\n          return {\n            center: this.center,\n            list: this.list };\n\n        } },\n\n\n      connected() {\n        toggleClass(this.$el, this.clsContainer, !$(\".\" + this.clsContainer, this.$el));\n      },\n\n      update: {\n        write() {\n          for (const el of this.navItems) {\n            const index = toNumber(data(el, this.attrItem));\n            if (index !== false) {\n              el.hidden =\n              !this.maxIndex ||\n              index > this.maxIndex ||\n              this.sets && !includes(this.sets, index);\n            }\n          }\n\n          if (this.length && !this.dragging && !this.stack.length) {\n            this.reorder();\n            this._translate(1);\n          }\n\n          this.updateActiveClasses();\n        },\n\n        events: ['resize'] },\n\n\n      events: {\n        beforeitemshow(e) {\n          if (\n          !this.dragging &&\n          this.sets &&\n          this.stack.length < 2 &&\n          !includes(this.sets, this.index))\n          {\n            this.index = this.getValidIndex();\n          }\n\n          const diff = Math.abs(\n          this.index -\n          this.prevIndex + (\n          this.dir > 0 && this.index < this.prevIndex ||\n          this.dir < 0 && this.index > this.prevIndex ?\n          (this.maxIndex + 1) * this.dir :\n          0));\n\n\n          if (!this.dragging && diff > 1) {\n            for (let i = 0; i < diff; i++) {\n              this.stack.splice(1, 0, this.dir > 0 ? 'next' : 'previous');\n            }\n\n            e.preventDefault();\n            return;\n          }\n\n          const index =\n          this.dir < 0 || !this.slides[this.prevIndex] ? this.index : this.prevIndex;\n          this.duration =\n          speedUp(this.avgWidth / this.velocity) * (\n          dimensions$1(this.slides[index]).width / this.avgWidth);\n\n          this.reorder();\n        },\n\n        itemshow() {\n          if (~this.prevIndex) {\n            addClass(this._getTransitioner().getItemIn(), this.clsActive);\n          }\n        },\n\n        itemshown() {\n          this.updateActiveClasses();\n        } },\n\n\n      methods: {\n        reorder() {\n          if (this.finite) {\n            css(this.slides, 'order', '');\n            return;\n          }\n\n          const index = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index;\n\n          this.slides.forEach((slide, i) =>\n          css(\n          slide,\n          'order',\n          this.dir > 0 && i < index ? 1 : this.dir < 0 && i >= this.index ? -1 : ''));\n\n\n\n          if (!this.center) {\n            return;\n          }\n\n          const next = this.slides[index];\n          let width = dimensions$1(this.list).width / 2 - dimensions$1(next).width / 2;\n          let j = 0;\n\n          while (width > 0) {\n            const slideIndex = this.getIndex(--j + index, index);\n            const slide = this.slides[slideIndex];\n\n            css(slide, 'order', slideIndex > index ? -2 : -1);\n            width -= dimensions$1(slide).width;\n          }\n        },\n\n        updateActiveClasses() {\n          const actives = this._getTransitioner(this.index).getActives();\n          const activeClasses = [\n          this.clsActive,\n          (!this.sets || includes(this.sets, toFloat(this.index))) && this.clsActivated ||\n          ''];\n\n          for (const slide of this.slides) {\n            toggleClass(slide, activeClasses, includes(actives, slide));\n          }\n        },\n\n        getValidIndex(index, prevIndex) {if (index === void 0) {index = this.index;}if (prevIndex === void 0) {prevIndex = this.prevIndex;}\n          index = this.getIndex(index, prevIndex);\n\n          if (!this.sets) {\n            return index;\n          }\n\n          let prev;\n\n          do {\n            if (includes(this.sets, index)) {\n              return index;\n            }\n\n            prev = index;\n            index = this.getIndex(index + this.dir, prevIndex);\n          } while (index !== prev);\n\n          return index;\n        },\n\n        getAdjacentSlides() {\n          const { width } = dimensions$1(this.list);\n          const left = -width;\n          const right = width * 2;\n          const slideWidth = dimensions$1(this.slides[this.index]).width;\n          const slideLeft = this.center ? width / 2 - slideWidth / 2 : 0;\n          const slides = new Set();\n          for (const i of [-1, 1]) {\n            let currentLeft = slideLeft + (i > 0 ? slideWidth : 0);\n            let j = 0;\n            do {\n              const slide = this.slides[this.getIndex(this.index + i + j++ * i)];\n              currentLeft += dimensions$1(slide).width * i;\n              slides.add(slide);\n            } while (this.slides.length > j && currentLeft > left && currentLeft < right);\n          }\n          return Array.from(slides);\n        } } };\n\n\n\n    function getMaxElWidth(list) {\n      return Math.max(0, ...children(list).map((el) => dimensions$1(el).width));\n    }\n\n    var sliderParallax = {\n      mixins: [Parallax],\n\n      data: {\n        selItem: '!li' },\n\n\n      beforeConnect() {\n        this.item = query(this.selItem, this.$el);\n      },\n\n      disconnected() {\n        this.item = null;\n      },\n\n      events: [\n      {\n        name: 'itemin itemout',\n\n        self: true,\n\n        el() {\n          return this.item;\n        },\n\n        handler(_ref) {let { type, detail: { percent, duration, timing, dir } } = _ref;\n          fastdom.read(() => {\n            const propsFrom = this.getCss(getCurrentPercent(type, dir, percent));\n            const propsTo = this.getCss(isIn(type) ? 0.5 : dir > 0 ? 1 : 0);\n            fastdom.write(() => {\n              css(this.$el, propsFrom);\n              Transition.start(this.$el, propsTo, duration, timing).catch(noop);\n            });\n          });\n        } },\n\n\n      {\n        name: 'transitioncanceled transitionend',\n\n        self: true,\n\n        el() {\n          return this.item;\n        },\n\n        handler() {\n          Transition.cancel(this.$el);\n        } },\n\n\n      {\n        name: 'itemtranslatein itemtranslateout',\n\n        self: true,\n\n        el() {\n          return this.item;\n        },\n\n        handler(_ref2) {let { type, detail: { percent, dir } } = _ref2;\n          fastdom.read(() => {\n            const props = this.getCss(getCurrentPercent(type, dir, percent));\n            fastdom.write(() => css(this.$el, props));\n          });\n        } }] };\n\n\n\n\n    function isIn(type) {\n      return endsWith(type, 'in');\n    }\n\n    function getCurrentPercent(type, dir, percent) {\n      percent /= 2;\n\n      return isIn(type) ^ dir < 0 ? percent : 1 - percent;\n    }\n\n    var Animations = {\n      ...Animations$2,\n      fade: {\n        show() {\n          return [{ opacity: 0, zIndex: 0 }, { zIndex: -1 }];\n        },\n\n        percent(current) {\n          return 1 - css(current, 'opacity');\n        },\n\n        translate(percent) {\n          return [{ opacity: 1 - percent, zIndex: 0 }, { zIndex: -1 }];\n        } },\n\n\n      scale: {\n        show() {\n          return [{ opacity: 0, transform: scale3d(1 + 0.5), zIndex: 0 }, { zIndex: -1 }];\n        },\n\n        percent(current) {\n          return 1 - css(current, 'opacity');\n        },\n\n        translate(percent) {\n          return [\n          { opacity: 1 - percent, transform: scale3d(1 + 0.5 * percent), zIndex: 0 },\n          { zIndex: -1 }];\n\n        } },\n\n\n      pull: {\n        show(dir) {\n          return dir < 0 ?\n          [\n          { transform: translate(30), zIndex: -1 },\n          { transform: translate(), zIndex: 0 }] :\n\n          [\n          { transform: translate(-100), zIndex: 0 },\n          { transform: translate(), zIndex: -1 }];\n\n        },\n\n        percent(current, next, dir) {\n          return dir < 0 ? 1 - translated(next) : translated(current);\n        },\n\n        translate(percent, dir) {\n          return dir < 0 ?\n          [\n          { transform: translate(30 * percent), zIndex: -1 },\n          { transform: translate(-100 * (1 - percent)), zIndex: 0 }] :\n\n          [\n          { transform: translate(-percent * 100), zIndex: 0 },\n          { transform: translate(30 * (1 - percent)), zIndex: -1 }];\n\n        } },\n\n\n      push: {\n        show(dir) {\n          return dir < 0 ?\n          [\n          { transform: translate(100), zIndex: 0 },\n          { transform: translate(), zIndex: -1 }] :\n\n          [\n          { transform: translate(-30), zIndex: -1 },\n          { transform: translate(), zIndex: 0 }];\n\n        },\n\n        percent(current, next, dir) {\n          return dir > 0 ? 1 - translated(next) : translated(current);\n        },\n\n        translate(percent, dir) {\n          return dir < 0 ?\n          [\n          { transform: translate(percent * 100), zIndex: 0 },\n          { transform: translate(-30 * (1 - percent)), zIndex: -1 }] :\n\n          [\n          { transform: translate(-30 * percent), zIndex: -1 },\n          { transform: translate(100 * (1 - percent)), zIndex: 0 }];\n\n        } } };\n\n    var slideshow = {\n      mixins: [Class, Slideshow, SliderReactive, SliderPreload],\n\n      props: {\n        ratio: String,\n        minHeight: Number,\n        maxHeight: Number },\n\n\n      data: {\n        ratio: '16:9',\n        minHeight: false,\n        maxHeight: false,\n        selList: '.uk-slideshow-items',\n        attrItem: 'uk-slideshow-item',\n        selNav: '.uk-slideshow-nav',\n        Animations },\n\n\n      update: {\n        read() {\n          if (!this.list) {\n            return false;\n          }\n\n          let [width, height] = this.ratio.split(':').map(Number);\n\n          height = height * this.list.offsetWidth / width || 0;\n\n          if (this.minHeight) {\n            height = Math.max(this.minHeight, height);\n          }\n\n          if (this.maxHeight) {\n            height = Math.min(this.maxHeight, height);\n          }\n\n          return { height: height - boxModelAdjust(this.list, 'height', 'content-box') };\n        },\n\n        write(_ref) {let { height } = _ref;\n          height > 0 && css(this.list, 'minHeight', height);\n        },\n\n        events: ['resize'] },\n\n\n      methods: {\n        getAdjacentSlides() {\n          return [1, -1].map((i) => this.slides[this.getIndex(this.index + i)]);\n        } } };\n\n    var sortable = {\n      mixins: [Class, Animate],\n\n      props: {\n        group: String,\n        threshold: Number,\n        clsItem: String,\n        clsPlaceholder: String,\n        clsDrag: String,\n        clsDragState: String,\n        clsBase: String,\n        clsNoDrag: String,\n        clsEmpty: String,\n        clsCustom: String,\n        handle: String },\n\n\n      data: {\n        group: false,\n        threshold: 5,\n        clsItem: 'uk-sortable-item',\n        clsPlaceholder: 'uk-sortable-placeholder',\n        clsDrag: 'uk-sortable-drag',\n        clsDragState: 'uk-drag',\n        clsBase: 'uk-sortable',\n        clsNoDrag: 'uk-sortable-nodrag',\n        clsEmpty: 'uk-sortable-empty',\n        clsCustom: '',\n        handle: false,\n        pos: {} },\n\n\n      created() {\n        for (const key of ['init', 'start', 'move', 'end']) {\n          const fn = this[key];\n          this[key] = (e) => {\n            assign(this.pos, getEventPos(e));\n            fn(e);\n          };\n        }\n      },\n\n      events: {\n        name: pointerDown$1,\n        passive: false,\n        handler: 'init' },\n\n\n      computed: {\n        target() {\n          return (this.$el.tBodies || [this.$el])[0];\n        },\n\n        items() {\n          return children(this.target);\n        },\n\n        isEmpty: {\n          get() {\n            return isEmpty(this.items);\n          },\n\n          watch(empty) {\n            toggleClass(this.target, this.clsEmpty, empty);\n          },\n\n          immediate: true },\n\n\n        handles: {\n          get(_ref, el) {let { handle } = _ref;\n            return handle ? $$(handle, el) : this.items;\n          },\n\n          watch(handles, prev) {\n            css(prev, { touchAction: '', userSelect: '' });\n            css(handles, { touchAction: hasTouch ? 'none' : '', userSelect: 'none' }); // touchAction set to 'none' causes a performance drop in Chrome 80\n          },\n\n          immediate: true } },\n\n\n\n      update: {\n        write(data) {\n          if (!this.drag || !parent(this.placeholder)) {\n            return;\n          }\n\n          const {\n            pos: { x, y },\n            origin: { offsetTop, offsetLeft },\n            placeholder } =\n          this;\n\n          css(this.drag, {\n            top: y - offsetTop,\n            left: x - offsetLeft });\n\n\n          const sortable = this.getSortable(document.elementFromPoint(x, y));\n\n          if (!sortable) {\n            return;\n          }\n\n          const { items } = sortable;\n\n          if (items.some(Transition.inProgress)) {\n            return;\n          }\n\n          const target = findTarget(items, { x, y });\n\n          if (items.length && (!target || target === placeholder)) {\n            return;\n          }\n\n          const previous = this.getSortable(placeholder);\n          const insertTarget = findInsertTarget(\n          sortable.target,\n          target,\n          placeholder,\n          x,\n          y,\n          sortable === previous && data.moved !== target);\n\n\n          if (insertTarget === false) {\n            return;\n          }\n\n          if (insertTarget && placeholder === insertTarget) {\n            return;\n          }\n\n          if (sortable !== previous) {\n            previous.remove(placeholder);\n            data.moved = target;\n          } else {\n            delete data.moved;\n          }\n\n          sortable.insert(placeholder, insertTarget);\n\n          this.touched.add(sortable);\n        },\n\n        events: ['move'] },\n\n\n      methods: {\n        init(e) {\n          const { target, button, defaultPrevented } = e;\n          const [placeholder] = this.items.filter((el) => within(target, el));\n\n          if (\n          !placeholder ||\n          defaultPrevented ||\n          button > 0 ||\n          isInput(target) ||\n          within(target, \".\" + this.clsNoDrag) ||\n          this.handle && !within(target, this.handle))\n          {\n            return;\n          }\n\n          e.preventDefault();\n\n          this.touched = new Set([this]);\n          this.placeholder = placeholder;\n          this.origin = { target, index: index(placeholder), ...this.pos };\n\n          on(document, pointerMove$1, this.move);\n          on(document, pointerUp$1, this.end);\n\n          if (!this.threshold) {\n            this.start(e);\n          }\n        },\n\n        start(e) {\n          this.drag = appendDrag(this.$container, this.placeholder);\n          const { left, top } = this.placeholder.getBoundingClientRect();\n          assign(this.origin, { offsetLeft: this.pos.x - left, offsetTop: this.pos.y - top });\n\n          addClass(this.drag, this.clsDrag, this.clsCustom);\n          addClass(this.placeholder, this.clsPlaceholder);\n          addClass(this.items, this.clsItem);\n          addClass(document.documentElement, this.clsDragState);\n\n          trigger(this.$el, 'start', [this, this.placeholder]);\n\n          trackScroll(this.pos);\n\n          this.move(e);\n        },\n\n        move(e) {\n          if (this.drag) {\n            this.$emit('move');\n          } else if (\n          Math.abs(this.pos.x - this.origin.x) > this.threshold ||\n          Math.abs(this.pos.y - this.origin.y) > this.threshold)\n          {\n            this.start(e);\n          }\n        },\n\n        end() {\n          off(document, pointerMove$1, this.move);\n          off(document, pointerUp$1, this.end);\n\n          if (!this.drag) {\n            return;\n          }\n\n          untrackScroll();\n\n          const sortable = this.getSortable(this.placeholder);\n\n          if (this === sortable) {\n            if (this.origin.index !== index(this.placeholder)) {\n              trigger(this.$el, 'moved', [this, this.placeholder]);\n            }\n          } else {\n            trigger(sortable.$el, 'added', [sortable, this.placeholder]);\n            trigger(this.$el, 'removed', [this, this.placeholder]);\n          }\n\n          trigger(this.$el, 'stop', [this, this.placeholder]);\n\n          remove$1(this.drag);\n          this.drag = null;\n\n          for (const { clsPlaceholder, clsItem } of this.touched) {\n            for (const sortable of this.touched) {\n              removeClass(sortable.items, clsPlaceholder, clsItem);\n            }\n          }\n          this.touched = null;\n          removeClass(document.documentElement, this.clsDragState);\n        },\n\n        insert(element, target) {\n          addClass(this.items, this.clsItem);\n\n          const insert = () => target ? before(target, element) : append(this.target, element);\n\n          this.animate(insert);\n        },\n\n        remove(element) {\n          if (!within(element, this.target)) {\n            return;\n          }\n\n          this.animate(() => remove$1(element));\n        },\n\n        getSortable(element) {\n          do {\n            const sortable = this.$getComponent(element, 'sortable');\n\n            if (\n            sortable && (\n            sortable === this || this.group !== false && sortable.group === this.group))\n            {\n              return sortable;\n            }\n          } while (element = parent(element));\n        } } };\n\n\n\n    let trackTimer;\n    function trackScroll(pos) {\n      let last = Date.now();\n      trackTimer = setInterval(() => {\n        let { x, y } = pos;\n        y += document.scrollingElement.scrollTop;\n\n        const dist = (Date.now() - last) * 0.3;\n        last = Date.now();\n\n        scrollParents(document.elementFromPoint(x, pos.y), /auto|scroll/).\n        reverse().\n        some((scrollEl) => {\n          let { scrollTop: scroll, scrollHeight } = scrollEl;\n\n          const { top, bottom, height } = offsetViewport(scrollEl);\n\n          if (top < y && top + 35 > y) {\n            scroll -= dist;\n          } else if (bottom > y && bottom - 35 < y) {\n            scroll += dist;\n          } else {\n            return;\n          }\n\n          if (scroll > 0 && scroll < scrollHeight - height) {\n            scrollEl.scrollTop = scroll;\n            return true;\n          }\n        });\n      }, 15);\n    }\n\n    function untrackScroll() {\n      clearInterval(trackTimer);\n    }\n\n    function appendDrag(container, element) {\n      let clone;\n      if (['li', 'tr'].some((tag) => isTag(element, tag))) {\n        clone = $('<div>');\n        append(clone, element.cloneNode(true).children);\n        for (const attribute of element.getAttributeNames()) {\n          attr(clone, attribute, element.getAttribute(attribute));\n        }\n      } else {\n        clone = element.cloneNode(true);\n      }\n\n      append(container, clone);\n\n      css(clone, 'margin', '0', 'important');\n      css(clone, {\n        boxSizing: 'border-box',\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        padding: css(element, 'padding') });\n\n\n      height(clone.firstElementChild, height(element.firstElementChild));\n\n      return clone;\n    }\n\n    function findTarget(items, point) {\n      return items[findIndex(items, (item) => pointInRect(point, item.getBoundingClientRect()))];\n    }\n\n    function findInsertTarget(list, target, placeholder, x, y, sameList) {\n      if (!children(list).length) {\n        return;\n      }\n\n      const rect = target.getBoundingClientRect();\n      if (!sameList) {\n        if (!isHorizontal(list, placeholder)) {\n          return y < rect.top + rect.height / 2 ? target : target.nextElementSibling;\n        }\n\n        return target;\n      }\n\n      const placeholderRect = placeholder.getBoundingClientRect();\n      const sameRow = linesIntersect(\n      [rect.top, rect.bottom],\n      [placeholderRect.top, placeholderRect.bottom]);\n\n\n      const pointerPos = sameRow ? x : y;\n      const lengthProp = sameRow ? 'width' : 'height';\n      const startProp = sameRow ? 'left' : 'top';\n      const endProp = sameRow ? 'right' : 'bottom';\n\n      const diff =\n      placeholderRect[lengthProp] < rect[lengthProp] ?\n      rect[lengthProp] - placeholderRect[lengthProp] :\n      0;\n\n      if (placeholderRect[startProp] < rect[startProp]) {\n        if (diff && pointerPos < rect[startProp] + diff) {\n          return false;\n        }\n\n        return target.nextElementSibling;\n      }\n\n      if (diff && pointerPos > rect[endProp] - diff) {\n        return false;\n      }\n\n      return target;\n    }\n\n    function isHorizontal(list, placeholder) {\n      const single = children(list).length === 1;\n\n      if (single) {\n        append(list, placeholder);\n      }\n\n      const items = children(list);\n      const isHorizontal = items.some((el, i) => {\n        const rectA = el.getBoundingClientRect();\n        return items.slice(i + 1).some((el) => {\n          const rectB = el.getBoundingClientRect();\n          return !linesIntersect([rectA.left, rectA.right], [rectB.left, rectB.right]);\n        });\n      });\n\n      if (single) {\n        remove$1(placeholder);\n      }\n\n      return isHorizontal;\n    }\n\n    function linesIntersect(lineA, lineB) {\n      return lineA[1] > lineB[0] && lineB[1] > lineA[0];\n    }\n\n    var tooltip = {\n      mixins: [Container, Togglable, Position],\n\n      args: 'title',\n\n      props: {\n        delay: Number,\n        title: String },\n\n\n      data: {\n        pos: 'top',\n        title: '',\n        delay: 0,\n        animation: ['uk-animation-scale-up'],\n        duration: 100,\n        cls: 'uk-active' },\n\n\n      beforeConnect() {\n        this.id = \"uk-tooltip-\" + this._uid;\n        this._hasTitle = hasAttr(this.$el, 'title');\n        attr(this.$el, {\n          title: '',\n          'aria-describedby': this.id });\n\n        makeFocusable(this.$el);\n      },\n\n      disconnected() {\n        this.hide();\n        attr(this.$el, 'title', this._hasTitle ? this.title : null);\n      },\n\n      methods: {\n        show() {\n          if (this.isToggled(this.tooltip || null) || !this.title) {\n            return;\n          }\n\n          this._unbind = once(\n          document, \"keydown \" +\n          pointerDown$1,\n          this.hide,\n          false,\n          (e) =>\n          e.type === pointerDown$1 && !within(e.target, this.$el) ||\n          e.type === 'keydown' && e.keyCode === 27);\n\n\n          clearTimeout(this.showTimer);\n          this.showTimer = setTimeout(this._show, this.delay);\n        },\n\n        async hide() {\n          if (matches(this.$el, 'input:focus')) {\n            return;\n          }\n\n          clearTimeout(this.showTimer);\n\n          if (!this.isToggled(this.tooltip || null)) {\n            return;\n          }\n\n          await this.toggleElement(this.tooltip, false, false);\n          remove$1(this.tooltip);\n          this.tooltip = null;\n          this._unbind();\n        },\n\n        _show() {\n          this.tooltip = append(\n          this.container, \"<div id=\\\"\" +\n          this.id + \"\\\" class=\\\"uk-\" + this.$options.name + \"\\\" role=\\\"tooltip\\\"> <div class=\\\"uk-\" +\n          this.$options.name + \"-inner\\\">\" + this.title + \"</div> </div>\");\n\n\n\n          on(this.tooltip, 'toggled', (e, toggled) => {\n            if (!toggled) {\n              return;\n            }\n\n            this.positionAt(this.tooltip, this.$el);\n\n            const [dir, align] = getAlignment(this.tooltip, this.$el, this.pos);\n\n            this.origin =\n            this.axis === 'y' ?\n            flipPosition(dir) + \"-\" + align :\n            align + \"-\" + flipPosition(dir);\n          });\n\n          this.toggleElement(this.tooltip, true);\n        } },\n\n\n      events: {\n        focus: 'show',\n        blur: 'hide',\n\n        [pointerEnter + \" \" + pointerLeave](e) {\n          if (!isTouch(e)) {\n            this[e.type === pointerEnter ? 'show' : 'hide']();\n          }\n        },\n\n        // Clicking a button does not give it focus on all browsers and platforms\n        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus\n        [pointerDown$1](e) {\n          if (isTouch(e)) {\n            this.show();\n          }\n        } } };\n\n\n\n    function makeFocusable(el) {\n      if (!isFocusable(el)) {\n        attr(el, 'tabindex', '0');\n      }\n    }\n\n    function getAlignment(el, target, _ref) {let [dir, align] = _ref;\n      const elOffset = offset(el);\n      const targetOffset = offset(target);\n      const properties = [\n      ['left', 'right'],\n      ['top', 'bottom']];\n\n\n      for (const props of properties) {\n        if (elOffset[props[0]] >= targetOffset[props[1]]) {\n          dir = props[1];\n          break;\n        }\n        if (elOffset[props[1]] <= targetOffset[props[0]]) {\n          dir = props[0];\n          break;\n        }\n      }\n\n      const props = includes(properties[0], dir) ? properties[1] : properties[0];\n      if (elOffset[props[0]] === targetOffset[props[0]]) {\n        align = props[0];\n      } else if (elOffset[props[1]] === targetOffset[props[1]]) {\n        align = props[1];\n      } else {\n        align = 'center';\n      }\n\n      return [dir, align];\n    }\n\n    var upload = {\n      props: {\n        allow: String,\n        clsDragover: String,\n        concurrent: Number,\n        maxSize: Number,\n        method: String,\n        mime: String,\n        msgInvalidMime: String,\n        msgInvalidName: String,\n        msgInvalidSize: String,\n        multiple: Boolean,\n        name: String,\n        params: Object,\n        type: String,\n        url: String },\n\n\n      data: {\n        allow: false,\n        clsDragover: 'uk-dragover',\n        concurrent: 1,\n        maxSize: 0,\n        method: 'POST',\n        mime: false,\n        msgInvalidMime: 'Invalid File Type: %s',\n        msgInvalidName: 'Invalid File Name: %s',\n        msgInvalidSize: 'Invalid File Size: %s Kilobytes Max',\n        multiple: false,\n        name: 'files[]',\n        params: {},\n        type: '',\n        url: '',\n        abort: noop,\n        beforeAll: noop,\n        beforeSend: noop,\n        complete: noop,\n        completeAll: noop,\n        error: noop,\n        fail: noop,\n        load: noop,\n        loadEnd: noop,\n        loadStart: noop,\n        progress: noop },\n\n\n      events: {\n        change(e) {\n          if (!matches(e.target, 'input[type=\"file\"]')) {\n            return;\n          }\n\n          e.preventDefault();\n\n          if (e.target.files) {\n            this.upload(e.target.files);\n          }\n\n          e.target.value = '';\n        },\n\n        drop(e) {\n          stop(e);\n\n          const transfer = e.dataTransfer;\n\n          if (!(transfer != null && transfer.files)) {\n            return;\n          }\n\n          removeClass(this.$el, this.clsDragover);\n\n          this.upload(transfer.files);\n        },\n\n        dragenter(e) {\n          stop(e);\n        },\n\n        dragover(e) {\n          stop(e);\n          addClass(this.$el, this.clsDragover);\n        },\n\n        dragleave(e) {\n          stop(e);\n          removeClass(this.$el, this.clsDragover);\n        } },\n\n\n      methods: {\n        async upload(files) {\n          files = toArray(files);\n\n          if (!files.length) {\n            return;\n          }\n\n          trigger(this.$el, 'upload', [files]);\n\n          for (const file of files) {\n            if (this.maxSize && this.maxSize * 1000 < file.size) {\n              this.fail(this.msgInvalidSize.replace('%s', this.maxSize));\n              return;\n            }\n\n            if (this.allow && !match(this.allow, file.name)) {\n              this.fail(this.msgInvalidName.replace('%s', this.allow));\n              return;\n            }\n\n            if (this.mime && !match(this.mime, file.type)) {\n              this.fail(this.msgInvalidMime.replace('%s', this.mime));\n              return;\n            }\n          }\n\n          if (!this.multiple) {\n            files = files.slice(0, 1);\n          }\n\n          this.beforeAll(this, files);\n\n          const chunks = chunk(files, this.concurrent);\n          const upload = async (files) => {\n            const data = new FormData();\n\n            files.forEach((file) => data.append(this.name, file));\n\n            for (const key in this.params) {\n              data.append(key, this.params[key]);\n            }\n\n            try {\n              const xhr = await ajax(this.url, {\n                data,\n                method: this.method,\n                responseType: this.type,\n                beforeSend: (env) => {\n                  const { xhr } = env;\n                  xhr.upload && on(xhr.upload, 'progress', this.progress);\n                  for (const type of ['loadStart', 'load', 'loadEnd', 'abort']) {\n                    on(xhr, type.toLowerCase(), this[type]);\n                  }\n\n                  return this.beforeSend(env);\n                } });\n\n\n              this.complete(xhr);\n\n              if (chunks.length) {\n                await upload(chunks.shift());\n              } else {\n                this.completeAll(xhr);\n              }\n            } catch (e) {\n              this.error(e);\n            }\n          };\n\n          await upload(chunks.shift());\n        } } };\n\n\n\n    function match(pattern, path) {\n      return path.match(\n      new RegExp(\"^\" +\n      pattern.\n      replace(/\\//g, '\\\\/').\n      replace(/\\*\\*/g, '(\\\\/[^\\\\/]+)*').\n      replace(/\\*/g, '[^\\\\/]+').\n      replace(/((?!\\\\))\\?/g, '$1.') + \"$\",\n      'i'));\n\n\n    }\n\n    function chunk(files, size) {\n      const chunks = [];\n      for (let i = 0; i < files.length; i += size) {\n        chunks.push(files.slice(i, i + size));\n      }\n      return chunks;\n    }\n\n    function stop(e) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    var components = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        Countdown: countdown,\n        Filter: filter,\n        Lightbox: lightbox,\n        LightboxPanel: LightboxPanel,\n        Notification: notification,\n        Parallax: parallax,\n        Slider: slider,\n        SliderParallax: sliderParallax,\n        Slideshow: slideshow,\n        SlideshowParallax: sliderParallax,\n        Sortable: sortable,\n        Tooltip: tooltip,\n        Upload: upload\n    });\n\n    each(components, (component, name) => UIkit.component(name, component));\n\n    return UIkit;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvZGlzdC9qcy91aWtpdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLElBQUksS0FBNEQ7QUFDaEUsSUFBSSxDQUNvRztBQUN4RyxDQUFDLHVCQUF1Qjs7QUFFeEIsWUFBWSwyQkFBMkI7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVkseUJBQXlCO0FBQ3JDLFlBQVksU0FBUzs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNLG9CQUFvQixPQUFPLE1BQU0sb0JBQW9CLFFBQVE7QUFDaEcsdURB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QWMsSUFBSSxjQUFjO0FBQzVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjs7QUFFQSxzRUFBc0UsOEJBQThCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELHlCQUF5QixZQUFZO0FBQ3ZGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaUJBQWlCO0FBQ3ZFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsNEJBQTRCO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVULHdCQUF3QixNQUFNLGVBQWU7QUFDN0M7QUFDQSxXQUFXOzs7QUFHWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7OztBQUlYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7OztBQUc1QjtBQUNBO0FBQ0EsNENBQTRDOzs7QUFHNUM7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNa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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOzs7QUFHckM7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsWUFBWSxPQUFPOztBQUVuQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0EscUNBQXFDLGlDQUFpQztBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNB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QUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qjs7O0FBR3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOzs7QUFHdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxzQkFBc0IsTUFBTSxTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSxTQUFTOztBQUVULHFCQUFxQixNQUFNLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOzs7QUFHWDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVCw0QkFBNEI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91aWtpdC9kaXN0L2pzL3Vpa2l0LmpzPzJmNDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIFVJa2l0IDMuMTUuMTAgfCBodHRwczovL3d3dy5nZXR1aWtpdC5jb20gfCAoYykgMjAxNCAtIDIwMjIgWU9PdGhlbWUgfCBNSVQgTGljZW5zZSAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ3Vpa2l0JywgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5VSWtpdCA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCB7IGhhc093blByb3BlcnR5LCB0b1N0cmluZyB9ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IGh5cGhlbmF0ZVJlID0gL1xcQihbQS1aXSkvZztcblxuICAgIGNvbnN0IGh5cGhlbmF0ZSA9IG1lbW9pemUoKHN0cikgPT4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUmUsICctJDEnKS50b0xvd2VyQ2FzZSgpKTtcblxuICAgIGNvbnN0IGNhbWVsaXplUmUgPSAvLShcXHcpL2c7XG5cbiAgICBjb25zdCBjYW1lbGl6ZSA9IG1lbW9pemUoKHN0cikgPT4gc3RyLnJlcGxhY2UoY2FtZWxpemVSZSwgdG9VcHBlcikpO1xuXG4gICAgY29uc3QgdWNmaXJzdCA9IG1lbW9pemUoKHN0cikgPT5cbiAgICBzdHIubGVuZ3RoID8gdG9VcHBlcihudWxsLCBzdHIuY2hhckF0KDApKSArIHN0ci5zbGljZSgxKSA6ICcnKTtcblxuXG4gICAgZnVuY3Rpb24gdG9VcHBlcihfLCBjKSB7XG4gICAgICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gpIHtcbiAgICAgIHJldHVybiBzdHIgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ci5zdGFydHNXaXRoID09IG51bGwgPyB2b2lkIDAgOiBzdHIuc3RhcnRzV2l0aChzZWFyY2gpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoKSB7XG4gICAgICByZXR1cm4gc3RyID09IG51bGwgPyB2b2lkIDAgOiBzdHIuZW5kc1dpdGggPT0gbnVsbCA/IHZvaWQgMCA6IHN0ci5lbmRzV2l0aChzZWFyY2gpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluY2x1ZGVzKG9iaiwgc2VhcmNoKSB7XG4gICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmouaW5jbHVkZXMgPT0gbnVsbCA/IHZvaWQgMCA6IG9iai5pbmNsdWRlcyhzZWFyY2gpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/IHZvaWQgMCA6IGFycmF5LmZpbmRJbmRleCA9PSBudWxsID8gdm9pZCAwIDogYXJyYXkuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBpc0FycmF5LCBmcm9tOiB0b0FycmF5IH0gPSBBcnJheTtcbiAgICBjb25zdCB7IGFzc2lnbiB9ID0gT2JqZWN0O1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3Qob2JqKSAmJiBvYmogPT09IG9iai53aW5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEb2N1bWVudChvYmopIHtcbiAgICAgIHJldHVybiBub2RlVHlwZShvYmopID09PSA5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTm9kZShvYmopIHtcbiAgICAgIHJldHVybiBub2RlVHlwZShvYmopID49IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KG9iaikge1xuICAgICAgcmV0dXJuIG5vZGVUeXBlKG9iaikgPT09IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9kZVR5cGUob2JqKSB7XG4gICAgICByZXR1cm4gIWlzV2luZG93KG9iaikgJiYgaXNPYmplY3Qob2JqKSAmJiBvYmoubm9kZVR5cGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWVyaWModmFsdWUpIHtcbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgfHwgaXNTdHJpbmcodmFsdWUpICYmICFpc05hTih2YWx1ZSAtIHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgICAgcmV0dXJuICEoaXNBcnJheShvYmopID8gb2JqLmxlbmd0aCA6IGlzT2JqZWN0KG9iaikgPyBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA6IGZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Cb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNCb29sZWFuKHZhbHVlKSA/XG4gICAgICB2YWx1ZSA6XG4gICAgICB2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnMScgfHwgdmFsdWUgPT09ICcnID9cbiAgICAgIHRydWUgOlxuICAgICAgdmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICcwJyA/XG4gICAgICBmYWxzZSA6XG4gICAgICB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgICAgY29uc3QgbnVtYmVyID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgIHJldHVybiBpc05hTihudW1iZXIpID8gZmFsc2UgOiBudW1iZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9GbG9hdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob2RlKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpWzBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm9kZXMoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQgJiYgKGlzTm9kZShlbGVtZW50KSA/IFtlbGVtZW50XSA6IEFycmF5LmZyb20oZWxlbWVudCkuZmlsdGVyKGlzTm9kZSkpIHx8IFtdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvV2luZG93KGVsZW1lbnQpIHt2YXIgX2VsZW1lbnQ7XG4gICAgICBpZiAoaXNXaW5kb3coZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQgPSB0b05vZGUoZWxlbWVudCk7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGlzRG9jdW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogKF9lbGVtZW50ID0gZWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgIHJldHVybiAoZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZhbHVlID09PSBvdGhlciB8fFxuICAgICAgICBpc09iamVjdCh2YWx1ZSkgJiZcbiAgICAgICAgaXNPYmplY3Qob3RoZXIpICYmXG4gICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IE9iamVjdC5rZXlzKG90aGVyKS5sZW5ndGggJiZcbiAgICAgICAgZWFjaCh2YWx1ZSwgKHZhbCwga2V5KSA9PiB2YWwgPT09IG90aGVyW2tleV0pKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN3YXAodmFsdWUsIGEsIGIpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAoYSArIFwifFwiICsgYiwgJ2cnKSwgKG1hdGNoKSA9PiBtYXRjaCA9PT0gYSA/IGIgOiBhKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWFjaChvYmosIGNiKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGZhbHNlID09PSBjYihvYmpba2V5XSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydEJ5JDEoYXJyYXksIHByb3ApIHtcbiAgICAgIHJldHVybiBhcnJheS5cbiAgICAgIHNsaWNlKCkuXG4gICAgICBzb3J0KChfcmVmLCBfcmVmMikgPT4ge2xldCB7IFtwcm9wXTogcHJvcEEgPSAwIH0gPSBfcmVmO2xldCB7IFtwcm9wXTogcHJvcEIgPSAwIH0gPSBfcmVmMjtyZXR1cm4gKFxuICAgICAgICAgIHByb3BBID4gcHJvcEIgPyAxIDogcHJvcEIgPiBwcm9wQSA/IC0xIDogMCk7fSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmlxdWVCeShhcnJheSwgcHJvcCkge1xuICAgICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICAgIHJldHVybiBhcnJheS5maWx0ZXIoKF9yZWYzKSA9PiB7bGV0IHsgW3Byb3BdOiBjaGVjayB9ID0gX3JlZjM7cmV0dXJuIHNlZW4uaGFzKGNoZWNrKSA/IGZhbHNlIDogc2Vlbi5hZGQoY2hlY2spO30pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbWluLCBtYXgpIHtpZiAobWluID09PSB2b2lkIDApIHttaW4gPSAwO31pZiAobWF4ID09PSB2b2lkIDApIHttYXggPSAxO31cbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh0b051bWJlcihudW1iZXIpIHx8IDAsIG1pbiksIG1heCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3RSZWN0KCkge2ZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZWN0cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtyZWN0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTt9XG4gICAgICByZXR1cm4gW1xuICAgICAgWydib3R0b20nLCAndG9wJ10sXG4gICAgICBbJ3JpZ2h0JywgJ2xlZnQnXV0uXG4gICAgICBldmVyeShcbiAgICAgIChfcmVmNCkgPT4ge2xldCBbbWluUHJvcCwgbWF4UHJvcF0gPSBfcmVmNDtyZXR1cm4gKFxuICAgICAgICAgIE1hdGgubWluKC4uLnJlY3RzLm1hcCgoX3JlZjUpID0+IHtsZXQgeyBbbWluUHJvcF06IG1pbiB9ID0gX3JlZjU7cmV0dXJuIG1pbjt9KSkgLVxuICAgICAgICAgIE1hdGgubWF4KC4uLnJlY3RzLm1hcCgoX3JlZjYpID0+IHtsZXQgeyBbbWF4UHJvcF06IG1heCB9ID0gX3JlZjY7cmV0dXJuIG1heDt9KSkgPlxuICAgICAgICAgIDApO30pO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnRJblJlY3QocG9pbnQsIHJlY3QpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBvaW50LnggPD0gcmVjdC5yaWdodCAmJlxuICAgICAgICBwb2ludC54ID49IHJlY3QubGVmdCAmJlxuICAgICAgICBwb2ludC55IDw9IHJlY3QuYm90dG9tICYmXG4gICAgICAgIHBvaW50LnkgPj0gcmVjdC50b3ApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmF0aW8oZGltZW5zaW9ucywgcHJvcCwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IGFQcm9wID0gcHJvcCA9PT0gJ3dpZHRoJyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW2FQcm9wXTogZGltZW5zaW9uc1twcm9wXSA/XG4gICAgICAgIE1hdGgucm91bmQodmFsdWUgKiBkaW1lbnNpb25zW2FQcm9wXSAvIGRpbWVuc2lvbnNbcHJvcF0pIDpcbiAgICAgICAgZGltZW5zaW9uc1thUHJvcF0sXG4gICAgICAgIFtwcm9wXTogdmFsdWUgfTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW4oZGltZW5zaW9ucywgbWF4RGltZW5zaW9ucykge1xuICAgICAgZGltZW5zaW9ucyA9IHsgLi4uZGltZW5zaW9ucyB9O1xuXG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gZGltZW5zaW9ucykge1xuICAgICAgICBkaW1lbnNpb25zID1cbiAgICAgICAgZGltZW5zaW9uc1twcm9wXSA+IG1heERpbWVuc2lvbnNbcHJvcF0gP1xuICAgICAgICByYXRpbyhkaW1lbnNpb25zLCBwcm9wLCBtYXhEaW1lbnNpb25zW3Byb3BdKSA6XG4gICAgICAgIGRpbWVuc2lvbnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaW1lbnNpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvdmVyJDEoZGltZW5zaW9ucywgbWF4RGltZW5zaW9ucykge1xuICAgICAgZGltZW5zaW9ucyA9IGNvbnRhaW4oZGltZW5zaW9ucywgbWF4RGltZW5zaW9ucyk7XG5cbiAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBkaW1lbnNpb25zKSB7XG4gICAgICAgIGRpbWVuc2lvbnMgPVxuICAgICAgICBkaW1lbnNpb25zW3Byb3BdIDwgbWF4RGltZW5zaW9uc1twcm9wXSA/XG4gICAgICAgIHJhdGlvKGRpbWVuc2lvbnMsIHByb3AsIG1heERpbWVuc2lvbnNbcHJvcF0pIDpcbiAgICAgICAgZGltZW5zaW9ucztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbWVuc2lvbnM7XG4gICAgfVxuXG4gICAgY29uc3QgRGltZW5zaW9ucyA9IHsgcmF0aW8sIGNvbnRhaW4sIGNvdmVyOiBjb3ZlciQxIH07XG5cbiAgICBmdW5jdGlvbiBnZXRJbmRleChpLCBlbGVtZW50cywgY3VycmVudCwgZmluaXRlKSB7aWYgKGN1cnJlbnQgPT09IHZvaWQgMCkge2N1cnJlbnQgPSAwO31pZiAoZmluaXRlID09PSB2b2lkIDApIHtmaW5pdGUgPSBmYWxzZTt9XG4gICAgICBlbGVtZW50cyA9IHRvTm9kZXMoZWxlbWVudHMpO1xuXG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gZWxlbWVudHM7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgaSA9IGlzTnVtZXJpYyhpKSA/XG4gICAgICB0b051bWJlcihpKSA6XG4gICAgICBpID09PSAnbmV4dCcgP1xuICAgICAgY3VycmVudCArIDEgOlxuICAgICAgaSA9PT0gJ3ByZXZpb3VzJyA/XG4gICAgICBjdXJyZW50IC0gMSA6XG4gICAgICBlbGVtZW50cy5pbmRleE9mKHRvTm9kZShpKSk7XG5cbiAgICAgIGlmIChmaW5pdGUpIHtcbiAgICAgICAgcmV0dXJuIGNsYW1wKGksIDAsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICBpICU9IGxlbmd0aDtcblxuICAgICAgcmV0dXJuIGkgPCAwID8gaSArIGxlbmd0aCA6IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICAgICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIChrZXkpID0+IGNhY2hlW2tleV0gfHwgKGNhY2hlW2tleV0gPSBmbihrZXkpKTtcbiAgICB9XG5cbiAgICBjbGFzcyBEZWZlcnJlZCB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgfX1cblxuICAgIGZ1bmN0aW9uIGF0dHIoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuYW1lKSB7XG4gICAgICAgICAgYXR0cihlbGVtZW50LCBrZXksIG5hbWVba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7dmFyIF90b05vZGU7XG4gICAgICAgIHJldHVybiAoX3RvTm9kZSA9IHRvTm9kZShlbGVtZW50KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90b05vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBlbCBvZiB0b05vZGVzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwoZWwsIGF0dHIoZWwsIG5hbWUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0F0dHIoZWxlbWVudCwgbmFtZSkge1xuICAgICAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuc29tZSgoZWxlbWVudCkgPT4gZWxlbWVudC5oYXNBdHRyaWJ1dGUobmFtZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUF0dHIoZWxlbWVudCwgbmFtZSkge1xuICAgICAgY29uc3QgZWxlbWVudHMgPSB0b05vZGVzKGVsZW1lbnQpO1xuICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgbmFtZS5zcGxpdCgnICcpKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXRhKGVsZW1lbnQsIGF0dHJpYnV0ZSkge1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIFthdHRyaWJ1dGUsIFwiZGF0YS1cIiArIGF0dHJpYnV0ZV0pIHtcbiAgICAgICAgaWYgKGhhc0F0dHIoZWxlbWVudCwgbmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gYXR0cihlbGVtZW50LCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHZvaWRFbGVtZW50cyA9IHtcbiAgICAgIGFyZWE6IHRydWUsXG4gICAgICBiYXNlOiB0cnVlLFxuICAgICAgYnI6IHRydWUsXG4gICAgICBjb2w6IHRydWUsXG4gICAgICBlbWJlZDogdHJ1ZSxcbiAgICAgIGhyOiB0cnVlLFxuICAgICAgaW1nOiB0cnVlLFxuICAgICAgaW5wdXQ6IHRydWUsXG4gICAgICBrZXlnZW46IHRydWUsXG4gICAgICBsaW5rOiB0cnVlLFxuICAgICAgbWVudWl0ZW06IHRydWUsXG4gICAgICBtZXRhOiB0cnVlLFxuICAgICAgcGFyYW06IHRydWUsXG4gICAgICBzb3VyY2U6IHRydWUsXG4gICAgICB0cmFjazogdHJ1ZSxcbiAgICAgIHdicjogdHJ1ZSB9O1xuXG4gICAgZnVuY3Rpb24gaXNWb2lkRWxlbWVudChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5zb21lKChlbGVtZW50KSA9PiB2b2lkRWxlbWVudHNbZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCldKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Zpc2libGUoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuc29tZShcbiAgICAgIChlbGVtZW50KSA9PiBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xuXG4gICAgfVxuXG4gICAgY29uc3Qgc2VsSW5wdXQgPSAnaW5wdXQsc2VsZWN0LHRleHRhcmVhLGJ1dHRvbic7XG4gICAgZnVuY3Rpb24gaXNJbnB1dChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5zb21lKChlbGVtZW50KSA9PiBtYXRjaGVzKGVsZW1lbnQsIHNlbElucHV0KSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsRm9jdXNhYmxlID0gc2VsSW5wdXQgKyBcIixhW2hyZWZdLFt0YWJpbmRleF1cIjtcbiAgICBmdW5jdGlvbiBpc0ZvY3VzYWJsZShlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcyhlbGVtZW50LCBzZWxGb2N1c2FibGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcmVudChlbGVtZW50KSB7dmFyIF90b05vZGU7XG4gICAgICByZXR1cm4gKF90b05vZGUgPSB0b05vZGUoZWxlbWVudCkpID09IG51bGwgPyB2b2lkIDAgOiBfdG9Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyJDEoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLmZpbHRlcigoZWxlbWVudCkgPT4gbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoKGVsZW1lbnQpID0+IGVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBpc0VsZW1lbnQoZWxlbWVudCkgP1xuICAgICAgZWxlbWVudC5jbG9zZXN0KHN0YXJ0c1dpdGgoc2VsZWN0b3IsICc+JykgPyBzZWxlY3Rvci5zbGljZSgxKSA6IHNlbGVjdG9yKSA6XG4gICAgICB0b05vZGVzKGVsZW1lbnQpLlxuICAgICAgbWFwKChlbGVtZW50KSA9PiBjbG9zZXN0KGVsZW1lbnQsIHNlbGVjdG9yKSkuXG4gICAgICBmaWx0ZXIoQm9vbGVhbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2l0aGluKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gaXNTdHJpbmcoc2VsZWN0b3IpID9cbiAgICAgICEhY2xvc2VzdChlbGVtZW50LCBzZWxlY3RvcikgOlxuICAgICAgdG9Ob2RlKHNlbGVjdG9yKS5jb250YWlucyh0b05vZGUoZWxlbWVudCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcmVudHMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG5cbiAgICAgIHdoaWxlIChlbGVtZW50ID0gcGFyZW50KGVsZW1lbnQpKSB7XG4gICAgICAgIGlmICghc2VsZWN0b3IgfHwgbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcikpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gZWxlbWVudCA/IHRvTm9kZXMoZWxlbWVudC5jaGlsZHJlbikgOiBbXTtcbiAgICAgIHJldHVybiBzZWxlY3RvciA/IGZpbHRlciQxKGNoaWxkcmVuLCBzZWxlY3RvcikgOiBjaGlsZHJlbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmRleChlbGVtZW50LCByZWYpIHtcbiAgICAgIHJldHVybiByZWYgPyB0b05vZGVzKGVsZW1lbnQpLmluZGV4T2YodG9Ob2RlKHJlZikpIDogY2hpbGRyZW4ocGFyZW50KGVsZW1lbnQpKS5pbmRleE9mKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHF1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gZmluZChzZWxlY3RvciwgZ2V0Q29udGV4dChzZWxlY3RvciwgY29udGV4dCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHF1ZXJ5QWxsKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gZmluZEFsbChzZWxlY3RvciwgZ2V0Q29udGV4dChzZWxlY3RvciwgY29udGV4dCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0b05vZGUoX3F1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0LCAncXVlcnlTZWxlY3RvcicpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kQWxsKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhfcXVlcnkoc2VsZWN0b3IsIGNvbnRleHQsICdxdWVyeVNlbGVjdG9yQWxsJykpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRleHRTZWxlY3RvclJlID0gLyhefFteXFxcXF0sKVxccypbIT4rfi1dLztcbiAgICBjb25zdCBpc0NvbnRleHRTZWxlY3RvciA9IG1lbW9pemUoKHNlbGVjdG9yKSA9PiBzZWxlY3Rvci5tYXRjaChjb250ZXh0U2VsZWN0b3JSZSkpO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dChzZWxlY3RvciwgY29udGV4dCkge2lmIChjb250ZXh0ID09PSB2b2lkIDApIHtjb250ZXh0ID0gZG9jdW1lbnQ7fVxuICAgICAgcmV0dXJuIGlzU3RyaW5nKHNlbGVjdG9yKSAmJiBpc0NvbnRleHRTZWxlY3RvcihzZWxlY3RvcikgfHwgaXNEb2N1bWVudChjb250ZXh0KSA/XG4gICAgICBjb250ZXh0IDpcbiAgICAgIGNvbnRleHQub3duZXJEb2N1bWVudDtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0U2FuaXRpemVSZSA9IC8oWyE+K34tXSkoPz1cXHMrWyE+K34tXXxcXHMqJCkvZztcbiAgICBjb25zdCBzYW5hdGl6ZSA9IG1lbW9pemUoKHNlbGVjdG9yKSA9PiBzZWxlY3Rvci5yZXBsYWNlKGNvbnRleHRTYW5pdGl6ZVJlLCAnJDEgKicpKTtcblxuICAgIGZ1bmN0aW9uIF9xdWVyeShzZWxlY3RvciwgY29udGV4dCwgcXVlcnlGbikge2lmIChjb250ZXh0ID09PSB2b2lkIDApIHtjb250ZXh0ID0gZG9jdW1lbnQ7fVxuICAgICAgaWYgKCFzZWxlY3RvciB8fCAhaXNTdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0b3IgPSBzYW5hdGl6ZShzZWxlY3Rvcik7XG5cbiAgICAgIGlmIChpc0NvbnRleHRTZWxlY3RvcihzZWxlY3RvcikpIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBzcGxpdFNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgc2VsZWN0b3IgPSAnJztcbiAgICAgICAgZm9yIChsZXQgc2VsIG9mIHNwbGl0KSB7XG4gICAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQ7XG5cbiAgICAgICAgICBpZiAoc2VsWzBdID09PSAnIScpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IHNlbC5zdWJzdHIoMSkudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBjdHggPSBjbG9zZXN0KHBhcmVudChjb250ZXh0KSwgc2VsZWN0b3JzWzBdKTtcbiAgICAgICAgICAgIHNlbCA9IHNlbGVjdG9ycy5zbGljZSgxKS5qb2luKCcgJykudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCFzZWwubGVuZ3RoICYmIHNwbGl0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxbMF0gPT09ICctJykge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3JzID0gc2VsLnN1YnN0cigxKS50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSAoY3R4IHx8IGNvbnRleHQpLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICBjdHggPSBtYXRjaGVzKHByZXYsIHNlbC5zdWJzdHIoMSkpID8gcHJldiA6IG51bGw7XG4gICAgICAgICAgICBzZWwgPSBzZWxlY3RvcnMuc2xpY2UoMSkuam9pbignICcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIHNlbGVjdG9yICs9IFwiXCIgKyAoc2VsZWN0b3IgPyAnLCcgOiAnJykgKyBkb21QYXRoKGN0eCkgKyBcIiBcIiArIHNlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0W3F1ZXJ5Rm5dKHNlbGVjdG9yKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0b3JSZSA9IC8uKj9bXlxcXFxdKD86LHwkKS9nO1xuXG4gICAgY29uc3Qgc3BsaXRTZWxlY3RvciA9IG1lbW9pemUoKHNlbGVjdG9yKSA9PlxuICAgIHNlbGVjdG9yLm1hdGNoKHNlbGVjdG9yUmUpLm1hcCgoc2VsZWN0b3IpID0+IHNlbGVjdG9yLnJlcGxhY2UoLywkLywgJycpLnRyaW0oKSkpO1xuXG5cbiAgICBmdW5jdGlvbiBkb21QYXRoKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gW107XG4gICAgICB3aGlsZSAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnN0IGlkID0gYXR0cihlbGVtZW50LCAnaWQnKTtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgbmFtZXMudW5zaGlmdChcIiNcIiArIGVzY2FwZShpZCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCB7IHRhZ05hbWUgfSA9IGVsZW1lbnQ7XG4gICAgICAgICAgaWYgKHRhZ05hbWUgIT09ICdIVE1MJykge1xuICAgICAgICAgICAgdGFnTmFtZSArPSBcIjpudGgtY2hpbGQoXCIgKyAoaW5kZXgoZWxlbWVudCkgKyAxKSArIFwiKVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuYW1lcy51bnNoaWZ0KHRhZ05hbWUpO1xuICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuYW1lcy5qb2luKCcgPiAnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc2NhcGUoY3NzKSB7XG4gICAgICByZXR1cm4gaXNTdHJpbmcoY3NzKSA/IENTUy5lc2NhcGUoY3NzKSA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uKCkge2ZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge2FyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07fVxuICAgICAgbGV0IFt0YXJnZXRzLCB0eXBlcywgc2VsZWN0b3IsIGxpc3RlbmVyLCB1c2VDYXB0dXJlID0gZmFsc2VdID0gZ2V0QXJncyhhcmdzKTtcblxuICAgICAgaWYgKGxpc3RlbmVyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbGlzdGVuZXIgPSBkZXRhaWwobGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodXNlQ2FwdHVyZSAhPSBudWxsICYmIHVzZUNhcHR1cmUuc2VsZikge1xuICAgICAgICBsaXN0ZW5lciA9IHNlbGZGaWx0ZXIobGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgbGlzdGVuZXIgPSBkZWxlZ2F0ZShzZWxlY3RvciwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKCkgPT4gb2ZmKHRhcmdldHMsIHR5cGVzLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2ZmKCkge2ZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge2FyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTt9XG4gICAgICBsZXQgW3RhcmdldHMsIHR5cGVzLCwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgPSBmYWxzZV0gPSBnZXRBcmdzKGFyZ3MpO1xuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmNlKCkge2ZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge2FyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTt9XG4gICAgICBjb25zdCBbZWxlbWVudCwgdHlwZXMsIHNlbGVjdG9yLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSA9IGZhbHNlLCBjb25kaXRpb25dID0gZ2V0QXJncyhhcmdzKTtcbiAgICAgIGNvbnN0IG9mZiA9IG9uKFxuICAgICAgZWxlbWVudCxcbiAgICAgIHR5cGVzLFxuICAgICAgc2VsZWN0b3IsXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAhY29uZGl0aW9uIHx8IGNvbmRpdGlvbihlKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIG9mZigpO1xuICAgICAgICAgIGxpc3RlbmVyKGUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VDYXB0dXJlKTtcblxuXG4gICAgICByZXR1cm4gb2ZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0cywgZXZlbnQsIGRldGFpbCkge1xuICAgICAgcmV0dXJuIHRvRXZlbnRUYXJnZXRzKHRhcmdldHMpLmV2ZXJ5KCh0YXJnZXQpID0+XG4gICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChjcmVhdGVFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSwgZGV0YWlsKSkpO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRXZlbnQoZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgZGV0YWlsKSB7aWYgKGJ1YmJsZXMgPT09IHZvaWQgMCkge2J1YmJsZXMgPSB0cnVlO31pZiAoY2FuY2VsYWJsZSA9PT0gdm9pZCAwKSB7Y2FuY2VsYWJsZSA9IGZhbHNlO31cbiAgICAgIGlmIChpc1N0cmluZyhlKSkge1xuICAgICAgICBlID0gbmV3IEN1c3RvbUV2ZW50KGUsIHsgYnViYmxlcywgY2FuY2VsYWJsZSwgZGV0YWlsIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBcmdzKGFyZ3MpIHtcbiAgICAgIC8vIEV2ZW50IHRhcmdldHNcbiAgICAgIGFyZ3NbMF0gPSB0b0V2ZW50VGFyZ2V0cyhhcmdzWzBdKTtcblxuICAgICAgLy8gRXZlbnQgdHlwZXNcbiAgICAgIGlmIChpc1N0cmluZyhhcmdzWzFdKSkge1xuICAgICAgICBhcmdzWzFdID0gYXJnc1sxXS5zcGxpdCgnICcpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZWxlZ2F0ZT9cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZ3NbMl0pKSB7XG4gICAgICAgIGFyZ3Muc3BsaWNlKDIsIDAsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsZWdhdGUoc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gKGUpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9XG4gICAgICAgIHNlbGVjdG9yWzBdID09PSAnPicgP1xuICAgICAgICBmaW5kQWxsKHNlbGVjdG9yLCBlLmN1cnJlbnRUYXJnZXQpLlxuICAgICAgICByZXZlcnNlKCkuXG4gICAgICAgIGZpbHRlcigoZWxlbWVudCkgPT4gd2l0aGluKGUudGFyZ2V0LCBlbGVtZW50KSlbMF0gOlxuICAgICAgICBjbG9zZXN0KGUudGFyZ2V0LCBzZWxlY3Rvcik7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICBlLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0YWlsKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gKGUpID0+IGlzQXJyYXkoZS5kZXRhaWwpID8gbGlzdGVuZXIoZSwgLi4uZS5kZXRhaWwpIDogbGlzdGVuZXIoZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZkZpbHRlcihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0IHx8IGUudGFyZ2V0ID09PSBlLmN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuY2FsbChudWxsLCBlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0V2ZW50VGFyZ2V0KHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRhcmdldCAmJiAnYWRkRXZlbnRMaXN0ZW5lcicgaW4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRXZlbnRUYXJnZXQodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gaXNFdmVudFRhcmdldCh0YXJnZXQpID8gdGFyZ2V0IDogdG9Ob2RlKHRhcmdldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9FdmVudFRhcmdldHModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheSh0YXJnZXQpID9cbiAgICAgIHRhcmdldC5tYXAodG9FdmVudFRhcmdldCkuZmlsdGVyKEJvb2xlYW4pIDpcbiAgICAgIGlzU3RyaW5nKHRhcmdldCkgP1xuICAgICAgZmluZEFsbCh0YXJnZXQpIDpcbiAgICAgIGlzRXZlbnRUYXJnZXQodGFyZ2V0KSA/XG4gICAgICBbdGFyZ2V0XSA6XG4gICAgICB0b05vZGVzKHRhcmdldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNUb3VjaChlKSB7XG4gICAgICByZXR1cm4gZS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyB8fCAhIWUudG91Y2hlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFdmVudFBvcyhlKSB7dmFyIF9lJHRvdWNoZXMsIF9lJGNoYW5nZWRUb3VjaGVzO1xuICAgICAgY29uc3QgeyBjbGllbnRYOiB4LCBjbGllbnRZOiB5IH0gPSAoKF9lJHRvdWNoZXMgPSBlLnRvdWNoZXMpID09IG51bGwgPyB2b2lkIDAgOiBfZSR0b3VjaGVzWzBdKSB8fCAoKF9lJGNoYW5nZWRUb3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lJGNoYW5nZWRUb3VjaGVzWzBdKSB8fCBlO1xuXG4gICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWpheCh1cmwsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVudiA9IHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIHhocjogbmV3IFhNTEh0dHBSZXF1ZXN0KCksXG4gICAgICAgIGJlZm9yZVNlbmQ6IG5vb3AsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJycsXG4gICAgICAgIC4uLm9wdGlvbnMgfTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLlxuICAgICAgdGhlbigoKSA9PiBlbnYuYmVmb3JlU2VuZChlbnYpKS5cbiAgICAgIHRoZW4oKCkgPT4gc2VuZCh1cmwsIGVudikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbmQodXJsLCBlbnYpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgeGhyIH0gPSBlbnY7XG5cbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIGVudikge1xuICAgICAgICAgIGlmIChwcm9wIGluIHhocikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgeGhyW3Byb3BdID0gZW52W3Byb3BdO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgeGhyLm9wZW4oZW52Lm1ldGhvZC50b1VwcGVyQ2FzZSgpLCB1cmwpO1xuXG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIGVudi5oZWFkZXJzKSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCBlbnYuaGVhZGVyc1toZWFkZXJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uKHhociwgJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDAgfHwgeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCB8fCB4aHIuc3RhdHVzID09PSAzMDQpIHtcbiAgICAgICAgICAgIHJlc29sdmUoeGhyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgYXNzaWduKEVycm9yKHhoci5zdGF0dXNUZXh0KSwge1xuICAgICAgICAgICAgICB4aHIsXG4gICAgICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyB9KSk7XG5cblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgb24oeGhyLCAnZXJyb3InLCAoKSA9PiByZWplY3QoYXNzaWduKEVycm9yKCdOZXR3b3JrIEVycm9yJyksIHsgeGhyIH0pKSk7XG4gICAgICAgIG9uKHhociwgJ3RpbWVvdXQnLCAoKSA9PiByZWplY3QoYXNzaWduKEVycm9yKCdOZXR3b3JrIFRpbWVvdXQnKSwgeyB4aHIgfSkpKTtcblxuICAgICAgICB4aHIuc2VuZChlbnYuZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbWFnZShzcmMsIHNyY3NldCwgc2l6ZXMpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICAgIGltZy5vbmVycm9yID0gKGUpID0+IHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpemVzICYmIChpbWcuc2l6ZXMgPSBzaXplcyk7XG4gICAgICAgIHNyY3NldCAmJiAoaW1nLnNyY3NldCA9IHNyY3NldCk7XG4gICAgICAgIGltZy5zcmMgPSBzcmM7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjc3NOdW1iZXIgPSB7XG4gICAgICAnYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCc6IHRydWUsXG4gICAgICAnY29sdW1uLWNvdW50JzogdHJ1ZSxcbiAgICAgICdmaWxsLW9wYWNpdHknOiB0cnVlLFxuICAgICAgJ2ZsZXgtZ3Jvdyc6IHRydWUsXG4gICAgICAnZmxleC1zaHJpbmsnOiB0cnVlLFxuICAgICAgJ2ZvbnQtd2VpZ2h0JzogdHJ1ZSxcbiAgICAgICdsaW5lLWhlaWdodCc6IHRydWUsXG4gICAgICBvcGFjaXR5OiB0cnVlLFxuICAgICAgb3JkZXI6IHRydWUsXG4gICAgICBvcnBoYW5zOiB0cnVlLFxuICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiB0cnVlLFxuICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogdHJ1ZSxcbiAgICAgIHdpZG93czogdHJ1ZSxcbiAgICAgICd6LWluZGV4JzogdHJ1ZSxcbiAgICAgIHpvb206IHRydWUgfTtcblxuXG4gICAgZnVuY3Rpb24gY3NzKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSwgcHJpb3JpdHkpIHtpZiAocHJpb3JpdHkgPT09IHZvaWQgMCkge3ByaW9yaXR5ID0gJyc7fVxuICAgICAgY29uc3QgZWxlbWVudHMgPSB0b05vZGVzKGVsZW1lbnQpO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChpc1N0cmluZyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BOYW1lKHByb3BlcnR5KTtcblxuICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICBpc051bWVyaWModmFsdWUpICYmICFjc3NOdW1iZXJbcHJvcGVydHldID9cbiAgICAgICAgICAgIHZhbHVlICsgXCJweFwiIDpcbiAgICAgICAgICAgIHZhbHVlIHx8IGlzTnVtYmVyKHZhbHVlKSA/XG4gICAgICAgICAgICB2YWx1ZSA6XG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIHByaW9yaXR5KTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHByb3BlcnR5KSkge1xuICAgICAgICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BlcnR5KSB7XG4gICAgICAgICAgICBwcm9wc1twcm9wXSA9IGNzcyhlbGVtZW50LCBwcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHByb3BlcnR5KSkge1xuICAgICAgICAgIHByaW9yaXR5ID0gdmFsdWU7XG4gICAgICAgICAgZWFjaChwcm9wZXJ0eSwgKHZhbHVlLCBwcm9wZXJ0eSkgPT4gY3NzKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSwgcHJpb3JpdHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnRzWzBdO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jZG9tLWNzc3N0eWxlZGVjbGFyYXRpb24tc2V0cHJvcGVydHlcbiAgICBjb25zdCBwcm9wTmFtZSA9IG1lbW9pemUoKG5hbWUpID0+IHZlbmRvclByb3BOYW1lKG5hbWUpKTtcblxuICAgIGZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKG5hbWUpIHtcbiAgICAgIGlmIChzdGFydHNXaXRoKG5hbWUsICctLScpKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuXG4gICAgICBuYW1lID0gaHlwaGVuYXRlKG5hbWUpO1xuXG4gICAgICBjb25zdCB7IHN0eWxlIH0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgIGlmIChuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBbJ3dlYmtpdCcsICdtb3onXSkge1xuICAgICAgICBjb25zdCBwcmVmaXhlZE5hbWUgPSBcIi1cIiArIHByZWZpeCArIFwiLVwiICsgbmFtZTtcbiAgICAgICAgaWYgKHByZWZpeGVkTmFtZSBpbiBzdHlsZSkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXhlZE5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50KSB7Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge2FyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO31cbiAgICAgIGFwcGx5JDEoZWxlbWVudCwgYXJncywgJ2FkZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQpIHtmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge2FyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07fVxuICAgICAgYXBwbHkkMShlbGVtZW50LCBhcmdzLCAncmVtb3ZlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3NlcyhlbGVtZW50LCBjbHMpIHtcbiAgICAgIGF0dHIoZWxlbWVudCwgJ2NsYXNzJywgKHZhbHVlKSA9PlxuICAgICAgKHZhbHVlIHx8ICcnKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxcYlwiICsgY2xzICsgXCJcXFxcYlxcXFxzP1wiLCAnZycpLCAnJykpO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUNsYXNzKGVsZW1lbnQpIHtcbiAgICAgIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0pICYmIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSk7XG4gICAgICAoYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKSAmJiBhZGRDbGFzcyhlbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNscykge1xuICAgICAgW2Nsc10gPSBnZXRDbGFzc2VzKGNscyk7XG4gICAgICByZXR1cm4gISFjbHMgJiYgdG9Ob2RlcyhlbGVtZW50KS5zb21lKChub2RlKSA9PiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhjbHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbHMsIGZvcmNlKSB7XG4gICAgICBjb25zdCBjbGFzc2VzID0gZ2V0Q2xhc3NlcyhjbHMpO1xuXG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKGZvcmNlKSkge1xuICAgICAgICBmb3JjZSA9ICEhZm9yY2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0b05vZGVzKGVsZW1lbnQpKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2xzIG9mIGNsYXNzZXMpIHtcbiAgICAgICAgICBub2RlLmNsYXNzTGlzdC50b2dnbGUoY2xzLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseSQxKGVsZW1lbnQsIGFyZ3MsIGZuKSB7XG4gICAgICBhcmdzID0gYXJncy5yZWR1Y2UoKGFyZ3MsIGFyZykgPT4gYXJncy5jb25jYXQoZ2V0Q2xhc3NlcyhhcmcpKSwgW10pO1xuXG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdG9Ob2RlcyhlbGVtZW50KSkge1xuICAgICAgICBub2RlLmNsYXNzTGlzdFtmbl0oLi4uYXJncyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2xhc3NlcyhzdHIpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5zcGxpdCgvXFxzfCwvKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbiQxKGVsZW1lbnQsIHByb3BzLCBkdXJhdGlvbiwgdGltaW5nKSB7aWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtkdXJhdGlvbiA9IDQwMDt9aWYgKHRpbWluZyA9PT0gdm9pZCAwKSB7dGltaW5nID0gJ2xpbmVhcic7fVxuICAgICAgZHVyYXRpb24gPSBNYXRoLnJvdW5kKGR1cmF0aW9uKTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIHRvTm9kZXMoZWxlbWVudCkubWFwKFxuICAgICAgKGVsZW1lbnQpID0+XG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3NzKGVsZW1lbnQsIG5hbWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIGNzcyhlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRyaWdnZXIoZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnKSwgZHVyYXRpb24pO1xuXG4gICAgICAgIG9uY2UoXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgICd0cmFuc2l0aW9uZW5kIHRyYW5zaXRpb25jYW5jZWxlZCcsXG4gICAgICAgIChfcmVmKSA9PiB7bGV0IHsgdHlwZSB9ID0gX3JlZjtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsICd1ay10cmFuc2l0aW9uJyk7XG4gICAgICAgICAgY3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogJycsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246ICcnLFxuICAgICAgICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiAnJyB9KTtcblxuICAgICAgICAgIHR5cGUgPT09ICd0cmFuc2l0aW9uY2FuY2VsZWQnID8gcmVqZWN0KCkgOiByZXNvbHZlKGVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICB7IHNlbGY6IHRydWUgfSk7XG5cblxuICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCAndWstdHJhbnNpdGlvbicpO1xuICAgICAgICBjc3MoZWxlbWVudCwge1xuICAgICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogT2JqZWN0LmtleXMocHJvcHMpLm1hcChwcm9wTmFtZSkuam9pbignLCcpLFxuICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogZHVyYXRpb24gKyBcIm1zXCIsXG4gICAgICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiB0aW1pbmcsXG4gICAgICAgICAgLi4ucHJvcHMgfSk7XG5cbiAgICAgIH0pKSk7XG5cblxuICAgIH1cblxuICAgIGNvbnN0IFRyYW5zaXRpb24gPSB7XG4gICAgICBzdGFydDogdHJhbnNpdGlvbiQxLFxuXG4gICAgICBhc3luYyBzdG9wKGVsZW1lbnQpIHtcbiAgICAgICAgdHJpZ2dlcihlbGVtZW50LCAndHJhbnNpdGlvbmVuZCcpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH0sXG5cbiAgICAgIGFzeW5jIGNhbmNlbChlbGVtZW50KSB7XG4gICAgICAgIHRyaWdnZXIoZWxlbWVudCwgJ3RyYW5zaXRpb25jYW5jZWxlZCcpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH0sXG5cbiAgICAgIGluUHJvZ3Jlc3MoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gaGFzQ2xhc3MoZWxlbWVudCwgJ3VrLXRyYW5zaXRpb24nKTtcbiAgICAgIH0gfTtcblxuXG4gICAgY29uc3QgYW5pbWF0aW9uUHJlZml4ID0gJ3VrLWFuaW1hdGlvbi0nO1xuXG4gICAgZnVuY3Rpb24gYW5pbWF0ZSQyKGVsZW1lbnQsIGFuaW1hdGlvbiwgZHVyYXRpb24sIG9yaWdpbiwgb3V0KSB7aWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtkdXJhdGlvbiA9IDIwMDt9XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICB0b05vZGVzKGVsZW1lbnQpLm1hcChcbiAgICAgIChlbGVtZW50KSA9PlxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cmlnZ2VyKGVsZW1lbnQsICdhbmltYXRpb25jYW5jZWxlZCcpO1xuICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdHJpZ2dlcihlbGVtZW50LCAnYW5pbWF0aW9uZW5kJyksIGR1cmF0aW9uKTtcblxuICAgICAgICBvbmNlKFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICAnYW5pbWF0aW9uZW5kIGFuaW1hdGlvbmNhbmNlbGVkJyxcbiAgICAgICAgKF9yZWYyKSA9PiB7bGV0IHsgdHlwZSB9ID0gX3JlZjI7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICAgIHR5cGUgPT09ICdhbmltYXRpb25jYW5jZWxlZCcgPyByZWplY3QoKSA6IHJlc29sdmUoZWxlbWVudCk7XG5cbiAgICAgICAgICBjc3MoZWxlbWVudCwgJ2FuaW1hdGlvbkR1cmF0aW9uJywgJycpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzZXMoZWxlbWVudCwgYW5pbWF0aW9uUHJlZml4ICsgXCJcXFxcUypcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHsgc2VsZjogdHJ1ZSB9KTtcblxuXG4gICAgICAgIGNzcyhlbGVtZW50LCAnYW5pbWF0aW9uRHVyYXRpb24nLCBkdXJhdGlvbiArIFwibXNcIik7XG4gICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIGFuaW1hdGlvbiwgYW5pbWF0aW9uUHJlZml4ICsgKG91dCA/ICdsZWF2ZScgOiAnZW50ZXInKSk7XG5cbiAgICAgICAgaWYgKHN0YXJ0c1dpdGgoYW5pbWF0aW9uLCBhbmltYXRpb25QcmVmaXgpKSB7XG4gICAgICAgICAgb3JpZ2luICYmIGFkZENsYXNzKGVsZW1lbnQsIFwidWstdHJhbnNmb3JtLW9yaWdpbi1cIiArIG9yaWdpbik7XG4gICAgICAgICAgb3V0ICYmIGFkZENsYXNzKGVsZW1lbnQsIGFuaW1hdGlvblByZWZpeCArIFwicmV2ZXJzZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSkpKTtcblxuXG4gICAgfVxuXG4gICAgY29uc3QgaW5Qcm9ncmVzc1JlID0gbmV3IFJlZ0V4cChhbmltYXRpb25QcmVmaXggKyBcIihlbnRlcnxsZWF2ZSlcIik7XG5cbiAgICBjb25zdCBBbmltYXRpb24gPSB7XG4gICAgICBpbjogYW5pbWF0ZSQyLFxuXG4gICAgICBvdXQoZWxlbWVudCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRlJDIoZWxlbWVudCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgb3JpZ2luLCB0cnVlKTtcbiAgICAgIH0sXG5cbiAgICAgIGluUHJvZ3Jlc3MoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gaW5Qcm9ncmVzc1JlLnRlc3QoYXR0cihlbGVtZW50LCAnY2xhc3MnKSk7XG4gICAgICB9LFxuXG4gICAgICBjYW5jZWwoZWxlbWVudCkge1xuICAgICAgICB0cmlnZ2VyKGVsZW1lbnQsICdhbmltYXRpb25jYW5jZWxlZCcpO1xuICAgICAgfSB9O1xuXG4gICAgY29uc3QgZGlycyQxID0ge1xuICAgICAgd2lkdGg6IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgaGVpZ2h0OiBbJ3RvcCcsICdib3R0b20nXSB9O1xuXG5cbiAgICBmdW5jdGlvbiBkaW1lbnNpb25zJDEoZWxlbWVudCkge1xuICAgICAgY29uc3QgcmVjdCA9IGlzRWxlbWVudChlbGVtZW50KSA/XG4gICAgICB0b05vZGUoZWxlbWVudCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOlxuICAgICAgeyBoZWlnaHQ6IGhlaWdodChlbGVtZW50KSwgd2lkdGg6IHdpZHRoKGVsZW1lbnQpLCB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICAgIHRvcDogcmVjdC50b3AsXG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICAgICAgYm90dG9tOiByZWN0LnRvcCArIHJlY3QuaGVpZ2h0LFxuICAgICAgICByaWdodDogcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCB9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KGVsZW1lbnQsIGNvb3JkaW5hdGVzKSB7XG4gICAgICBjb25zdCBjdXJyZW50T2Zmc2V0ID0gZGltZW5zaW9ucyQxKGVsZW1lbnQpO1xuXG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBjb25zdCB7IHNjcm9sbFksIHNjcm9sbFggfSA9IHRvV2luZG93KGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBvZmZzZXRCeSA9IHsgaGVpZ2h0OiBzY3JvbGxZLCB3aWR0aDogc2Nyb2xsWCB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgZGlyIGluIGRpcnMkMSkge1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBkaXJzJDFbZGlyXSkge1xuICAgICAgICAgICAgY3VycmVudE9mZnNldFtwcm9wXSArPSBvZmZzZXRCeVtkaXJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50T2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwb3MgPSBjc3MoZWxlbWVudCwgJ3Bvc2l0aW9uJyk7XG5cbiAgICAgIGVhY2goY3NzKGVsZW1lbnQsIFsnbGVmdCcsICd0b3AnXSksICh2YWx1ZSwgcHJvcCkgPT5cbiAgICAgIGNzcyhcbiAgICAgIGVsZW1lbnQsXG4gICAgICBwcm9wLFxuICAgICAgY29vcmRpbmF0ZXNbcHJvcF0gLVxuICAgICAgY3VycmVudE9mZnNldFtwcm9wXSArXG4gICAgICB0b0Zsb2F0KHBvcyA9PT0gJ2Fic29sdXRlJyAmJiB2YWx1ZSA9PT0gJ2F1dG8nID8gcG9zaXRpb24oZWxlbWVudClbcHJvcF0gOiB2YWx1ZSkpKTtcblxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpb24oZWxlbWVudCkge1xuICAgICAgbGV0IHsgdG9wLCBsZWZ0IH0gPSBvZmZzZXQoZWxlbWVudCk7XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3duZXJEb2N1bWVudDogeyBib2R5LCBkb2N1bWVudEVsZW1lbnQgfSxcbiAgICAgICAgb2Zmc2V0UGFyZW50IH0gPVxuICAgICAgdG9Ob2RlKGVsZW1lbnQpO1xuICAgICAgbGV0IHBhcmVudCA9IG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgIHdoaWxlIChcbiAgICAgIHBhcmVudCAmJiAoXG4gICAgICBwYXJlbnQgPT09IGJvZHkgfHwgcGFyZW50ID09PSBkb2N1bWVudEVsZW1lbnQpICYmXG4gICAgICBjc3MocGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpXG4gICAgICB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNFbGVtZW50KHBhcmVudCkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50T2Zmc2V0ID0gb2Zmc2V0KHBhcmVudCk7XG4gICAgICAgIHRvcCAtPSBwYXJlbnRPZmZzZXQudG9wICsgdG9GbG9hdChjc3MocGFyZW50LCAnYm9yZGVyVG9wV2lkdGgnKSk7XG4gICAgICAgIGxlZnQgLT0gcGFyZW50T2Zmc2V0LmxlZnQgKyB0b0Zsb2F0KGNzcyhwYXJlbnQsICdib3JkZXJMZWZ0V2lkdGgnKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wIC0gdG9GbG9hdChjc3MoZWxlbWVudCwgJ21hcmdpblRvcCcpKSxcbiAgICAgICAgbGVmdDogbGVmdCAtIHRvRmxvYXQoY3NzKGVsZW1lbnQsICdtYXJnaW5MZWZ0JykpIH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRQb3NpdGlvbihlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gdG9Ob2RlKGVsZW1lbnQpO1xuXG4gICAgICBjb25zdCBvZmZzZXQgPSBbZWxlbWVudC5vZmZzZXRUb3AsIGVsZW1lbnQub2Zmc2V0TGVmdF07XG5cbiAgICAgIHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgb2Zmc2V0WzBdICs9IGVsZW1lbnQub2Zmc2V0VG9wICsgdG9GbG9hdChjc3MoZWxlbWVudCwgXCJib3JkZXJUb3BXaWR0aFwiKSk7XG4gICAgICAgIG9mZnNldFsxXSArPSBlbGVtZW50Lm9mZnNldExlZnQgKyB0b0Zsb2F0KGNzcyhlbGVtZW50LCBcImJvcmRlckxlZnRXaWR0aFwiKSk7XG5cbiAgICAgICAgaWYgKGNzcyhlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAgIGNvbnN0IHdpbiA9IHRvV2luZG93KGVsZW1lbnQpO1xuICAgICAgICAgIG9mZnNldFswXSArPSB3aW4uc2Nyb2xsWTtcbiAgICAgICAgICBvZmZzZXRbMV0gKz0gd2luLnNjcm9sbFg7XG4gICAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGNvbnN0IGhlaWdodCA9IGRpbWVuc2lvbignaGVpZ2h0Jyk7XG4gICAgY29uc3Qgd2lkdGggPSBkaW1lbnNpb24oJ3dpZHRoJyk7XG5cbiAgICBmdW5jdGlvbiBkaW1lbnNpb24ocHJvcCkge1xuICAgICAgY29uc3QgcHJvcE5hbWUgPSB1Y2ZpcnN0KHByb3ApO1xuICAgICAgcmV0dXJuIChlbGVtZW50LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGlzV2luZG93KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudFtcImlubmVyXCIgKyBwcm9wTmFtZV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzRG9jdW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IGVsZW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGRvY1tcIm9mZnNldFwiICsgcHJvcE5hbWVdLCBkb2NbXCJzY3JvbGxcIiArIHByb3BOYW1lXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcblxuICAgICAgICAgIHZhbHVlID0gY3NzKGVsZW1lbnQsIHByb3ApO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICdhdXRvJyA/IGVsZW1lbnRbXCJvZmZzZXRcIiArIHByb3BOYW1lXSA6IHRvRmxvYXQodmFsdWUpIHx8IDA7XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWUgLSBib3hNb2RlbEFkanVzdChlbGVtZW50LCBwcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3NzKFxuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgcHJvcCxcbiAgICAgICAgICAhdmFsdWUgJiYgdmFsdWUgIT09IDAgPyAnJyA6ICt2YWx1ZSArIGJveE1vZGVsQWRqdXN0KGVsZW1lbnQsIHByb3ApICsgJ3B4Jyk7XG5cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBib3hNb2RlbEFkanVzdChlbGVtZW50LCBwcm9wLCBzaXppbmcpIHtpZiAoc2l6aW5nID09PSB2b2lkIDApIHtzaXppbmcgPSAnYm9yZGVyLWJveCc7fVxuICAgICAgcmV0dXJuIGNzcyhlbGVtZW50LCAnYm94U2l6aW5nJykgPT09IHNpemluZyA/XG4gICAgICBkaXJzJDFbcHJvcF0uXG4gICAgICBtYXAodWNmaXJzdCkuXG4gICAgICByZWR1Y2UoXG4gICAgICAodmFsdWUsIHByb3ApID0+XG4gICAgICB2YWx1ZSArXG4gICAgICB0b0Zsb2F0KGNzcyhlbGVtZW50LCBcInBhZGRpbmdcIiArIHByb3ApKSArXG4gICAgICB0b0Zsb2F0KGNzcyhlbGVtZW50LCBcImJvcmRlclwiICsgcHJvcCArIFwiV2lkdGhcIikpLFxuICAgICAgMCkgOlxuXG4gICAgICAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZsaXBQb3NpdGlvbihwb3MpIHtcbiAgICAgIGZvciAoY29uc3QgZGlyIGluIGRpcnMkMSkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gZGlycyQxW2Rpcl0pIHtcbiAgICAgICAgICBpZiAoZGlycyQxW2Rpcl1baV0gPT09IHBvcykge1xuICAgICAgICAgICAgcmV0dXJuIGRpcnMkMVtkaXJdWzEgLSBpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9QeCh2YWx1ZSwgcHJvcGVydHksIGVsZW1lbnQsIG9mZnNldERpbSkge2lmIChwcm9wZXJ0eSA9PT0gdm9pZCAwKSB7cHJvcGVydHkgPSAnd2lkdGgnO31pZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7ZWxlbWVudCA9IHdpbmRvdzt9aWYgKG9mZnNldERpbSA9PT0gdm9pZCAwKSB7b2Zmc2V0RGltID0gZmFsc2U7fVxuICAgICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRvRmxvYXQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VDYWxjKHZhbHVlKS5yZWR1Y2UoKHJlc3VsdCwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdW5pdCA9IHBhcnNlVW5pdCh2YWx1ZSk7XG4gICAgICAgIGlmICh1bml0KSB7XG4gICAgICAgICAgdmFsdWUgPSBwZXJjZW50KFxuICAgICAgICAgIHVuaXQgPT09ICd2aCcgP1xuICAgICAgICAgIGhlaWdodCh0b1dpbmRvdyhlbGVtZW50KSkgOlxuICAgICAgICAgIHVuaXQgPT09ICd2dycgP1xuICAgICAgICAgIHdpZHRoKHRvV2luZG93KGVsZW1lbnQpKSA6XG4gICAgICAgICAgb2Zmc2V0RGltID9cbiAgICAgICAgICBlbGVtZW50W1wib2Zmc2V0XCIgKyB1Y2ZpcnN0KHByb3BlcnR5KV0gOlxuICAgICAgICAgIGRpbWVuc2lvbnMkMShlbGVtZW50KVtwcm9wZXJ0eV0sXG4gICAgICAgICAgdmFsdWUpO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgdG9GbG9hdCh2YWx1ZSk7XG4gICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYWxjUmUgPSAvLT9cXGQrKD86XFwuXFxkKyk/KD86dlt3aF18JXxweCk/L2c7XG4gICAgY29uc3QgcGFyc2VDYWxjID0gbWVtb2l6ZSgoY2FsYykgPT4gY2FsYy50b1N0cmluZygpLnJlcGxhY2UoL1xccy9nLCAnJykubWF0Y2goY2FsY1JlKSB8fCBbXSk7XG4gICAgY29uc3QgdW5pdFJlJDEgPSAvKD86dltod118JSkkLztcbiAgICBjb25zdCBwYXJzZVVuaXQgPSBtZW1vaXplKChzdHIpID0+IChzdHIubWF0Y2godW5pdFJlJDEpIHx8IFtdKVswXSk7XG5cbiAgICBmdW5jdGlvbiBwZXJjZW50KGJhc2UsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZSAqIHRvRmxvYXQodmFsdWUpIC8gMTAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWR5KGZuKSB7XG4gICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb25jZShkb2N1bWVudCwgJ0RPTUNvbnRlbnRMb2FkZWQnLCBmbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNUYWcoZWxlbWVudCwgdGFnTmFtZSkge3ZhciBfZWxlbWVudCR0YWdOYW1lO1xuICAgICAgcmV0dXJuIChlbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiAoX2VsZW1lbnQkdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JHRhZ05hbWUudG9Mb3dlckNhc2UoKSkgPT09IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbXB0eShlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gJChlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodG1sKHBhcmVudCwgaHRtbCkge1xuICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGh0bWwpID8gJChwYXJlbnQpLmlubmVySFRNTCA6IGFwcGVuZChlbXB0eShwYXJlbnQpLCBodG1sKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmVwZW5kID0gYXBwbHlGbigncHJlcGVuZCcpO1xuICAgIGNvbnN0IGFwcGVuZCA9IGFwcGx5Rm4oJ2FwcGVuZCcpO1xuICAgIGNvbnN0IGJlZm9yZSA9IGFwcGx5Rm4oJ2JlZm9yZScpO1xuICAgIGNvbnN0IGFmdGVyID0gYXBwbHlGbignYWZ0ZXInKTtcblxuICAgIGZ1bmN0aW9uIGFwcGx5Rm4oZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAocmVmLCBlbGVtZW50KSB7dmFyIF8kO1xuICAgICAgICBjb25zdCBub2RlcyA9IHRvTm9kZXMoaXNTdHJpbmcoZWxlbWVudCkgPyBmcmFnbWVudChlbGVtZW50KSA6IGVsZW1lbnQpO1xuICAgICAgICAoXyQgPSAkKHJlZikpID09IG51bGwgPyB2b2lkIDAgOiBfJFtmbl0oLi4ubm9kZXMpO1xuICAgICAgICByZXR1cm4gdW53cmFwU2luZ2xlKG5vZGVzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlJDEoZWxlbWVudCkge1xuICAgICAgdG9Ob2RlcyhlbGVtZW50KS5mb3JFYWNoKChlbGVtZW50KSA9PiBlbGVtZW50LnJlbW92ZSgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwQWxsKGVsZW1lbnQsIHN0cnVjdHVyZSkge1xuICAgICAgc3RydWN0dXJlID0gdG9Ob2RlKGJlZm9yZShlbGVtZW50LCBzdHJ1Y3R1cmUpKTtcblxuICAgICAgd2hpbGUgKHN0cnVjdHVyZS5maXJzdENoaWxkKSB7XG4gICAgICAgIHN0cnVjdHVyZSA9IHN0cnVjdHVyZS5maXJzdENoaWxkO1xuICAgICAgfVxuXG4gICAgICBhcHBlbmQoc3RydWN0dXJlLCBlbGVtZW50KTtcblxuICAgICAgcmV0dXJuIHN0cnVjdHVyZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwSW5uZXIoZWxlbWVudCwgc3RydWN0dXJlKSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhcbiAgICAgIHRvTm9kZXMoZWxlbWVudCkubWFwKChlbGVtZW50KSA9PlxuICAgICAgZWxlbWVudC5oYXNDaGlsZE5vZGVzKCkgP1xuICAgICAgd3JhcEFsbCh0b05vZGVzKGVsZW1lbnQuY2hpbGROb2RlcyksIHN0cnVjdHVyZSkgOlxuICAgICAgYXBwZW5kKGVsZW1lbnQsIHN0cnVjdHVyZSkpKTtcblxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW53cmFwKGVsZW1lbnQpIHtcbiAgICAgIHRvTm9kZXMoZWxlbWVudCkuXG4gICAgICBtYXAocGFyZW50KS5cbiAgICAgIGZpbHRlcigodmFsdWUsIGluZGV4LCBzZWxmKSA9PiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleCkuXG4gICAgICBmb3JFYWNoKChwYXJlbnQpID0+IHBhcmVudC5yZXBsYWNlV2l0aCguLi5wYXJlbnQuY2hpbGROb2RlcykpO1xuICAgIH1cblxuICAgIGNvbnN0IGZyYWdtZW50UmUgPSAvXlxccyo8KFxcdyt8ISlbXj5dKj4vO1xuICAgIGNvbnN0IHNpbmdsZVRhZ1JlID0gL148KFxcdyspXFxzKlxcLz8+KD86PFxcL1xcMT4pPyQvO1xuXG4gICAgZnVuY3Rpb24gZnJhZ21lbnQoaHRtbCkge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IHNpbmdsZVRhZ1JlLmV4ZWMoaHRtbCk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChtYXRjaGVzWzFdKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBpZiAoZnJhZ21lbnRSZS50ZXN0KGh0bWwpKSB7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGh0bWwudHJpbSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci50ZXh0Q29udGVudCA9IGh0bWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bndyYXBTaW5nbGUoY29udGFpbmVyLmNoaWxkTm9kZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVud3JhcFNpbmdsZShub2Rlcykge1xuICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDEgPyBub2RlcyA6IG5vZGVzWzBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5KG5vZGUsIGZuKSB7XG4gICAgICBpZiAoIWlzRWxlbWVudChub2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZuKG5vZGUpO1xuICAgICAgbm9kZSA9IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIGFwcGx5KG5vZGUsIGZuKTtcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJChzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGlzSHRtbChzZWxlY3RvcikgPyB0b05vZGUoZnJhZ21lbnQoc2VsZWN0b3IpKSA6IGZpbmQoc2VsZWN0b3IsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gaXNIdG1sKHNlbGVjdG9yKSA/IHRvTm9kZXMoZnJhZ21lbnQoc2VsZWN0b3IpKSA6IGZpbmRBbGwoc2VsZWN0b3IsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSHRtbChzdHIpIHtcbiAgICAgIHJldHVybiBpc1N0cmluZyhzdHIpICYmIHN0YXJ0c1dpdGgoc3RyLnRyaW0oKSwgJzwnKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbiAgICBjb25zdCBpc1J0bCA9IGluQnJvd3NlciAmJiBhdHRyKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ2RpcicpID09PSAncnRsJztcblxuICAgIGNvbnN0IGhhc1RvdWNoID0gaW5Ccm93c2VyICYmICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcbiAgICBjb25zdCBoYXNQb2ludGVyRXZlbnRzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5Qb2ludGVyRXZlbnQ7XG5cbiAgICBjb25zdCBwb2ludGVyRG93biQxID0gaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVyZG93bicgOiBoYXNUb3VjaCA/ICd0b3VjaHN0YXJ0JyA6ICdtb3VzZWRvd24nO1xuICAgIGNvbnN0IHBvaW50ZXJNb3ZlJDEgPSBoYXNQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJtb3ZlJyA6IGhhc1RvdWNoID8gJ3RvdWNobW92ZScgOiAnbW91c2Vtb3ZlJztcbiAgICBjb25zdCBwb2ludGVyVXAkMSA9IGhhc1BvaW50ZXJFdmVudHMgPyAncG9pbnRlcnVwJyA6IGhhc1RvdWNoID8gJ3RvdWNoZW5kJyA6ICdtb3VzZXVwJztcbiAgICBjb25zdCBwb2ludGVyRW50ZXIgPSBoYXNQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJlbnRlcicgOiBoYXNUb3VjaCA/ICcnIDogJ21vdXNlZW50ZXInO1xuICAgIGNvbnN0IHBvaW50ZXJMZWF2ZSA9IGhhc1BvaW50ZXJFdmVudHMgPyAncG9pbnRlcmxlYXZlJyA6IGhhc1RvdWNoID8gJycgOiAnbW91c2VsZWF2ZSc7XG4gICAgY29uc3QgcG9pbnRlckNhbmNlbCA9IGhhc1BvaW50ZXJFdmVudHMgPyAncG9pbnRlcmNhbmNlbCcgOiAndG91Y2hjYW5jZWwnO1xuXG4gICAgLypcbiAgICAgICAgQmFzZWQgb246XG4gICAgICAgIENvcHlyaWdodCAoYykgMjAxNiBXaWxzb24gUGFnZSB3aWxzb25wYWdlQG1lLmNvbVxuICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vd2lsc29ucGFnZS9mYXN0ZG9tXG4gICAgKi9cblxuICAgIGNvbnN0IGZhc3Rkb20gPSB7XG4gICAgICByZWFkczogW10sXG4gICAgICB3cml0ZXM6IFtdLFxuXG4gICAgICByZWFkKHRhc2spIHtcbiAgICAgICAgdGhpcy5yZWFkcy5wdXNoKHRhc2spO1xuICAgICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgfSxcblxuICAgICAgd3JpdGUodGFzaykge1xuICAgICAgICB0aGlzLndyaXRlcy5wdXNoKHRhc2spO1xuICAgICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgfSxcblxuICAgICAgY2xlYXIodGFzaykge1xuICAgICAgICByZW1vdmUodGhpcy5yZWFkcywgdGFzayk7XG4gICAgICAgIHJlbW92ZSh0aGlzLndyaXRlcywgdGFzayk7XG4gICAgICB9LFxuXG4gICAgICBmbHVzaCB9O1xuXG5cbiAgICBmdW5jdGlvbiBmbHVzaChyZWN1cnNpb24pIHtcbiAgICAgIHJ1blRhc2tzKGZhc3Rkb20ucmVhZHMpO1xuICAgICAgcnVuVGFza3MoZmFzdGRvbS53cml0ZXMuc3BsaWNlKDApKTtcblxuICAgICAgZmFzdGRvbS5zY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGZhc3Rkb20ucmVhZHMubGVuZ3RoIHx8IGZhc3Rkb20ud3JpdGVzLmxlbmd0aCkge1xuICAgICAgICBzY2hlZHVsZUZsdXNoKHJlY3Vyc2lvbiArIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDQ7XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVGbHVzaChyZWN1cnNpb24pIHtcbiAgICAgIGlmIChmYXN0ZG9tLnNjaGVkdWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZhc3Rkb20uc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIGlmIChyZWN1cnNpb24gJiYgcmVjdXJzaW9uIDwgUkVDVVJTSU9OX0xJTUlUKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZmx1c2gocmVjdXJzaW9uKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gZmx1c2goMSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1blRhc2tzKHRhc2tzKSB7XG4gICAgICBsZXQgdGFzaztcbiAgICAgIHdoaWxlICh0YXNrID0gdGFza3Muc2hpZnQoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIGl0ZW0pIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICAgIHJldHVybiB+aW5kZXggJiYgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNb3VzZVRyYWNrZXIoKSB7fVxuXG4gICAgTW91c2VUcmFja2VyLnByb3RvdHlwZSA9IHtcbiAgICAgIHBvc2l0aW9uczogW10sXG5cbiAgICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gW107XG5cbiAgICAgICAgbGV0IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLnVuYmluZCA9IG9uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgKGUpID0+IHBvc2l0aW9uID0gZ2V0RXZlbnRQb3MoZSkpO1xuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9ucy5sZW5ndGggPiA1KSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTApO1xuICAgICAgfSxcblxuICAgICAgY2FuY2VsKCkge3ZhciBfdGhpcyR1bmJpbmQ7XG4gICAgICAgIChfdGhpcyR1bmJpbmQgPSB0aGlzLnVuYmluZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHVuYmluZC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmludGVydmFsICYmIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICB9LFxuXG4gICAgICBtb3Zlc1RvKHRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbnMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHAgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH0gPSBwO1xuXG4gICAgICAgIGNvbnN0IFtwcmV2UG9zaXRpb25dID0gdGhpcy5wb3NpdGlvbnM7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbGFzdCh0aGlzLnBvc2l0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBbcHJldlBvc2l0aW9uLCBwb3NpdGlvbl07XG5cbiAgICAgICAgaWYgKHBvaW50SW5SZWN0KHBvc2l0aW9uLCBwKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRpYWdvbmFscyA9IFtcbiAgICAgICAgW1xuICAgICAgICB7IHg6IGxlZnQsIHk6IHRvcCB9LFxuICAgICAgICB7IHg6IHJpZ2h0LCB5OiBib3R0b20gfV0sXG5cbiAgICAgICAgW1xuICAgICAgICB7IHg6IGxlZnQsIHk6IGJvdHRvbSB9LFxuICAgICAgICB7IHg6IHJpZ2h0LCB5OiB0b3AgfV1dO1xuXG5cblxuICAgICAgICByZXR1cm4gZGlhZ29uYWxzLnNvbWUoKGRpYWdvbmFsKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0KHBhdGgsIGRpYWdvbmFsKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uICYmIHBvaW50SW5SZWN0KGludGVyc2VjdGlvbiwgcCk7XG4gICAgICAgIH0pO1xuICAgICAgfSB9O1xuXG5cbiAgICAvLyBJbnNwaXJlZCBieSBodHRwOi8vcGF1bGJvdXJrZS5uZXQvZ2VvbWV0cnkvcG9pbnRsaW5lcGxhbmUvXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0KF9yZWYsIF9yZWYyKSB7bGV0IFt7IHg6IHgxLCB5OiB5MSB9LCB7IHg6IHgyLCB5OiB5MiB9XSA9IF9yZWY7bGV0IFt7IHg6IHgzLCB5OiB5MyB9LCB7IHg6IHg0LCB5OiB5NCB9XSA9IF9yZWYyO1xuICAgICAgY29uc3QgZGVub21pbmF0b3IgPSAoeTQgLSB5MykgKiAoeDIgLSB4MSkgLSAoeDQgLSB4MykgKiAoeTIgLSB5MSk7XG5cbiAgICAgIC8vIExpbmVzIGFyZSBwYXJhbGxlbFxuICAgICAgaWYgKGRlbm9taW5hdG9yID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdWEgPSAoKHg0IC0geDMpICogKHkxIC0geTMpIC0gKHk0IC0geTMpICogKHgxIC0geDMpKSAvIGRlbm9taW5hdG9yO1xuXG4gICAgICBpZiAodWEgPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAgIHJldHVybiB7IHg6IHgxICsgdWEgKiAoeDIgLSB4MSksIHk6IHkxICsgdWEgKiAoeTIgLSB5MSkgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvYnNlcnZlSW50ZXJzZWN0aW9uKHRhcmdldHMsIGNiLCBvcHRpb25zLCBpbnRlcnNlY3RpbmcpIHtpZiAoaW50ZXJzZWN0aW5nID09PSB2b2lkIDApIHtpbnRlcnNlY3RpbmcgPSB0cnVlO31cbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgICAgaW50ZXJzZWN0aW5nID9cbiAgICAgIChlbnRyaWVzLCBvYnNlcnZlcikgPT4ge1xuICAgICAgICBpZiAoZW50cmllcy5zb21lKChlbnRyeSkgPT4gZW50cnkuaXNJbnRlcnNlY3RpbmcpKSB7XG4gICAgICAgICAgY2IoZW50cmllcywgb2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICB9IDpcbiAgICAgIGNiLFxuICAgICAgb3B0aW9ucyk7XG5cbiAgICAgIGZvciAoY29uc3QgZWwgb2YgdG9Ob2Rlcyh0YXJnZXRzKSkge1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cblxuICAgIGNvbnN0IGhhc1Jlc2l6ZU9ic2VydmVyID0gaW5Ccm93c2VyICYmIHdpbmRvdy5SZXNpemVPYnNlcnZlcjtcbiAgICBmdW5jdGlvbiBvYnNlcnZlUmVzaXplKHRhcmdldHMsIGNiLCBvcHRpb25zKSB7aWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge29wdGlvbnMgPSB7IGJveDogJ2JvcmRlci1ib3gnIH07fVxuICAgICAgaWYgKGhhc1Jlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZlKFJlc2l6ZU9ic2VydmVyLCB0YXJnZXRzLCBjYiwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZhbGxiYWNrIFNhZmFyaSA8IDEzLjFcbiAgICAgIGluaXRSZXNpemVMaXN0ZW5lcigpO1xuICAgICAgbGlzdGVuZXJzLmFkZChjYik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShjYik7XG4gICAgICAgIH0gfTtcblxuICAgIH1cblxuICAgIGxldCBsaXN0ZW5lcnM7XG4gICAgZnVuY3Rpb24gaW5pdFJlc2l6ZUxpc3RlbmVyKCkge1xuICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IG5ldyBTZXQoKTtcblxuICAgICAgLy8gdGhyb3R0bGUgJ3Jlc2l6ZSdcbiAgICAgIGxldCBwZW5kaW5nUmVzaXplO1xuICAgICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICBpZiAocGVuZGluZ1Jlc2l6ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nUmVzaXplID0gdHJ1ZTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHBlbmRpbmdSZXNpemUgPSBmYWxzZSk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgb24od2luZG93LCAnbG9hZCByZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgb24oZG9jdW1lbnQsICdsb2FkZWRtZXRhZGF0YSBsb2FkJywgaGFuZGxlUmVzaXplLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvYnNlcnZlTXV0YXRpb24odGFyZ2V0cywgY2IsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvYnNlcnZlKE11dGF0aW9uT2JzZXJ2ZXIsIHRhcmdldHMsIGNiLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvYnNlcnZlKE9ic2VydmVyLCB0YXJnZXRzLCBjYiwgb3B0aW9ucykge1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXIoY2IpO1xuICAgICAgZm9yIChjb25zdCBlbCBvZiB0b05vZGVzKHRhcmdldHMpKSB7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWwsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyYXRzID0ge307XG5cbiAgICBzdHJhdHMuZXZlbnRzID1cbiAgICBzdHJhdHMuY3JlYXRlZCA9XG4gICAgc3RyYXRzLmJlZm9yZUNvbm5lY3QgPVxuICAgIHN0cmF0cy5jb25uZWN0ZWQgPVxuICAgIHN0cmF0cy5iZWZvcmVEaXNjb25uZWN0ID1cbiAgICBzdHJhdHMuZGlzY29ubmVjdGVkID1cbiAgICBzdHJhdHMuZGVzdHJveSA9XG4gICAgY29uY2F0U3RyYXQ7XG5cbiAgICAvLyBhcmdzIHN0cmF0ZWd5XG4gICAgc3RyYXRzLmFyZ3MgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsICE9PSBmYWxzZSAmJiBjb25jYXRTdHJhdChjaGlsZFZhbCB8fCBwYXJlbnRWYWwpO1xuICAgIH07XG5cbiAgICAvLyB1cGRhdGUgc3RyYXRlZ3lcbiAgICBzdHJhdHMudXBkYXRlID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBzb3J0QnkkMShcbiAgICAgIGNvbmNhdFN0cmF0KHBhcmVudFZhbCwgaXNGdW5jdGlvbihjaGlsZFZhbCkgPyB7IHJlYWQ6IGNoaWxkVmFsIH0gOiBjaGlsZFZhbCksXG4gICAgICAnb3JkZXInKTtcblxuICAgIH07XG5cbiAgICAvLyBwcm9wZXJ0eSBzdHJhdGVneVxuICAgIHN0cmF0cy5wcm9wcyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICBpZiAoaXNBcnJheShjaGlsZFZhbCkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgY2hpbGRWYWwpIHtcbiAgICAgICAgICB2YWx1ZVtrZXldID0gU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkVmFsID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJhdHMubWV0aG9kcyhwYXJlbnRWYWwsIGNoaWxkVmFsKTtcbiAgICB9O1xuXG4gICAgLy8gZXh0ZW5kIHN0cmF0ZWd5XG4gICAgc3RyYXRzLmNvbXB1dGVkID0gc3RyYXRzLm1ldGhvZHMgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsID8gcGFyZW50VmFsID8geyAuLi5wYXJlbnRWYWwsIC4uLmNoaWxkVmFsIH0gOiBjaGlsZFZhbCA6IHBhcmVudFZhbDtcbiAgICB9O1xuXG4gICAgLy8gZGF0YSBzdHJhdGVneVxuICAgIHN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gICAgICBpZiAoIXZtKSB7XG4gICAgICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50VmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGRWYWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZtKSB7XG4gICAgICAgICAgcmV0dXJuIG1lcmdlRm5EYXRhKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lcmdlRm5EYXRhKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWVyZ2VGbkRhdGEocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgICAgIHJldHVybiBzdHJhdHMuY29tcHV0ZWQoXG4gICAgICBpc0Z1bmN0aW9uKHBhcmVudFZhbCkgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pIDogcGFyZW50VmFsLFxuICAgICAgaXNGdW5jdGlvbihjaGlsZFZhbCkgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSkgOiBjaGlsZFZhbCk7XG5cbiAgICB9XG5cbiAgICAvLyBjb25jYXQgc3RyYXRlZ3lcbiAgICBmdW5jdGlvbiBjb25jYXRTdHJhdChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICBwYXJlbnRWYWwgPSBwYXJlbnRWYWwgJiYgIWlzQXJyYXkocGFyZW50VmFsKSA/IFtwYXJlbnRWYWxdIDogcGFyZW50VmFsO1xuXG4gICAgICByZXR1cm4gY2hpbGRWYWwgP1xuICAgICAgcGFyZW50VmFsID9cbiAgICAgIHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpIDpcbiAgICAgIGlzQXJyYXkoY2hpbGRWYWwpID9cbiAgICAgIGNoaWxkVmFsIDpcbiAgICAgIFtjaGlsZFZhbF0gOlxuICAgICAgcGFyZW50VmFsO1xuICAgIH1cblxuICAgIC8vIGRlZmF1bHQgc3RyYXRlZ3lcbiAgICBmdW5jdGlvbiBkZWZhdWx0U3RyYXQocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGNoaWxkVmFsKSA/IHBhcmVudFZhbCA6IGNoaWxkVmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLCB2bSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGQuZXh0ZW5kcykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBtaXhpbiBvZiBjaGlsZC5taXhpbnMpIHtcbiAgICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBtaXhpbiwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmVudCkge1xuICAgICAgICBtZXJnZUtleShrZXkpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZCkge1xuICAgICAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgICAgICBtZXJnZUtleShrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1lcmdlS2V5KGtleSkge1xuICAgICAgICBvcHRpb25zW2tleV0gPSAoc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0KShwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9wdGlvbnMob3B0aW9ucywgYXJncykge2lmIChhcmdzID09PSB2b2lkIDApIHthcmdzID0gW107fVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMgP1xuICAgICAgICBzdGFydHNXaXRoKG9wdGlvbnMsICd7JykgP1xuICAgICAgICBKU09OLnBhcnNlKG9wdGlvbnMpIDpcbiAgICAgICAgYXJncy5sZW5ndGggJiYgIWluY2x1ZGVzKG9wdGlvbnMsICc6JykgP1xuICAgICAgICB7IFthcmdzWzBdXTogb3B0aW9ucyB9IDpcbiAgICAgICAgb3B0aW9ucy5zcGxpdCgnOycpLnJlZHVjZSgob3B0aW9ucywgb3B0aW9uKSA9PiB7XG4gICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gb3B0aW9uLnNwbGl0KC86KC4qKS8pO1xuICAgICAgICAgIGlmIChrZXkgJiYgIWlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgb3B0aW9uc1trZXkudHJpbSgpXSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgIH0sIHt9KSA6XG4gICAgICAgIHt9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGxheShlbCkge1xuICAgICAgaWYgKGlzSUZyYW1lKGVsKSkge1xuICAgICAgICBjYWxsKGVsLCB7IGZ1bmM6ICdwbGF5VmlkZW8nLCBtZXRob2Q6ICdwbGF5JyB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSFRNTDUoZWwpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZWwucGxheSgpLmNhdGNoKG5vb3ApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGF1c2UoZWwpIHtcbiAgICAgIGlmIChpc0lGcmFtZShlbCkpIHtcbiAgICAgICAgY2FsbChlbCwgeyBmdW5jOiAncGF1c2VWaWRlbycsIG1ldGhvZDogJ3BhdXNlJyB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSFRNTDUoZWwpKSB7XG4gICAgICAgIGVsLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXV0ZShlbCkge1xuICAgICAgaWYgKGlzSUZyYW1lKGVsKSkge1xuICAgICAgICBjYWxsKGVsLCB7IGZ1bmM6ICdtdXRlJywgbWV0aG9kOiAnc2V0Vm9sdW1lJywgdmFsdWU6IDAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0hUTUw1KGVsKSkge1xuICAgICAgICBlbC5tdXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWaWRlbyhlbCkge1xuICAgICAgcmV0dXJuIGlzSFRNTDUoZWwpIHx8IGlzSUZyYW1lKGVsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0hUTUw1KGVsKSB7XG4gICAgICByZXR1cm4gaXNUYWcoZWwsICd2aWRlbycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSUZyYW1lKGVsKSB7XG4gICAgICByZXR1cm4gaXNUYWcoZWwsICdpZnJhbWUnKSAmJiAoaXNZb3V0dWJlKGVsKSB8fCBpc1ZpbWVvKGVsKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNZb3V0dWJlKGVsKSB7XG4gICAgICByZXR1cm4gISFlbC5zcmMubWF0Y2goXG4gICAgICAvXFwvXFwvLio/eW91dHViZSgtbm9jb29raWUpP1xcLlthLXpdK1xcLyh3YXRjaFxcP3Y9W14mXFxzXSt8ZW1iZWQpfHlvdXR1XFwuYmVcXC8uKi8pO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWaW1lbyhlbCkge1xuICAgICAgcmV0dXJuICEhZWwuc3JjLm1hdGNoKC92aW1lb1xcLmNvbVxcL3ZpZGVvXFwvLiovKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjYWxsKGVsLCBjbWQpIHtcbiAgICAgIGF3YWl0IGVuYWJsZUFwaShlbCk7XG4gICAgICBwb3N0KGVsLCBjbWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3QoZWwsIGNtZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWwuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7IGV2ZW50OiAnY29tbWFuZCcsIC4uLmNtZCB9KSwgJyonKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlS2V5ID0gJ191a1BsYXllcic7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGZ1bmN0aW9uIGVuYWJsZUFwaShlbCkge1xuICAgICAgaWYgKGVsW3N0YXRlS2V5XSkge1xuICAgICAgICByZXR1cm4gZWxbc3RhdGVLZXldO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB5b3V0dWJlID0gaXNZb3V0dWJlKGVsKTtcbiAgICAgIGNvbnN0IHZpbWVvID0gaXNWaW1lbyhlbCk7XG5cbiAgICAgIGNvbnN0IGlkID0gKytjb3VudGVyO1xuICAgICAgbGV0IHBvbGxlcjtcblxuICAgICAgcmV0dXJuIGVsW3N0YXRlS2V5XSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHlvdXR1YmUgJiZcbiAgICAgICAgb25jZShlbCwgJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiBwb3N0KGVsLCB7IGV2ZW50OiAnbGlzdGVuaW5nJywgaWQgfSk7XG4gICAgICAgICAgcG9sbGVyID0gc2V0SW50ZXJ2YWwobGlzdGVuZXIsIDEwMCk7XG4gICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb25jZSh3aW5kb3csICdtZXNzYWdlJywgcmVzb2x2ZSwgZmFsc2UsIChfcmVmKSA9PiB7bGV0IHsgZGF0YSB9ID0gX3JlZjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBkYXRhICYmIChcbiAgICAgICAgICAgICAgeW91dHViZSAmJiBkYXRhLmlkID09PSBpZCAmJiBkYXRhLmV2ZW50ID09PSAnb25SZWFkeScgfHxcbiAgICAgICAgICAgICAgdmltZW8gJiYgTnVtYmVyKGRhdGEucGxheWVyX2lkKSA9PT0gaWQpKTtcblxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVsLnNyYyA9IFwiXCIgKyBlbC5zcmMgKyAoaW5jbHVkZXMoZWwuc3JjLCAnPycpID8gJyYnIDogJz8nKSArIChcbiAgICAgICAgeW91dHViZSA/ICdlbmFibGVqc2FwaT0xJyA6IFwiYXBpPTEmcGxheWVyX2lkPVwiICsgaWQpO1xuXG4gICAgICB9KS50aGVuKCgpID0+IGNsZWFySW50ZXJ2YWwocG9sbGVyKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJblZpZXcoZWxlbWVudCwgb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0KSB7aWYgKG9mZnNldFRvcCA9PT0gdm9pZCAwKSB7b2Zmc2V0VG9wID0gMDt9aWYgKG9mZnNldExlZnQgPT09IHZvaWQgMCkge29mZnNldExlZnQgPSAwO31cbiAgICAgIGlmICghaXNWaXNpYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGludGVyc2VjdFJlY3QoXG4gICAgICAuLi5zY3JvbGxQYXJlbnRzKGVsZW1lbnQpLlxuICAgICAgbWFwKChwYXJlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfSA9IG9mZnNldFZpZXdwb3J0KHBhcmVudCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6IHRvcCAtIG9mZnNldFRvcCxcbiAgICAgICAgICBsZWZ0OiBsZWZ0IC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgICBib3R0b206IGJvdHRvbSArIG9mZnNldFRvcCxcbiAgICAgICAgICByaWdodDogcmlnaHQgKyBvZmZzZXRMZWZ0IH07XG5cbiAgICAgIH0pLlxuICAgICAgY29uY2F0KG9mZnNldChlbGVtZW50KSkpO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoZWxlbWVudCwgX3RlbXApIHtsZXQgeyBvZmZzZXQ6IG9mZnNldEJ5ID0gMCB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gICAgICBjb25zdCBwYXJlbnRzID0gaXNWaXNpYmxlKGVsZW1lbnQpID8gc2Nyb2xsUGFyZW50cyhlbGVtZW50KSA6IFtdO1xuICAgICAgcmV0dXJuIHBhcmVudHMucmVkdWNlKFxuICAgICAgKGZuLCBzY3JvbGxFbGVtZW50LCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQsIG9mZnNldEhlaWdodCB9ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBvZmZzZXRWaWV3cG9ydChzY3JvbGxFbGVtZW50KTtcbiAgICAgICAgY29uc3QgbWF4U2Nyb2xsID0gc2Nyb2xsSGVpZ2h0IC0gdmlld3BvcnQuaGVpZ2h0O1xuICAgICAgICBjb25zdCB7IGhlaWdodDogZWxIZWlnaHQsIHRvcDogZWxUb3AgfSA9IHBhcmVudHNbaSAtIDFdID9cbiAgICAgICAgb2Zmc2V0Vmlld3BvcnQocGFyZW50c1tpIC0gMV0pIDpcbiAgICAgICAgb2Zmc2V0KGVsZW1lbnQpO1xuXG4gICAgICAgIGxldCB0b3AgPSBNYXRoLmNlaWwoZWxUb3AgLSB2aWV3cG9ydC50b3AgLSBvZmZzZXRCeSArIHNjcm9sbFRvcCk7XG5cbiAgICAgICAgaWYgKG9mZnNldEJ5ID4gMCAmJiBvZmZzZXRIZWlnaHQgPCBlbEhlaWdodCArIG9mZnNldEJ5KSB7XG4gICAgICAgICAgdG9wICs9IG9mZnNldEJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldEJ5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3AgPiBtYXhTY3JvbGwpIHtcbiAgICAgICAgICBvZmZzZXRCeSAtPSB0b3AgLSBtYXhTY3JvbGw7XG4gICAgICAgICAgdG9wID0gbWF4U2Nyb2xsO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcCA8IDApIHtcbiAgICAgICAgICBvZmZzZXRCeSAtPSB0b3A7XG4gICAgICAgICAgdG9wID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKSA9PiBzY3JvbGxUbyhzY3JvbGxFbGVtZW50LCB0b3AgLSBzY3JvbGxUb3ApLnRoZW4oZm4pO1xuICAgICAgfSxcbiAgICAgICgpID0+IFByb21pc2UucmVzb2x2ZSgpKSgpO1xuXG5cbiAgICAgIGZ1bmN0aW9uIHNjcm9sbFRvKGVsZW1lbnQsIHRvcCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICBjb25zdCBzY3JvbGwgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IGdldER1cmF0aW9uKE1hdGguYWJzKHRvcCkpO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgIChmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudCA9IGVhc2UoY2xhbXAoKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbikpO1xuXG4gICAgICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbCArIHRvcCAqIHBlcmNlbnQ7XG5cbiAgICAgICAgICAgIC8vIHNjcm9sbCBtb3JlIGlmIHdlIGhhdmUgbm90IHJlYWNoZWQgb3VyIGRlc3RpbmF0aW9uXG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMSkge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldER1cmF0aW9uKGRpc3QpIHtcbiAgICAgICAgcmV0dXJuIDQwICogTWF0aC5wb3coZGlzdCwgMC4zNzUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlYXNlKGspIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxlZE92ZXIoZWxlbWVudCwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge2lmIChzdGFydE9mZnNldCA9PT0gdm9pZCAwKSB7c3RhcnRPZmZzZXQgPSAwO31pZiAoZW5kT2Zmc2V0ID09PSB2b2lkIDApIHtlbmRPZmZzZXQgPSAwO31cbiAgICAgIGlmICghaXNWaXNpYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbc2Nyb2xsRWxlbWVudF0gPSBzY3JvbGxQYXJlbnRzKGVsZW1lbnQsIC9hdXRvfHNjcm9sbC8sIHRydWUpO1xuICAgICAgY29uc3QgeyBzY3JvbGxIZWlnaHQsIHNjcm9sbFRvcCB9ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgIGNvbnN0IHsgaGVpZ2h0OiB2aWV3cG9ydEhlaWdodCB9ID0gb2Zmc2V0Vmlld3BvcnQoc2Nyb2xsRWxlbWVudCk7XG4gICAgICBjb25zdCBtYXhTY3JvbGwgPSBzY3JvbGxIZWlnaHQgLSB2aWV3cG9ydEhlaWdodDtcbiAgICAgIGNvbnN0IGVsZW1lbnRPZmZzZXRUb3AgPSBvZmZzZXRQb3NpdGlvbihlbGVtZW50KVswXSAtIG9mZnNldFBvc2l0aW9uKHNjcm9sbEVsZW1lbnQpWzBdO1xuXG4gICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIGVsZW1lbnRPZmZzZXRUb3AgLSB2aWV3cG9ydEhlaWdodCArIHN0YXJ0T2Zmc2V0KTtcbiAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKG1heFNjcm9sbCwgZWxlbWVudE9mZnNldFRvcCArIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gZW5kT2Zmc2V0KTtcblxuICAgICAgcmV0dXJuIGNsYW1wKChzY3JvbGxUb3AgLSBzdGFydCkgLyAoZW5kIC0gc3RhcnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxQYXJlbnRzKGVsZW1lbnQsIG92ZXJmbG93UmUsIHNjcm9sbGFibGUpIHtpZiAob3ZlcmZsb3dSZSA9PT0gdm9pZCAwKSB7b3ZlcmZsb3dSZSA9IC9hdXRvfHNjcm9sbHxoaWRkZW58Y2xpcC87fWlmIChzY3JvbGxhYmxlID09PSB2b2lkIDApIHtzY3JvbGxhYmxlID0gZmFsc2U7fVxuICAgICAgY29uc3Qgc2Nyb2xsRWwgPSBzY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICBsZXQgYW5jZXN0b3JzID0gcGFyZW50cyhlbGVtZW50KS5yZXZlcnNlKCk7XG4gICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuc2xpY2UoYW5jZXN0b3JzLmluZGV4T2Yoc2Nyb2xsRWwpICsgMSk7XG5cbiAgICAgIGNvbnN0IGZpeGVkSW5kZXggPSBmaW5kSW5kZXgoYW5jZXN0b3JzLCAoZWwpID0+IGNzcyhlbCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpO1xuICAgICAgaWYgKH5maXhlZEluZGV4KSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5zbGljZShmaXhlZEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtzY3JvbGxFbF0uXG4gICAgICBjb25jYXQoXG4gICAgICBhbmNlc3RvcnMuZmlsdGVyKFxuICAgICAgKHBhcmVudCkgPT5cbiAgICAgIG92ZXJmbG93UmUudGVzdChjc3MocGFyZW50LCAnb3ZlcmZsb3cnKSkgJiYgKFxuICAgICAgIXNjcm9sbGFibGUgfHwgcGFyZW50LnNjcm9sbEhlaWdodCA+IG9mZnNldFZpZXdwb3J0KHBhcmVudCkuaGVpZ2h0KSkpLlxuXG5cbiAgICAgIHJldmVyc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRWaWV3cG9ydChzY3JvbGxFbGVtZW50KSB7XG4gICAgICBjb25zdCB3aW5kb3cgPSB0b1dpbmRvdyhzY3JvbGxFbGVtZW50KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZG9jdW1lbnQ6IHsgZG9jdW1lbnRFbGVtZW50IH0gfSA9XG4gICAgICB3aW5kb3c7XG4gICAgICBsZXQgdmlld3BvcnRFbGVtZW50ID1cbiAgICAgIHNjcm9sbEVsZW1lbnQgPT09IHNjcm9sbGluZ0VsZW1lbnQoc2Nyb2xsRWxlbWVudCkgPyB3aW5kb3cgOiBzY3JvbGxFbGVtZW50O1xuXG4gICAgICBjb25zdCB7IHZpc3VhbFZpZXdwb3J0IH0gPSB3aW5kb3c7XG4gICAgICBpZiAoaXNXaW5kb3codmlld3BvcnRFbGVtZW50KSAmJiB2aXN1YWxWaWV3cG9ydCkge1xuICAgICAgICBsZXQgeyBoZWlnaHQsIHdpZHRoLCBzY2FsZSwgcGFnZVRvcDogdG9wLCBwYWdlTGVmdDogbGVmdCB9ID0gdmlzdWFsVmlld3BvcnQ7XG4gICAgICAgIGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0ICogc2NhbGUpO1xuICAgICAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGggKiBzY2FsZSk7XG4gICAgICAgIHJldHVybiB7IGhlaWdodCwgd2lkdGgsIHRvcCwgbGVmdCwgYm90dG9tOiB0b3AgKyBoZWlnaHQsIHJpZ2h0OiBsZWZ0ICsgd2lkdGggfTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlY3QgPSBvZmZzZXQodmlld3BvcnRFbGVtZW50KTtcbiAgICAgIGZvciAobGV0IFtwcm9wLCBkaXIsIHN0YXJ0LCBlbmRdIG9mIFtcbiAgICAgIFsnd2lkdGgnLCAneCcsICdsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICBbJ2hlaWdodCcsICd5JywgJ3RvcCcsICdib3R0b20nXV0pXG4gICAgICB7XG4gICAgICAgIGlmIChpc1dpbmRvdyh2aWV3cG9ydEVsZW1lbnQpKSB7XG4gICAgICAgICAgLy8gaU9TIDEyIHJldHVybnMgPGJvZHk+IGFzIHNjcm9sbGluZ0VsZW1lbnRcbiAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQgPSBkb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdFtzdGFydF0gKz0gdG9GbG9hdChjc3Modmlld3BvcnRFbGVtZW50LCBcImJvcmRlci1cIiArIHN0YXJ0ICsgXCItd2lkdGhcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJlY3RbcHJvcF0gPSByZWN0W2Rpcl0gPSB2aWV3cG9ydEVsZW1lbnRbXCJjbGllbnRcIiArIHVjZmlyc3QocHJvcCldO1xuICAgICAgICByZWN0W2VuZF0gPSByZWN0W3Byb3BdICsgcmVjdFtzdGFydF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0b1dpbmRvdyhlbGVtZW50KS5kb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IGRpcnMgPSBbXG4gICAgWyd3aWR0aCcsICd4JywgJ2xlZnQnLCAncmlnaHQnXSxcbiAgICBbJ2hlaWdodCcsICd5JywgJ3RvcCcsICdib3R0b20nXV07XG5cblxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uQXQoZWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBhdHRhY2g6IHtcbiAgICAgICAgICBlbGVtZW50OiBbJ2xlZnQnLCAndG9wJ10sXG4gICAgICAgICAgdGFyZ2V0OiBbJ2xlZnQnLCAndG9wJ10sXG4gICAgICAgICAgLi4ub3B0aW9ucy5hdHRhY2ggfSxcblxuICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgcGxhY2VtZW50OiBbXSxcbiAgICAgICAgLi4ub3B0aW9ucyB9O1xuXG5cbiAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgIHRhcmdldCA9IFt0YXJnZXQsIHRhcmdldF07XG4gICAgICB9XG5cbiAgICAgIG9mZnNldChlbGVtZW50LCBnZXRQb3NpdGlvbihlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gYXR0YWNoVG8oZWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHsgYm91bmRhcnksIHZpZXdwb3J0T2Zmc2V0ID0gMCwgcGxhY2VtZW50IH0gPSBvcHRpb25zO1xuXG4gICAgICBsZXQgb2Zmc2V0UG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgIGZvciAoY29uc3QgW2ksIFtwcm9wLCwgc3RhcnQsIGVuZF1dIG9mIE9iamVjdC5lbnRyaWVzKGRpcnMpKSB7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnQkMSh0YXJnZXRbaV0sIHZpZXdwb3J0T2Zmc2V0LCBib3VuZGFyeSwgaSk7XG5cbiAgICAgICAgaWYgKGlzV2l0aGluKHBvc2l0aW9uLCB2aWV3cG9ydCwgaSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvZmZzZXRCeSA9IDA7XG5cbiAgICAgICAgLy8gRmxpcFxuICAgICAgICBpZiAocGxhY2VtZW50W2ldID09PSAnZmxpcCcpIHtcbiAgICAgICAgICBjb25zdCBhdHRhY2ggPSBvcHRpb25zLmF0dGFjaC50YXJnZXRbaV07XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIGF0dGFjaCA9PT0gZW5kICYmIHBvc2l0aW9uW2VuZF0gPD0gdmlld3BvcnRbZW5kXSB8fFxuICAgICAgICAgIGF0dGFjaCA9PT0gc3RhcnQgJiYgcG9zaXRpb25bc3RhcnRdID49IHZpZXdwb3J0W3N0YXJ0XSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvZmZzZXRCeSA9IGZsaXAoZWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zLCBpKVtzdGFydF0gLSBwb3NpdGlvbltzdGFydF07XG5cbiAgICAgICAgICBjb25zdCBzY3JvbGxBcmVhID0gZ2V0U2Nyb2xsQXJlYSh0YXJnZXRbaV0sIHZpZXdwb3J0T2Zmc2V0LCBpKTtcblxuICAgICAgICAgIGlmICghaXNXaXRoaW4oYXBwbHlPZmZzZXQocG9zaXRpb24sIG9mZnNldEJ5LCBpKSwgc2Nyb2xsQXJlYSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChpc1dpdGhpbihwb3NpdGlvbiwgc2Nyb2xsQXJlYSwgaSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlY3Vyc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1BvcyA9IGZsaXBBeGlzKGVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGlmIChuZXdQb3MgJiYgaXNXaXRoaW4obmV3UG9zLCBzY3JvbGxBcmVhLCAxIC0gaSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2hpZnRcbiAgICAgICAgfSBlbHNlIGlmIChwbGFjZW1lbnRbaV0gPT09ICdzaGlmdCcpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXREaW0gPSBvZmZzZXQodGFyZ2V0W2ldKTtcbiAgICAgICAgICBjb25zdCB7IG9mZnNldDogZWxPZmZzZXQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgb2Zmc2V0QnkgPVxuICAgICAgICAgIGNsYW1wKFxuICAgICAgICAgIGNsYW1wKHBvc2l0aW9uW3N0YXJ0XSwgdmlld3BvcnRbc3RhcnRdLCB2aWV3cG9ydFtlbmRdIC0gcG9zaXRpb25bcHJvcF0pLFxuICAgICAgICAgIHRhcmdldERpbVtzdGFydF0gLSBwb3NpdGlvbltwcm9wXSArIGVsT2Zmc2V0W2ldLFxuICAgICAgICAgIHRhcmdldERpbVtlbmRdIC0gZWxPZmZzZXRbaV0pIC1cbiAgICAgICAgICBwb3NpdGlvbltzdGFydF07XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXRQb3NpdGlvbiA9IGFwcGx5T2Zmc2V0KG9mZnNldFBvc2l0aW9uLCBvZmZzZXRCeSwgaSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdHRhY2hUbyhlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIGxldCB7IGF0dGFjaCwgb2Zmc2V0OiBvZmZzZXRCeSB9ID0ge1xuICAgICAgICBhdHRhY2g6IHtcbiAgICAgICAgICBlbGVtZW50OiBbJ2xlZnQnLCAndG9wJ10sXG4gICAgICAgICAgdGFyZ2V0OiBbJ2xlZnQnLCAndG9wJ10sXG4gICAgICAgICAgLi4ub3B0aW9ucy5hdHRhY2ggfSxcblxuICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgLi4ub3B0aW9ucyB9O1xuXG5cbiAgICAgIGxldCBlbE9mZnNldCA9IG9mZnNldChlbGVtZW50KTtcblxuICAgICAgZm9yIChjb25zdCBbaSwgW3Byb3AsLCBzdGFydCwgZW5kXV0gb2YgT2JqZWN0LmVudHJpZXMoZGlycykpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID1cbiAgICAgICAgYXR0YWNoLnRhcmdldFtpXSA9PT0gYXR0YWNoLmVsZW1lbnRbaV0gPyBvZmZzZXRWaWV3cG9ydCh0YXJnZXRbaV0pIDogb2Zmc2V0KHRhcmdldFtpXSk7XG5cbiAgICAgICAgZWxPZmZzZXQgPSBhcHBseU9mZnNldChcbiAgICAgICAgZWxPZmZzZXQsXG4gICAgICAgIHRhcmdldE9mZnNldFtzdGFydF0gLVxuICAgICAgICBlbE9mZnNldFtzdGFydF0gK1xuICAgICAgICBtb3ZlQnkoYXR0YWNoLnRhcmdldFtpXSwgZW5kLCB0YXJnZXRPZmZzZXRbcHJvcF0pIC1cbiAgICAgICAgbW92ZUJ5KGF0dGFjaC5lbGVtZW50W2ldLCBlbmQsIGVsT2Zmc2V0W3Byb3BdKSArXG4gICAgICAgICtvZmZzZXRCeVtpXSxcbiAgICAgICAgaSk7XG5cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbE9mZnNldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseU9mZnNldChwb3NpdGlvbiwgb2Zmc2V0LCBpKSB7XG4gICAgICBjb25zdCBbLCBkaXIsIHN0YXJ0LCBlbmRdID0gZGlyc1tpXTtcbiAgICAgIGNvbnN0IG5ld1BvcyA9IHsgLi4ucG9zaXRpb24gfTtcbiAgICAgIG5ld1Bvc1tzdGFydF0gPSBwb3NpdGlvbltkaXJdID0gcG9zaXRpb25bc3RhcnRdICsgb2Zmc2V0O1xuICAgICAgbmV3UG9zW2VuZF0gKz0gb2Zmc2V0O1xuICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3ZlQnkoYXR0YWNoLCBlbmQsIGRpbSkge1xuICAgICAgcmV0dXJuIGF0dGFjaCA9PT0gJ2NlbnRlcicgPyBkaW0gLyAyIDogYXR0YWNoID09PSBlbmQgPyBkaW0gOiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZpZXdwb3J0JDEoZWxlbWVudCwgdmlld3BvcnRPZmZzZXQsIGJvdW5kYXJ5LCBpKSB7XG4gICAgICBsZXQgdmlld3BvcnQgPSBnZXRJbnRlcnNlY3Rpb25BcmVhKC4uLnNjcm9sbFBhcmVudHMoZWxlbWVudCkubWFwKG9mZnNldFZpZXdwb3J0KSk7XG5cbiAgICAgIGlmICh2aWV3cG9ydE9mZnNldCkge1xuICAgICAgICB2aWV3cG9ydFtkaXJzW2ldWzJdXSArPSB2aWV3cG9ydE9mZnNldDtcbiAgICAgICAgdmlld3BvcnRbZGlyc1tpXVszXV0gLT0gdmlld3BvcnRPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChib3VuZGFyeSkge1xuICAgICAgICB2aWV3cG9ydCA9IGdldEludGVyc2VjdGlvbkFyZWEoXG4gICAgICAgIHZpZXdwb3J0LFxuICAgICAgICBvZmZzZXQoaXNBcnJheShib3VuZGFyeSkgPyBib3VuZGFyeVtpXSA6IGJvdW5kYXJ5KSk7XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZpZXdwb3J0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNjcm9sbEFyZWEoZWxlbWVudCwgdmlld3BvcnRPZmZzZXQsIGkpIHtcbiAgICAgIGNvbnN0IFtwcm9wLCwgc3RhcnQsIGVuZF0gPSBkaXJzW2ldO1xuICAgICAgY29uc3QgW3Njcm9sbEVsZW1lbnRdID0gc2Nyb2xsUGFyZW50cyhlbGVtZW50KTtcbiAgICAgIGNvbnN0IHZpZXdwb3J0ID0gb2Zmc2V0Vmlld3BvcnQoc2Nyb2xsRWxlbWVudCk7XG4gICAgICB2aWV3cG9ydFtzdGFydF0gLT0gc2Nyb2xsRWxlbWVudFtcInNjcm9sbFwiICsgdWNmaXJzdChzdGFydCldIC0gdmlld3BvcnRPZmZzZXQ7XG4gICAgICB2aWV3cG9ydFtlbmRdID0gdmlld3BvcnRbc3RhcnRdICsgc2Nyb2xsRWxlbWVudFtcInNjcm9sbFwiICsgdWNmaXJzdChwcm9wKV0gLSB2aWV3cG9ydE9mZnNldDtcbiAgICAgIHJldHVybiB2aWV3cG9ydDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25BcmVhKCkge1xuICAgICAgbGV0IGFyZWEgPSB7fTtmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVjdHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7cmVjdHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07fVxuICAgICAgZm9yIChjb25zdCByZWN0IG9mIHJlY3RzKSB7XG4gICAgICAgIGZvciAoY29uc3QgWywsIHN0YXJ0LCBlbmRdIG9mIGRpcnMpIHtcbiAgICAgICAgICBhcmVhW3N0YXJ0XSA9IE1hdGgubWF4KGFyZWFbc3RhcnRdIHx8IDAsIHJlY3Rbc3RhcnRdKTtcbiAgICAgICAgICBhcmVhW2VuZF0gPSBNYXRoLm1pbiguLi5bYXJlYVtlbmRdLCByZWN0W2VuZF1dLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzV2l0aGluKHBvc2l0aW9uQSwgcG9zaXRpb25CLCBpKSB7XG4gICAgICBjb25zdCBbLCwgc3RhcnQsIGVuZF0gPSBkaXJzW2ldO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uQVtzdGFydF0gPj0gcG9zaXRpb25CW3N0YXJ0XSAmJiBwb3NpdGlvbkFbZW5kXSA8PSBwb3NpdGlvbkJbZW5kXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbGlwKGVsZW1lbnQsIHRhcmdldCwgX3JlZiwgaSkge2xldCB7IG9mZnNldCwgYXR0YWNoIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIGF0dGFjaFRvKGVsZW1lbnQsIHRhcmdldCwge1xuICAgICAgICBhdHRhY2g6IHtcbiAgICAgICAgICBlbGVtZW50OiBmbGlwQXR0YWNoKGF0dGFjaC5lbGVtZW50LCBpKSxcbiAgICAgICAgICB0YXJnZXQ6IGZsaXBBdHRhY2goYXR0YWNoLnRhcmdldCwgaSkgfSxcblxuICAgICAgICBvZmZzZXQ6IGZsaXBPZmZzZXQob2Zmc2V0LCBpKSB9KTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZsaXBBeGlzKGVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGdldFBvc2l0aW9uKGVsZW1lbnQsIHRhcmdldCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBhdHRhY2g6IHtcbiAgICAgICAgICBlbGVtZW50OiBvcHRpb25zLmF0dGFjaC5lbGVtZW50Lm1hcChmbGlwQXR0YWNoQXhpcykucmV2ZXJzZSgpLFxuICAgICAgICAgIHRhcmdldDogb3B0aW9ucy5hdHRhY2gudGFyZ2V0Lm1hcChmbGlwQXR0YWNoQXhpcykucmV2ZXJzZSgpIH0sXG5cbiAgICAgICAgb2Zmc2V0OiBvcHRpb25zLm9mZnNldC5yZXZlcnNlKCksXG4gICAgICAgIHBsYWNlbWVudDogb3B0aW9ucy5wbGFjZW1lbnQucmV2ZXJzZSgpLFxuICAgICAgICByZWN1cnNpb246IHRydWUgfSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbGlwQXR0YWNoKGF0dGFjaCwgaSkge1xuICAgICAgY29uc3QgbmV3QXR0YWNoID0gWy4uLmF0dGFjaF07XG4gICAgICBjb25zdCBpbmRleCA9IGRpcnNbaV0uaW5kZXhPZihhdHRhY2hbaV0pO1xuICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICBuZXdBdHRhY2hbaV0gPSBkaXJzW2ldWzEgLSBpbmRleCAlIDIgKyAyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdBdHRhY2g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmxpcEF0dGFjaEF4aXMocHJvcCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGlyc1tpXS5pbmRleE9mKHByb3ApO1xuICAgICAgICBpZiAofmluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIGRpcnNbMSAtIGldW2luZGV4ICUgMiArIDJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmxpcE9mZnNldChvZmZzZXQsIGkpIHtcbiAgICAgIG9mZnNldCA9IFsuLi5vZmZzZXRdO1xuICAgICAgb2Zmc2V0W2ldICo9IC0xO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgdXRpbCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBhamF4OiBhamF4LFxuICAgICAgICBnZXRJbWFnZTogZ2V0SW1hZ2UsXG4gICAgICAgIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gICAgICAgIEFuaW1hdGlvbjogQW5pbWF0aW9uLFxuICAgICAgICBhdHRyOiBhdHRyLFxuICAgICAgICBoYXNBdHRyOiBoYXNBdHRyLFxuICAgICAgICByZW1vdmVBdHRyOiByZW1vdmVBdHRyLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBhZGRDbGFzczogYWRkQ2xhc3MsXG4gICAgICAgIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcbiAgICAgICAgcmVtb3ZlQ2xhc3NlczogcmVtb3ZlQ2xhc3NlcyxcbiAgICAgICAgcmVwbGFjZUNsYXNzOiByZXBsYWNlQ2xhc3MsXG4gICAgICAgIGhhc0NsYXNzOiBoYXNDbGFzcyxcbiAgICAgICAgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxuICAgICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zJDEsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgIG9mZnNldFBvc2l0aW9uOiBvZmZzZXRQb3NpdGlvbixcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgYm94TW9kZWxBZGp1c3Q6IGJveE1vZGVsQWRqdXN0LFxuICAgICAgICBmbGlwUG9zaXRpb246IGZsaXBQb3NpdGlvbixcbiAgICAgICAgdG9QeDogdG9QeCxcbiAgICAgICAgcmVhZHk6IHJlYWR5LFxuICAgICAgICBpc1RhZzogaXNUYWcsXG4gICAgICAgIGVtcHR5OiBlbXB0eSxcbiAgICAgICAgaHRtbDogaHRtbCxcbiAgICAgICAgcHJlcGVuZDogcHJlcGVuZCxcbiAgICAgICAgYXBwZW5kOiBhcHBlbmQsXG4gICAgICAgIGJlZm9yZTogYmVmb3JlLFxuICAgICAgICBhZnRlcjogYWZ0ZXIsXG4gICAgICAgIHJlbW92ZTogcmVtb3ZlJDEsXG4gICAgICAgIHdyYXBBbGw6IHdyYXBBbGwsXG4gICAgICAgIHdyYXBJbm5lcjogd3JhcElubmVyLFxuICAgICAgICB1bndyYXA6IHVud3JhcCxcbiAgICAgICAgZnJhZ21lbnQ6IGZyYWdtZW50LFxuICAgICAgICBhcHBseTogYXBwbHksXG4gICAgICAgICQ6ICQsXG4gICAgICAgICQkOiAkJCxcbiAgICAgICAgaW5Ccm93c2VyOiBpbkJyb3dzZXIsXG4gICAgICAgIGlzUnRsOiBpc1J0bCxcbiAgICAgICAgaGFzVG91Y2g6IGhhc1RvdWNoLFxuICAgICAgICBwb2ludGVyRG93bjogcG9pbnRlckRvd24kMSxcbiAgICAgICAgcG9pbnRlck1vdmU6IHBvaW50ZXJNb3ZlJDEsXG4gICAgICAgIHBvaW50ZXJVcDogcG9pbnRlclVwJDEsXG4gICAgICAgIHBvaW50ZXJFbnRlcjogcG9pbnRlckVudGVyLFxuICAgICAgICBwb2ludGVyTGVhdmU6IHBvaW50ZXJMZWF2ZSxcbiAgICAgICAgcG9pbnRlckNhbmNlbDogcG9pbnRlckNhbmNlbCxcbiAgICAgICAgb246IG9uLFxuICAgICAgICBvZmY6IG9mZixcbiAgICAgICAgb25jZTogb25jZSxcbiAgICAgICAgdHJpZ2dlcjogdHJpZ2dlcixcbiAgICAgICAgY3JlYXRlRXZlbnQ6IGNyZWF0ZUV2ZW50LFxuICAgICAgICB0b0V2ZW50VGFyZ2V0czogdG9FdmVudFRhcmdldHMsXG4gICAgICAgIGlzVG91Y2g6IGlzVG91Y2gsXG4gICAgICAgIGdldEV2ZW50UG9zOiBnZXRFdmVudFBvcyxcbiAgICAgICAgZmFzdGRvbTogZmFzdGRvbSxcbiAgICAgICAgaXNWb2lkRWxlbWVudDogaXNWb2lkRWxlbWVudCxcbiAgICAgICAgaXNWaXNpYmxlOiBpc1Zpc2libGUsXG4gICAgICAgIHNlbElucHV0OiBzZWxJbnB1dCxcbiAgICAgICAgaXNJbnB1dDogaXNJbnB1dCxcbiAgICAgICAgc2VsRm9jdXNhYmxlOiBzZWxGb2N1c2FibGUsXG4gICAgICAgIGlzRm9jdXNhYmxlOiBpc0ZvY3VzYWJsZSxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIGZpbHRlcjogZmlsdGVyJDEsXG4gICAgICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgICAgIGNsb3Nlc3Q6IGNsb3Nlc3QsXG4gICAgICAgIHdpdGhpbjogd2l0aGluLFxuICAgICAgICBwYXJlbnRzOiBwYXJlbnRzLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgaGFzT3duOiBoYXNPd24sXG4gICAgICAgIGh5cGhlbmF0ZTogaHlwaGVuYXRlLFxuICAgICAgICBjYW1lbGl6ZTogY2FtZWxpemUsXG4gICAgICAgIHVjZmlyc3Q6IHVjZmlyc3QsXG4gICAgICAgIHN0YXJ0c1dpdGg6IHN0YXJ0c1dpdGgsXG4gICAgICAgIGVuZHNXaXRoOiBlbmRzV2l0aCxcbiAgICAgICAgaW5jbHVkZXM6IGluY2x1ZGVzLFxuICAgICAgICBmaW5kSW5kZXg6IGZpbmRJbmRleCxcbiAgICAgICAgaXNBcnJheTogaXNBcnJheSxcbiAgICAgICAgdG9BcnJheTogdG9BcnJheSxcbiAgICAgICAgYXNzaWduOiBhc3NpZ24sXG4gICAgICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICAgICAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgICAgICAgaXNXaW5kb3c6IGlzV2luZG93LFxuICAgICAgICBpc0RvY3VtZW50OiBpc0RvY3VtZW50LFxuICAgICAgICBpc05vZGU6IGlzTm9kZSxcbiAgICAgICAgaXNFbGVtZW50OiBpc0VsZW1lbnQsXG4gICAgICAgIGlzQm9vbGVhbjogaXNCb29sZWFuLFxuICAgICAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgICAgIGlzTnVtYmVyOiBpc051bWJlcixcbiAgICAgICAgaXNOdW1lcmljOiBpc051bWVyaWMsXG4gICAgICAgIGlzRW1wdHk6IGlzRW1wdHksXG4gICAgICAgIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgICAgICAgdG9Cb29sZWFuOiB0b0Jvb2xlYW4sXG4gICAgICAgIHRvTnVtYmVyOiB0b051bWJlcixcbiAgICAgICAgdG9GbG9hdDogdG9GbG9hdCxcbiAgICAgICAgdG9Ob2RlOiB0b05vZGUsXG4gICAgICAgIHRvTm9kZXM6IHRvTm9kZXMsXG4gICAgICAgIHRvV2luZG93OiB0b1dpbmRvdyxcbiAgICAgICAgaXNFcXVhbDogaXNFcXVhbCxcbiAgICAgICAgc3dhcDogc3dhcCxcbiAgICAgICAgbGFzdDogbGFzdCxcbiAgICAgICAgZWFjaDogZWFjaCxcbiAgICAgICAgc29ydEJ5OiBzb3J0QnkkMSxcbiAgICAgICAgdW5pcXVlQnk6IHVuaXF1ZUJ5LFxuICAgICAgICBjbGFtcDogY2xhbXAsXG4gICAgICAgIG5vb3A6IG5vb3AsXG4gICAgICAgIGludGVyc2VjdFJlY3Q6IGludGVyc2VjdFJlY3QsXG4gICAgICAgIHBvaW50SW5SZWN0OiBwb2ludEluUmVjdCxcbiAgICAgICAgRGltZW5zaW9uczogRGltZW5zaW9ucyxcbiAgICAgICAgZ2V0SW5kZXg6IGdldEluZGV4LFxuICAgICAgICBtZW1vaXplOiBtZW1vaXplLFxuICAgICAgICBEZWZlcnJlZDogRGVmZXJyZWQsXG4gICAgICAgIE1vdXNlVHJhY2tlcjogTW91c2VUcmFja2VyLFxuICAgICAgICBvYnNlcnZlSW50ZXJzZWN0aW9uOiBvYnNlcnZlSW50ZXJzZWN0aW9uLFxuICAgICAgICBvYnNlcnZlUmVzaXplOiBvYnNlcnZlUmVzaXplLFxuICAgICAgICBvYnNlcnZlTXV0YXRpb246IG9ic2VydmVNdXRhdGlvbixcbiAgICAgICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgICAgIHBhcnNlT3B0aW9uczogcGFyc2VPcHRpb25zLFxuICAgICAgICBwbGF5OiBwbGF5LFxuICAgICAgICBwYXVzZTogcGF1c2UsXG4gICAgICAgIG11dGU6IG11dGUsXG4gICAgICAgIGlzVmlkZW86IGlzVmlkZW8sXG4gICAgICAgIHBvc2l0aW9uQXQ6IHBvc2l0aW9uQXQsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgcXVlcnlBbGw6IHF1ZXJ5QWxsLFxuICAgICAgICBmaW5kOiBmaW5kLFxuICAgICAgICBmaW5kQWxsOiBmaW5kQWxsLFxuICAgICAgICBlc2NhcGU6IGVzY2FwZSxcbiAgICAgICAgY3NzOiBjc3MsXG4gICAgICAgIHByb3BOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgaXNJblZpZXc6IGlzSW5WaWV3LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogc2Nyb2xsSW50b1ZpZXcsXG4gICAgICAgIHNjcm9sbGVkT3Zlcjogc2Nyb2xsZWRPdmVyLFxuICAgICAgICBzY3JvbGxQYXJlbnRzOiBzY3JvbGxQYXJlbnRzLFxuICAgICAgICBvZmZzZXRWaWV3cG9ydDogb2Zmc2V0Vmlld3BvcnRcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdsb2JhbEFQSSAoVUlraXQpIHtcbiAgICAgIGNvbnN0IERBVEEgPSBVSWtpdC5kYXRhO1xuXG4gICAgICBVSWtpdC51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcGx1Z2luLmNhbGwobnVsbCwgdGhpcyk7XG4gICAgICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgVUlraXQubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4sIGNvbXBvbmVudCkge1xuICAgICAgICBjb21wb25lbnQgPSAoaXNTdHJpbmcoY29tcG9uZW50KSA/IFVJa2l0LmNvbXBvbmVudChjb21wb25lbnQpIDogY29tcG9uZW50KSB8fCB0aGlzO1xuICAgICAgICBjb21wb25lbnQub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhjb21wb25lbnQub3B0aW9ucywgbWl4aW4pO1xuICAgICAgfTtcblxuICAgICAgVUlraXQuZXh0ZW5kID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgY29uc3QgU3VwZXIgPSB0aGlzO1xuICAgICAgICBjb25zdCBTdWIgPSBmdW5jdGlvbiBVSWtpdENvbXBvbmVudChvcHRpb25zKSB7XG4gICAgICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgICAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgICAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhTdXBlci5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICBTdWIuc3VwZXIgPSBTdXBlcjtcbiAgICAgICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcblxuICAgICAgICByZXR1cm4gU3ViO1xuICAgICAgfTtcblxuICAgICAgVUlraXQudXBkYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGUpIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQgPyB0b05vZGUoZWxlbWVudCkgOiBkb2N1bWVudC5ib2R5O1xuXG4gICAgICAgIGZvciAoY29uc3QgcGFyZW50RWwgb2YgcGFyZW50cyhlbGVtZW50KS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICB1cGRhdGUocGFyZW50RWxbREFUQV0sIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwbHkoZWxlbWVudCwgKGVsZW1lbnQpID0+IHVwZGF0ZShlbGVtZW50W0RBVEFdLCBlKSk7XG4gICAgICB9O1xuXG4gICAgICBsZXQgY29udGFpbmVyO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVJa2l0LCAnY29udGFpbmVyJywge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldChlbGVtZW50KSB7XG4gICAgICAgICAgY29udGFpbmVyID0gJChlbGVtZW50KTtcbiAgICAgICAgfSB9KTtcblxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGUoZGF0YSwgZSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGF0YSkge1xuICAgICAgICAgIGlmIChkYXRhW25hbWVdLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGRhdGFbbmFtZV0uX2NhbGxVcGRhdGUoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaG9va3NBUEkgKFVJa2l0KSB7XG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2NhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHt2YXIgX3RoaXMkJG9wdGlvbnMkaG9vaztcbiAgICAgICAgKF90aGlzJCRvcHRpb25zJGhvb2sgPSB0aGlzLiRvcHRpb25zW2hvb2tdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkJG9wdGlvbnMkaG9vay5mb3JFYWNoKChoYW5kbGVyKSA9PiBoYW5kbGVyLmNhbGwodGhpcykpO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9jYWxsQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuICAgICAgICB0aGlzLl9jb21wdXRlZCA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2luaXRQcm9wcygpO1xuXG4gICAgICAgIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVDb25uZWN0Jyk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5faW5pdEV2ZW50cygpO1xuICAgICAgICB0aGlzLl9pbml0T2JzZXJ2ZXJzKCk7XG5cbiAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2Nvbm5lY3RlZCcpO1xuICAgICAgICB0aGlzLl9jYWxsVXBkYXRlKCk7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2NhbGxEaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2JlZm9yZURpc2Nvbm5lY3QnKTtcbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdE9ic2VydmVycygpO1xuICAgICAgICB0aGlzLl91bmJpbmRFdmVudHMoKTtcbiAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2Rpc2Nvbm5lY3RlZCcpO1xuXG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBkZWxldGUgdGhpcy5fd2F0Y2g7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2NhbGxVcGRhdGUgPSBmdW5jdGlvbiAoZSkge2lmIChlID09PSB2b2lkIDApIHtlID0gJ3VwZGF0ZSc7fVxuICAgICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlID09PSAndXBkYXRlJyB8fCBlID09PSAncmVzaXplJykge1xuICAgICAgICAgIHRoaXMuX2NhbGxXYXRjaGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuJG9wdGlvbnMudXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl91cGRhdGVzKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBmYXN0ZG9tLnJlYWQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICBydW5VcGRhdGVzLmNhbGwodGhpcywgdGhpcy5fdXBkYXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdXBkYXRlcztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZXMuYWRkKGUudHlwZSB8fCBlKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5fY2FsbFdhdGNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl93YXRjaCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGluaXRpYWwgPSAhaGFzT3duKHRoaXMsICdfd2F0Y2gnKTtcblxuICAgICAgICB0aGlzLl93YXRjaCA9IGZhc3Rkb20ucmVhZCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgcnVuV2F0Y2hlcy5jYWxsKHRoaXMsIGluaXRpYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl93YXRjaCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gcnVuVXBkYXRlcyh0eXBlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHsgcmVhZCwgd3JpdGUsIGV2ZW50cyA9IFtdIH0gb2YgdGhpcy4kb3B0aW9ucy51cGRhdGUpIHtcbiAgICAgICAgICBpZiAoIXR5cGVzLmhhcygndXBkYXRlJykgJiYgIWV2ZW50cy5zb21lKCh0eXBlKSA9PiB0eXBlcy5oYXModHlwZSkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgIGlmIChyZWFkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZWFkLmNhbGwodGhpcywgdGhpcy5fZGF0YSwgdHlwZXMpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0ICYmIGlzUGxhaW5PYmplY3QocmVzdWx0KSkge1xuICAgICAgICAgICAgICBhc3NpZ24odGhpcy5fZGF0YSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod3JpdGUgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZmFzdGRvbS53cml0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZS5jYWxsKHRoaXMsIHRoaXMuX2RhdGEsIHR5cGVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJ1bldhdGNoZXMoaW5pdGlhbCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJG9wdGlvbnM6IHsgY29tcHV0ZWQgfSB9ID1cbiAgICAgICAgdGhpcztcbiAgICAgICAgY29uc3QgdmFsdWVzID0geyAuLi50aGlzLl9jb21wdXRlZCB9O1xuICAgICAgICB0aGlzLl9jb21wdXRlZCA9IHt9O1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29uc3QgeyB3YXRjaCwgaW1tZWRpYXRlIH0gPSBjb21wdXRlZFtrZXldO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICB3YXRjaCAmJiAoXG4gICAgICAgICAgaW5pdGlhbCAmJiBpbW1lZGlhdGUgfHxcbiAgICAgICAgICBoYXNPd24odmFsdWVzLCBrZXkpICYmICFpc0VxdWFsKHZhbHVlc1trZXldLCB0aGlzW2tleV0pKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICB3YXRjaC5jYWxsKHRoaXMsIHRoaXNba2V5XSwgdmFsdWVzW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXRlQVBJIChVSWtpdCkge1xuICAgICAgbGV0IHVpZCA9IDA7XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLmRhdGEgPSBub3JtYWxpemVEYXRhKG9wdGlvbnMsIHRoaXMuY29uc3RydWN0b3Iub3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnMsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICB0aGlzLiRlbCA9IG51bGw7XG4gICAgICAgIHRoaXMuJHByb3BzID0ge307XG5cbiAgICAgICAgdGhpcy5fdWlkID0gdWlkKys7XG4gICAgICAgIHRoaXMuX2luaXREYXRhKCk7XG4gICAgICAgIHRoaXMuX2luaXRNZXRob2RzKCk7XG4gICAgICAgIHRoaXMuX2luaXRDb21wdXRlZHMoKTtcbiAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2NyZWF0ZWQnKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5lbCkge1xuICAgICAgICAgIHRoaXMuJG1vdW50KG9wdGlvbnMuZWwpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCB7IGRhdGEgPSB7fSB9ID0gdGhpcy4kb3B0aW9ucztcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgdGhpcy4kcHJvcHNba2V5XSA9IHRoaXNba2V5XSA9IGRhdGFba2V5XTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9pbml0TWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgeyBtZXRob2RzIH0gPSB0aGlzLiRvcHRpb25zO1xuXG4gICAgICAgIGlmIChtZXRob2RzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgICAgICAgdGhpc1trZXldID0gbWV0aG9kc1trZXldLmJpbmQodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXRDb21wdXRlZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHsgY29tcHV0ZWQgfSA9IHRoaXMuJG9wdGlvbnM7XG5cbiAgICAgICAgdGhpcy5fY29tcHV0ZWQgPSB7fTtcblxuICAgICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgICAgICAgcmVnaXN0ZXJDb21wdXRlZCh0aGlzLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9pbml0UHJvcHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgbGV0IGtleTtcblxuICAgICAgICBwcm9wcyA9IHByb3BzIHx8IGdldFByb3BzJDEodGhpcy4kb3B0aW9ucyk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHByb3BzW2tleV0pKSB7XG4gICAgICAgICAgICB0aGlzLiRwcm9wc1trZXldID0gcHJvcHNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBleGNsdWRlID0gW3RoaXMuJG9wdGlvbnMuY29tcHV0ZWQsIHRoaXMuJG9wdGlvbnMubWV0aG9kc107XG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuJHByb3BzKSB7XG4gICAgICAgICAgaWYgKGtleSBpbiBwcm9wcyAmJiBub3RJbihleGNsdWRlLCBrZXkpKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSB0aGlzLiRwcm9wc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9pbml0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiB0aGlzLiRvcHRpb25zLmV2ZW50cyB8fCBbXSkge1xuICAgICAgICAgIGlmIChoYXNPd24oZXZlbnQsICdoYW5kbGVyJykpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyRXZlbnQodGhpcywgZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBldmVudCkge1xuICAgICAgICAgICAgICByZWdpc3RlckV2ZW50KHRoaXMsIGV2ZW50W2tleV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX3VuYmluZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzLmZvckVhY2goKHVuYmluZCkgPT4gdW5iaW5kKCkpO1xuICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9pbml0T2JzZXJ2ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMgPSBbaW5pdFByb3BzT2JzZXJ2ZXIodGhpcyldO1xuXG4gICAgICAgIGlmICh0aGlzLiRvcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKGluaXRDaGlsZExpc3RPYnNlcnZlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5yZWdpc3Rlck9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMucHVzaCguLi5hcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9kaXNjb25uZWN0T2JzZXJ2ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IG9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBvYnNlcnZlci5kaXNjb25uZWN0KCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQcm9wcyQxKG9wdHMpIHtcbiAgICAgIGNvbnN0IGRhdGEkMSA9IHt9O1xuICAgICAgY29uc3QgeyBhcmdzID0gW10sIHByb3BzID0ge30sIGVsLCBpZCB9ID0gb3B0cztcblxuICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICByZXR1cm4gZGF0YSQxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBjb25zdCBwcm9wID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGRhdGEoZWwsIHByb3ApO1xuXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gcHJvcHNba2V5XSA9PT0gQm9vbGVhbiAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogY29lcmNlJDEocHJvcHNba2V5XSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChwcm9wID09PSAndGFyZ2V0JyAmJiBzdGFydHNXaXRoKHZhbHVlLCAnXycpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhJDFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcHRpb25zID0gcGFyc2VPcHRpb25zKGRhdGEoZWwsIGlkKSwgYXJncyk7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQocHJvcHNbcHJvcF0pKSB7XG4gICAgICAgICAgZGF0YSQxW3Byb3BdID0gY29lcmNlJDEocHJvcHNbcHJvcF0sIG9wdGlvbnNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGEkMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdpc3RlckNvbXB1dGVkKGNvbXBvbmVudCwga2V5LCBjYikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbXBvbmVudCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IHsgX2NvbXB1dGVkLCAkcHJvcHMsICRlbCB9ID0gY29tcG9uZW50O1xuXG4gICAgICAgICAgaWYgKCFoYXNPd24oX2NvbXB1dGVkLCBrZXkpKSB7XG4gICAgICAgICAgICBfY29tcHV0ZWRba2V5XSA9IChjYi5nZXQgfHwgY2IpLmNhbGwoY29tcG9uZW50LCAkcHJvcHMsICRlbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF9jb21wdXRlZFtrZXldO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgX2NvbXB1dGVkIH0gPSBjb21wb25lbnQ7XG5cbiAgICAgICAgICBfY29tcHV0ZWRba2V5XSA9IGNiLnNldCA/IGNiLnNldC5jYWxsKGNvbXBvbmVudCwgdmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoX2NvbXB1dGVkW2tleV0pKSB7XG4gICAgICAgICAgICBkZWxldGUgX2NvbXB1dGVkW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9IH0pO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJFdmVudChjb21wb25lbnQsIGV2ZW50LCBrZXkpIHtcbiAgICAgIGlmICghaXNQbGFpbk9iamVjdChldmVudCkpIHtcbiAgICAgICAgZXZlbnQgPSB7IG5hbWU6IGtleSwgaGFuZGxlcjogZXZlbnQgfTtcbiAgICAgIH1cblxuICAgICAgbGV0IHsgbmFtZSwgZWwsIGhhbmRsZXIsIGNhcHR1cmUsIHBhc3NpdmUsIGRlbGVnYXRlLCBmaWx0ZXIsIHNlbGYgfSA9IGV2ZW50O1xuICAgICAgZWwgPSBpc0Z1bmN0aW9uKGVsKSA/IGVsLmNhbGwoY29tcG9uZW50KSA6IGVsIHx8IGNvbXBvbmVudC4kZWw7XG5cbiAgICAgIGlmIChpc0FycmF5KGVsKSkge1xuICAgICAgICBlbC5mb3JFYWNoKChlbCkgPT4gcmVnaXN0ZXJFdmVudChjb21wb25lbnQsIHsgLi4uZXZlbnQsIGVsIH0sIGtleSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghZWwgfHwgZmlsdGVyICYmICFmaWx0ZXIuY2FsbChjb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50Ll9ldmVudHMucHVzaChcbiAgICAgIG9uKFxuICAgICAgZWwsXG4gICAgICBuYW1lLFxuICAgICAgZGVsZWdhdGUgPyBpc1N0cmluZyhkZWxlZ2F0ZSkgPyBkZWxlZ2F0ZSA6IGRlbGVnYXRlLmNhbGwoY29tcG9uZW50KSA6IG51bGwsXG4gICAgICBpc1N0cmluZyhoYW5kbGVyKSA/IGNvbXBvbmVudFtoYW5kbGVyXSA6IGhhbmRsZXIuYmluZChjb21wb25lbnQpLFxuICAgICAgeyBwYXNzaXZlLCBjYXB0dXJlLCBzZWxmIH0pKTtcblxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm90SW4ob3B0aW9ucywga2V5KSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5ldmVyeSgoYXJyKSA9PiAhYXJyIHx8ICFoYXNPd24oYXJyLCBrZXkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2VyY2UkMSh0eXBlLCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGUgPT09IEJvb2xlYW4pIHtcbiAgICAgICAgcmV0dXJuIHRvQm9vbGVhbih2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IE51bWJlcikge1xuICAgICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgcmV0dXJuIHRvTGlzdCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlID8gdHlwZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0xpc3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/XG4gICAgICB2YWx1ZSA6XG4gICAgICBpc1N0cmluZyh2YWx1ZSkgP1xuICAgICAgdmFsdWUuXG4gICAgICBzcGxpdCgvLCg/IVteKF0qXFwpKS8pLlxuICAgICAgbWFwKCh2YWx1ZSkgPT4gaXNOdW1lcmljKHZhbHVlKSA/IHRvTnVtYmVyKHZhbHVlKSA6IHRvQm9vbGVhbih2YWx1ZS50cmltKCkpKSA6XG4gICAgICBbdmFsdWVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZURhdGEoX3JlZiwgX3JlZjIpIHtsZXQgeyBkYXRhID0ge30gfSA9IF9yZWY7bGV0IHsgYXJncyA9IFtdLCBwcm9wcyA9IHt9IH0gPSBfcmVmMjtcbiAgICAgIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKDAsIGFyZ3MubGVuZ3RoKS5yZWR1Y2UoKGRhdGEsIHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgYXNzaWduKGRhdGEsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YVthcmdzW2luZGV4XV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoZGF0YVtrZXldKSkge1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2tleV07XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHNba2V5XSkge1xuICAgICAgICAgIGRhdGFba2V5XSA9IGNvZXJjZSQxKHByb3BzW2tleV0sIGRhdGFba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdENoaWxkTGlzdE9ic2VydmVyKGNvbXBvbmVudCkge1xuICAgICAgY29uc3QgeyBlbCB9ID0gY29tcG9uZW50LiRvcHRpb25zO1xuXG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IGNvbXBvbmVudC5fY2FsbFdhdGNoZXMoKSk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGVsLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSB9KTtcblxuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdFByb3BzT2JzZXJ2ZXIoY29tcG9uZW50KSB7XG4gICAgICBjb25zdCB7ICRvcHRpb25zLCAkcHJvcHMgfSA9IGNvbXBvbmVudDtcbiAgICAgIGNvbnN0IHsgaWQsIGF0dHJzLCBwcm9wcywgZWwgfSA9ICRvcHRpb25zO1xuXG4gICAgICBpZiAoIXByb3BzIHx8IGF0dHJzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBpc0FycmF5KGF0dHJzKSA/IGF0dHJzIDogT2JqZWN0LmtleXMocHJvcHMpO1xuICAgICAgY29uc3QgZmlsdGVyID0gYXR0cmlidXRlcy5tYXAoKGtleSkgPT4gaHlwaGVuYXRlKGtleSkpLmNvbmNhdChpZCk7XG5cbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKHJlY29yZHMpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldFByb3BzJDEoJG9wdGlvbnMpO1xuICAgICAgICBpZiAoXG4gICAgICAgIHJlY29yZHMuc29tZSgoX3JlZjMpID0+IHtsZXQgeyBhdHRyaWJ1dGVOYW1lIH0gPSBfcmVmMztcbiAgICAgICAgICBjb25zdCBwcm9wID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKCdkYXRhLScsICcnKTtcbiAgICAgICAgICByZXR1cm4gKHByb3AgPT09IGlkID8gYXR0cmlidXRlcyA6IFtjYW1lbGl6ZShwcm9wKSwgY2FtZWxpemUoYXR0cmlidXRlTmFtZSldKS5zb21lKFxuICAgICAgICAgIChwcm9wKSA9PiAhaXNVbmRlZmluZWQoZGF0YVtwcm9wXSkgJiYgZGF0YVtwcm9wXSAhPT0gJHByb3BzW3Byb3BdKTtcblxuICAgICAgICB9KSlcbiAgICAgICAge1xuICAgICAgICAgIGNvbXBvbmVudC4kcmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG9ic2VydmVyLm9ic2VydmUoZWwsIHtcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBmaWx0ZXIuY29uY2F0KGZpbHRlci5tYXAoKGtleSkgPT4gXCJkYXRhLVwiICsga2V5KSkgfSk7XG5cblxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbmNlQVBJIChVSWtpdCkge1xuICAgICAgY29uc3QgREFUQSA9IFVJa2l0LmRhdGE7XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS4kY3JlYXRlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgZWxlbWVudCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gVUlraXRbY29tcG9uZW50XShlbGVtZW50LCBkYXRhKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lIH0gPSB0aGlzLiRvcHRpb25zO1xuXG4gICAgICAgIGlmICghZWxbREFUQV0pIHtcbiAgICAgICAgICBlbFtEQVRBXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsW0RBVEFdW25hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxbREFUQV1bbmFtZV0gPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuJGVsID0gdGhpcy4kb3B0aW9ucy5lbCA9IHRoaXMuJG9wdGlvbnMuZWwgfHwgZWw7XG5cbiAgICAgICAgaWYgKHdpdGhpbihlbCwgZG9jdW1lbnQpKSB7XG4gICAgICAgICAgdGhpcy5fY2FsbENvbm5lY3RlZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuJHJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jYWxsRGlzY29ubmVjdGVkKCk7XG4gICAgICAgIHRoaXMuX2NhbGxDb25uZWN0ZWQoKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmVFbCkge2lmIChyZW1vdmVFbCA9PT0gdm9pZCAwKSB7cmVtb3ZlRWwgPSBmYWxzZTt9XG4gICAgICAgIGNvbnN0IHsgZWwsIG5hbWUgfSA9IHRoaXMuJG9wdGlvbnM7XG5cbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgdGhpcy5fY2FsbERpc2Nvbm5lY3RlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2Rlc3Ryb3knKTtcblxuICAgICAgICBpZiAoIShlbCAhPSBudWxsICYmIGVsW0RBVEFdKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBlbFtEQVRBXVtuYW1lXTtcblxuICAgICAgICBpZiAoIWlzRW1wdHkoZWxbREFUQV0pKSB7XG4gICAgICAgICAgZGVsZXRlIGVsW0RBVEFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbW92ZUVsKSB7XG4gICAgICAgICAgcmVtb3ZlJDEodGhpcy4kZWwpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9jYWxsVXBkYXRlKGUpO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLiR1cGRhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgZSkge2lmIChlbGVtZW50ID09PSB2b2lkIDApIHtlbGVtZW50ID0gdGhpcy4kZWw7fVxuICAgICAgICBVSWtpdC51cGRhdGUoZWxlbWVudCwgZSk7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuJGdldENvbXBvbmVudCA9IFVJa2l0LmdldENvbXBvbmVudDtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgVUlraXQucHJvdG90eXBlLFxuICAgICAgJyRjb250YWluZXInLFxuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihVSWtpdCwgJ2NvbnRhaW5lcicpKTtcblxuICAgIH1cblxuICAgIGNvbnN0IGNvbXBvbmVudHMkMyA9IHt9O1xuICAgIGZ1bmN0aW9uIGNvbXBvbmVudEFQSSAoVUlraXQpIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogREFUQSwgcHJlZml4OiBQUkVGSVggfSA9IFVJa2l0O1xuXG4gICAgICBVSWtpdC5jb21wb25lbnQgPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucykge1xuICAgICAgICBuYW1lID0gaHlwaGVuYXRlKG5hbWUpO1xuICAgICAgICBjb25zdCBpZCA9IFBSRUZJWCArIG5hbWU7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QoY29tcG9uZW50cyQzW2lkXSkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMkM1tpZF0gPSBjb21wb25lbnRzJDNbXCJkYXRhLVwiICsgaWRdID0gVUlraXQuZXh0ZW5kKGNvbXBvbmVudHMkM1tpZF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb21wb25lbnRzJDNbaWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuXG4gICAgICAgIFVJa2l0W25hbWVdID0gZnVuY3Rpb24gKGVsZW1lbnQsIGRhdGEpIHtcbiAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBVSWtpdC5jb21wb25lbnQobmFtZSk7XG5cbiAgICAgICAgICByZXR1cm4gY29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCA/XG4gICAgICAgICAgbmV3IGNvbXBvbmVudCh7IGRhdGE6IGlzUGxhaW5PYmplY3QoZWxlbWVudCkgPyBlbGVtZW50IDogWy4uLmFyZ3VtZW50c10gfSkgOlxuICAgICAgICAgIGVsZW1lbnQgP1xuICAgICAgICAgICQkKGVsZW1lbnQpLm1hcChpbml0KVswXSA6XG4gICAgICAgICAgaW5pdCgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaW5pdChlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IFVJa2l0LmdldENvbXBvbmVudChlbGVtZW50LCBuYW1lKTtcblxuICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb21wb25lbnQoeyBlbDogZWxlbWVudCwgZGF0YSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb3B0ID0gaXNQbGFpbk9iamVjdChvcHRpb25zKSA/IHsgLi4ub3B0aW9ucyB9IDogb3B0aW9ucy5vcHRpb25zO1xuXG4gICAgICAgIG9wdC5pZCA9IGlkO1xuICAgICAgICBvcHQubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgb3B0Lmluc3RhbGwgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdC5pbnN0YWxsKFVJa2l0LCBvcHQsIG5hbWUpO1xuXG4gICAgICAgIGlmIChVSWtpdC5faW5pdGlhbGl6ZWQgJiYgIW9wdC5mdW5jdGlvbmFsKSB7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IFVJa2l0W25hbWVdKFwiW1wiICsgaWQgKyBcIl0sW2RhdGEtXCIgKyBpZCArIFwiXVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9uZW50cyQzW2lkXSA9IGNvbXBvbmVudHMkM1tcImRhdGEtXCIgKyBpZF0gPSBpc1BsYWluT2JqZWN0KG9wdGlvbnMpID8gb3B0IDogb3B0aW9ucztcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LmdldENvbXBvbmVudHMgPSAoZWxlbWVudCkgPT4gKGVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnRbREFUQV0pIHx8IHt9O1xuICAgICAgVUlraXQuZ2V0Q29tcG9uZW50ID0gKGVsZW1lbnQsIG5hbWUpID0+IFVJa2l0LmdldENvbXBvbmVudHMoZWxlbWVudClbbmFtZV07XG5cbiAgICAgIFVJa2l0LmNvbm5lY3QgPSAobm9kZSkgPT4ge1xuICAgICAgICBpZiAobm9kZVtEQVRBXSkge1xuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBub2RlW0RBVEFdKSB7XG4gICAgICAgICAgICBub2RlW0RBVEFdW25hbWVdLl9jYWxsQ29ubmVjdGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2Ygbm9kZS5nZXRBdHRyaWJ1dGVOYW1lcygpKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoYXR0cmlidXRlKTtcbiAgICAgICAgICBuYW1lICYmIFVJa2l0W25hbWVdKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5kaXNjb25uZWN0ID0gKG5vZGUpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIG5vZGVbREFUQV0pIHtcbiAgICAgICAgICBub2RlW0RBVEFdW25hbWVdLl9jYWxsRGlzY29ubmVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShhdHRyaWJ1dGUpIHtcbiAgICAgIGNvbnN0IGNtcCA9IGNvbXBvbmVudHMkM1thdHRyaWJ1dGVdO1xuICAgICAgcmV0dXJuIGNtcCAmJiAoaXNQbGFpbk9iamVjdChjbXApID8gY21wIDogY21wLm9wdGlvbnMpLm5hbWU7XG4gICAgfVxuXG4gICAgY29uc3QgVUlraXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgVUlraXQudXRpbCA9IHV0aWw7XG4gICAgVUlraXQuZGF0YSA9ICdfX3Vpa2l0X18nO1xuICAgIFVJa2l0LnByZWZpeCA9ICd1ay0nO1xuICAgIFVJa2l0Lm9wdGlvbnMgPSB7fTtcbiAgICBVSWtpdC52ZXJzaW9uID0gJzMuMTUuMTAnO1xuXG4gICAgZ2xvYmFsQVBJKFVJa2l0KTtcbiAgICBob29rc0FQSShVSWtpdCk7XG4gICAgc3RhdGVBUEkoVUlraXQpO1xuICAgIGNvbXBvbmVudEFQSShVSWtpdCk7XG4gICAgaW5zdGFuY2VBUEkoVUlraXQpO1xuXG4gICAgZnVuY3Rpb24gYm9vdCAoVUlraXQpIHtcbiAgICAgIGNvbnN0IHsgY29ubmVjdCwgZGlzY29ubmVjdCB9ID0gVUlraXQ7XG5cbiAgICAgIGlmICghaW5Ccm93c2VyIHx8ICF3aW5kb3cuTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgYXBwbHkoZG9jdW1lbnQuYm9keSwgY29ubmVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcigocmVjb3JkcykgPT4gcmVjb3Jkcy5mb3JFYWNoKGFwcGx5Q2hpbGRMaXN0TXV0YXRpb24pKS5vYnNlcnZlKFxuICAgICAgICBkb2N1bWVudCxcbiAgICAgICAge1xuICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICBzdWJ0cmVlOiB0cnVlIH0pO1xuXG5cblxuICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcigocmVjb3JkcykgPT4gcmVjb3Jkcy5mb3JFYWNoKGFwcGx5QXR0cmlidXRlTXV0YXRpb24pKS5vYnNlcnZlKFxuICAgICAgICBkb2N1bWVudCxcbiAgICAgICAge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgc3VidHJlZTogdHJ1ZSB9KTtcblxuXG5cbiAgICAgICAgVUlraXQuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBhcHBseUNoaWxkTGlzdE11dGF0aW9uKF9yZWYpIHtsZXQgeyBhZGRlZE5vZGVzLCByZW1vdmVkTm9kZXMgfSA9IF9yZWY7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBhZGRlZE5vZGVzKSB7XG4gICAgICAgICAgYXBwbHkobm9kZSwgY29ubmVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgcmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgICAgYXBwbHkobm9kZSwgZGlzY29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVNdXRhdGlvbihfcmVmMikge2xldCB7IHRhcmdldCwgYXR0cmlidXRlTmFtZSB9ID0gX3JlZjI7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGF0dHJpYnV0ZU5hbWUpO1xuXG4gICAgICAgIGlmIChuYW1lKSB7dmFyIF9VSWtpdCRnZXRDb21wb25lbnQ7XG4gICAgICAgICAgaWYgKGhhc0F0dHIodGFyZ2V0LCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgVUlraXRbbmFtZV0odGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAoX1VJa2l0JGdldENvbXBvbmVudCA9IFVJa2l0LmdldENvbXBvbmVudCh0YXJnZXQsIG5hbWUpKSA9PSBudWxsID8gdm9pZCAwIDogX1VJa2l0JGdldENvbXBvbmVudC4kZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIENsYXNzID0ge1xuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy4kb3B0aW9ucy5pZCk7XG4gICAgICB9IH07XG5cbiAgICB2YXIgTGF6eWxvYWQgPSB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHByZWxvYWQ6IDUgfSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGxhenlsb2FkKG9ic2VydmVUYXJnZXRzLCB0YXJnZXRzKSB7aWYgKG9ic2VydmVUYXJnZXRzID09PSB2b2lkIDApIHtvYnNlcnZlVGFyZ2V0cyA9IHRoaXMuJGVsO31pZiAodGFyZ2V0cyA9PT0gdm9pZCAwKSB7dGFyZ2V0cyA9IHRoaXMuJGVsO31cbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIoXG4gICAgICAgICAgb2JzZXJ2ZUludGVyc2VjdGlvbihvYnNlcnZlVGFyZ2V0cywgKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRvTm9kZXMoaXNGdW5jdGlvbih0YXJnZXRzKSA/IHRhcmdldHMoKSA6IHRhcmdldHMpKSB7XG4gICAgICAgICAgICAgICQkKCdbbG9hZGluZz1cImxhenlcIl0nLCBlbCkuXG4gICAgICAgICAgICAgIHNsaWNlKDAsIHRoaXMucHJlbG9hZCAtIDEpLlxuICAgICAgICAgICAgICBmb3JFYWNoKChlbCkgPT4gcmVtb3ZlQXR0cihlbCwgJ2xvYWRpbmcnKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgZW50cmllcy5cbiAgICAgICAgICAgIGZpbHRlcigoX3JlZikgPT4ge2xldCB7IGlzSW50ZXJzZWN0aW5nIH0gPSBfcmVmO3JldHVybiBpc0ludGVyc2VjdGluZzt9KS5cbiAgICAgICAgICAgIG1hcCgoX3JlZjIpID0+IHtsZXQgeyB0YXJnZXQgfSA9IF9yZWYyO3JldHVybiB0YXJnZXQ7fSkpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgVG9nZ2xhYmxlID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2xzOiBCb29sZWFuLFxuICAgICAgICBhbmltYXRpb246ICdsaXN0JyxcbiAgICAgICAgZHVyYXRpb246IE51bWJlcixcbiAgICAgICAgdmVsb2NpdHk6IE51bWJlcixcbiAgICAgICAgb3JpZ2luOiBTdHJpbmcsXG4gICAgICAgIHRyYW5zaXRpb246IFN0cmluZyB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY2xzOiBmYWxzZSxcbiAgICAgICAgYW5pbWF0aW9uOiBbZmFsc2VdLFxuICAgICAgICBkdXJhdGlvbjogMjAwLFxuICAgICAgICB2ZWxvY2l0eTogMC4yLFxuICAgICAgICBvcmlnaW46IGZhbHNlLFxuICAgICAgICB0cmFuc2l0aW9uOiAnZWFzZScsXG4gICAgICAgIGNsc0VudGVyOiAndWstdG9nZ2xhYmUtZW50ZXInLFxuICAgICAgICBjbHNMZWF2ZTogJ3VrLXRvZ2dsYWJlLWxlYXZlJyB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGhhc0FuaW1hdGlvbihfcmVmKSB7bGV0IHsgYW5pbWF0aW9uIH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiAhIWFuaW1hdGlvblswXTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNUcmFuc2l0aW9uKF9yZWYyKSB7bGV0IHsgYW5pbWF0aW9uIH0gPSBfcmVmMjtcbiAgICAgICAgICByZXR1cm4gWydzbGlkZScsICdyZXZlYWwnXS5zb21lKCh0cmFuc2l0aW9uKSA9PiBzdGFydHNXaXRoKGFuaW1hdGlvblswXSwgdHJhbnNpdGlvbikpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICB0b2dnbGVFbGVtZW50KHRhcmdldHMsIHRvZ2dsZSwgYW5pbWF0ZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT5cbiAgICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICB0b05vZGVzKHRhcmdldHMpLm1hcCgoZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNob3cgPSBpc0Jvb2xlYW4odG9nZ2xlKSA/IHRvZ2dsZSA6ICF0aGlzLmlzVG9nZ2xlZChlbCk7XG5cbiAgICAgICAgICAgIGlmICghdHJpZ2dlcihlbCwgXCJiZWZvcmVcIiArIChzaG93ID8gJ3Nob3cnIDogJ2hpZGUnKSwgW3RoaXNdKSkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IChcbiAgICAgICAgICAgIGlzRnVuY3Rpb24oYW5pbWF0ZSkgP1xuICAgICAgICAgICAgYW5pbWF0ZSA6XG4gICAgICAgICAgICBhbmltYXRlID09PSBmYWxzZSB8fCAhdGhpcy5oYXNBbmltYXRpb24gP1xuICAgICAgICAgICAgdG9nZ2xlSW5zdGFudCA6XG4gICAgICAgICAgICB0aGlzLmhhc1RyYW5zaXRpb24gP1xuICAgICAgICAgICAgdG9nZ2xlVHJhbnNpdGlvbiA6XG4gICAgICAgICAgICB0b2dnbGVBbmltYXRpb24pKFxuICAgICAgICAgICAgZWwsIHNob3csIHRoaXMpO1xuXG4gICAgICAgICAgICBjb25zdCBjbHMgPSBzaG93ID8gdGhpcy5jbHNFbnRlciA6IHRoaXMuY2xzTGVhdmU7XG5cbiAgICAgICAgICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuXG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCBzaG93ID8gJ3Nob3cnIDogJ2hpZGUnLCBbdGhpc10pO1xuXG4gICAgICAgICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbiAgICAgICAgICAgICAgdHJpZ2dlcihlbCwgc2hvdyA/ICdzaG93bicgOiAnaGlkZGVuJywgW3RoaXNdKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlID9cbiAgICAgICAgICAgIHByb21pc2UudGhlbihkb25lLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KSkuXG4gICAgICAgICAgdGhlbihyZXNvbHZlLCBub29wKSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBpc1RvZ2dsZWQoZWwpIHtpZiAoZWwgPT09IHZvaWQgMCkge2VsID0gdGhpcy4kZWw7fVxuICAgICAgICAgIFtlbF0gPSB0b05vZGVzKGVsKTtcbiAgICAgICAgICByZXR1cm4gaGFzQ2xhc3MoZWwsIHRoaXMuY2xzRW50ZXIpID9cbiAgICAgICAgICB0cnVlIDpcbiAgICAgICAgICBoYXNDbGFzcyhlbCwgdGhpcy5jbHNMZWF2ZSkgP1xuICAgICAgICAgIGZhbHNlIDpcbiAgICAgICAgICB0aGlzLmNscyA/XG4gICAgICAgICAgaGFzQ2xhc3MoZWwsIHRoaXMuY2xzLnNwbGl0KCcgJylbMF0pIDpcbiAgICAgICAgICBpc1Zpc2libGUoZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF90b2dnbGUoZWwsIHRvZ2dsZWQpIHtcbiAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9nZ2xlZCA9IEJvb2xlYW4odG9nZ2xlZCk7XG5cbiAgICAgICAgICBsZXQgY2hhbmdlZDtcbiAgICAgICAgICBpZiAodGhpcy5jbHMpIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSBpbmNsdWRlcyh0aGlzLmNscywgJyAnKSB8fCB0b2dnbGVkICE9PSBoYXNDbGFzcyhlbCwgdGhpcy5jbHMpO1xuICAgICAgICAgICAgY2hhbmdlZCAmJiB0b2dnbGVDbGFzcyhlbCwgdGhpcy5jbHMsIGluY2x1ZGVzKHRoaXMuY2xzLCAnICcpID8gdW5kZWZpbmVkIDogdG9nZ2xlZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0b2dnbGVkID09PSBlbC5oaWRkZW47XG4gICAgICAgICAgICBjaGFuZ2VkICYmIChlbC5oaWRkZW4gPSAhdG9nZ2xlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJCQoJ1thdXRvZm9jdXNdJywgZWwpLnNvbWUoKGVsKSA9PiBpc1Zpc2libGUoZWwpID8gZWwuZm9jdXMoKSB8fCB0cnVlIDogZWwuYmx1cigpKTtcblxuICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCAndG9nZ2xlZCcsIFt0b2dnbGVkLCB0aGlzXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiB0b2dnbGVJbnN0YW50KGVsLCBzaG93LCBfcmVmMykge2xldCB7IF90b2dnbGUgfSA9IF9yZWYzO1xuICAgICAgQW5pbWF0aW9uLmNhbmNlbChlbCk7XG4gICAgICBUcmFuc2l0aW9uLmNhbmNlbChlbCk7XG4gICAgICByZXR1cm4gX3RvZ2dsZShlbCwgc2hvdyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gdG9nZ2xlVHJhbnNpdGlvbihcbiAgICBlbCxcbiAgICBzaG93LCBfcmVmNClcblxuICAgIHt2YXIgX2FuaW1hdGlvbiQ7bGV0IHsgYW5pbWF0aW9uLCBkdXJhdGlvbiwgdmVsb2NpdHksIHRyYW5zaXRpb24sIF90b2dnbGUgfSA9IF9yZWY0O1xuICAgICAgY29uc3QgW21vZGUgPSAncmV2ZWFsJywgc3RhcnRQcm9wID0gJ3RvcCddID0gKChfYW5pbWF0aW9uJCA9IGFuaW1hdGlvblswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbmltYXRpb24kLnNwbGl0KCctJykpIHx8IFtdO1xuXG4gICAgICBjb25zdCBkaXJzID0gW1xuICAgICAgWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICBbJ3RvcCcsICdib3R0b20nXV07XG5cbiAgICAgIGNvbnN0IGRpciA9IGRpcnNbaW5jbHVkZXMoZGlyc1swXSwgc3RhcnRQcm9wKSA/IDAgOiAxXTtcbiAgICAgIGNvbnN0IGVuZCA9IGRpclsxXSA9PT0gc3RhcnRQcm9wO1xuICAgICAgY29uc3QgcHJvcHMgPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuICAgICAgY29uc3QgZGltUHJvcCA9IHByb3BzW2RpcnMuaW5kZXhPZihkaXIpXTtcbiAgICAgIGNvbnN0IG1hcmdpblByb3AgPSBcIm1hcmdpbi1cIiArIGRpclswXTtcbiAgICAgIGNvbnN0IG1hcmdpblN0YXJ0UHJvcCA9IFwibWFyZ2luLVwiICsgc3RhcnRQcm9wO1xuXG4gICAgICBsZXQgY3VycmVudERpbSA9IGRpbWVuc2lvbnMkMShlbClbZGltUHJvcF07XG5cbiAgICAgIGNvbnN0IGluUHJvZ3Jlc3MgPSBUcmFuc2l0aW9uLmluUHJvZ3Jlc3MoZWwpO1xuICAgICAgYXdhaXQgVHJhbnNpdGlvbi5jYW5jZWwoZWwpO1xuXG4gICAgICBpZiAoc2hvdykge1xuICAgICAgICBfdG9nZ2xlKGVsLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJldlByb3BzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgW1xuICAgICAgJ3BhZGRpbmcnLFxuICAgICAgJ2JvcmRlcicsXG4gICAgICAnd2lkdGgnLFxuICAgICAgJ2hlaWdodCcsXG4gICAgICAnbWluV2lkdGgnLFxuICAgICAgJ21pbkhlaWdodCcsXG4gICAgICAnb3ZlcmZsb3dZJyxcbiAgICAgICdvdmVyZmxvd1gnLFxuICAgICAgbWFyZ2luUHJvcCxcbiAgICAgIG1hcmdpblN0YXJ0UHJvcF0uXG4gICAgICBtYXAoKGtleSkgPT4gW2tleSwgZWwuc3R5bGVba2V5XV0pKTtcblxuXG4gICAgICBjb25zdCBkaW0gPSBkaW1lbnNpb25zJDEoZWwpO1xuICAgICAgY29uc3QgY3VycmVudE1hcmdpbiA9IHRvRmxvYXQoY3NzKGVsLCBtYXJnaW5Qcm9wKSk7XG4gICAgICBjb25zdCBtYXJnaW5TdGFydCA9IHRvRmxvYXQoY3NzKGVsLCBtYXJnaW5TdGFydFByb3ApKTtcbiAgICAgIGNvbnN0IGVuZERpbSA9IGRpbVtkaW1Qcm9wXSArIG1hcmdpblN0YXJ0O1xuXG4gICAgICBpZiAoIWluUHJvZ3Jlc3MgJiYgIXNob3cpIHtcbiAgICAgICAgY3VycmVudERpbSArPSBtYXJnaW5TdGFydDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW3dyYXBwZXJdID0gd3JhcElubmVyKGVsLCAnPGRpdj4nKTtcbiAgICAgIGNzcyh3cmFwcGVyLCB7XG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBoZWlnaHQ6IGRpbS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBkaW0ud2lkdGgsXG4gICAgICAgIC4uLmNzcyhlbCwgW1xuICAgICAgICAnb3ZlcmZsb3cnLFxuICAgICAgICAncGFkZGluZycsXG4gICAgICAgICdib3JkZXJUb3AnLFxuICAgICAgICAnYm9yZGVyUmlnaHQnLFxuICAgICAgICAnYm9yZGVyQm90dG9tJyxcbiAgICAgICAgJ2JvcmRlckxlZnQnLFxuICAgICAgICAnYm9yZGVySW1hZ2UnLFxuICAgICAgICBtYXJnaW5TdGFydFByb3BdKSB9KTtcblxuXG5cbiAgICAgIGNzcyhlbCwge1xuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIG1pbldpZHRoOiAwLFxuICAgICAgICBtaW5IZWlnaHQ6IDAsXG4gICAgICAgIFttYXJnaW5TdGFydFByb3BdOiAwLFxuICAgICAgICB3aWR0aDogZGltLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGRpbS5oZWlnaHQsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgW2RpbVByb3BdOiBjdXJyZW50RGltIH0pO1xuXG5cbiAgICAgIGNvbnN0IHBlcmNlbnQgPSBjdXJyZW50RGltIC8gZW5kRGltO1xuICAgICAgZHVyYXRpb24gPSAodmVsb2NpdHkgKiBlbmREaW0gKyBkdXJhdGlvbikgKiAoc2hvdyA/IDEgLSBwZXJjZW50IDogcGVyY2VudCk7XG4gICAgICBjb25zdCBlbmRQcm9wcyA9IHsgW2RpbVByb3BdOiBzaG93ID8gZW5kRGltIDogMCB9O1xuXG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIGNzcyhlbCwgbWFyZ2luUHJvcCwgZW5kRGltIC0gY3VycmVudERpbSArIGN1cnJlbnRNYXJnaW4pO1xuICAgICAgICBlbmRQcm9wc1ttYXJnaW5Qcm9wXSA9IHNob3cgPyBjdXJyZW50TWFyZ2luIDogZW5kRGltICsgY3VycmVudE1hcmdpbjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbmQgXiBtb2RlID09PSAncmV2ZWFsJykge1xuICAgICAgICBjc3Mod3JhcHBlciwgbWFyZ2luUHJvcCwgLWVuZERpbSArIGN1cnJlbnREaW0pO1xuICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KHdyYXBwZXIsIHsgW21hcmdpblByb3BdOiBzaG93ID8gMCA6IC1lbmREaW0gfSwgZHVyYXRpb24sIHRyYW5zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBUcmFuc2l0aW9uLnN0YXJ0KGVsLCBlbmRQcm9wcywgZHVyYXRpb24sIHRyYW5zaXRpb24pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3NzKGVsLCBwcmV2UHJvcHMpO1xuICAgICAgICB1bndyYXAod3JhcHBlci5maXJzdENoaWxkKTtcblxuICAgICAgICBpZiAoIXNob3cpIHtcbiAgICAgICAgICBfdG9nZ2xlKGVsLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVBbmltYXRpb24oZWwsIHNob3csIGNtcCkge1xuICAgICAgQW5pbWF0aW9uLmNhbmNlbChlbCk7XG5cbiAgICAgIGNvbnN0IHsgYW5pbWF0aW9uLCBkdXJhdGlvbiwgX3RvZ2dsZSB9ID0gY21wO1xuXG4gICAgICBpZiAoc2hvdykge1xuICAgICAgICBfdG9nZ2xlKGVsLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbi5pbihlbCwgYW5pbWF0aW9uWzBdLCBkdXJhdGlvbiwgY21wLm9yaWdpbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBBbmltYXRpb24ub3V0KGVsLCBhbmltYXRpb25bMV0gfHwgYW5pbWF0aW9uWzBdLCBkdXJhdGlvbiwgY21wLm9yaWdpbikudGhlbigoKSA9PlxuICAgICAgX3RvZ2dsZShlbCwgZmFsc2UpKTtcblxuICAgIH1cblxuICAgIHZhciBBY2NvcmRpb24gPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgTGF6eWxvYWQsIFRvZ2dsYWJsZV0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGFuaW1hdGlvbjogQm9vbGVhbixcbiAgICAgICAgdGFyZ2V0czogU3RyaW5nLFxuICAgICAgICBhY3RpdmU6IG51bGwsXG4gICAgICAgIGNvbGxhcHNpYmxlOiBCb29sZWFuLFxuICAgICAgICBtdWx0aXBsZTogQm9vbGVhbixcbiAgICAgICAgdG9nZ2xlOiBTdHJpbmcsXG4gICAgICAgIGNvbnRlbnQ6IFN0cmluZyxcbiAgICAgICAgb2Zmc2V0OiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRhcmdldHM6ICc+IConLFxuICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICBhbmltYXRpb246IHRydWUsXG4gICAgICAgIGNvbGxhcHNpYmxlOiB0cnVlLFxuICAgICAgICBtdWx0aXBsZTogZmFsc2UsXG4gICAgICAgIGNsc09wZW46ICd1ay1vcGVuJyxcbiAgICAgICAgdG9nZ2xlOiAnPiAudWstYWNjb3JkaW9uLXRpdGxlJyxcbiAgICAgICAgY29udGVudDogJz4gLnVrLWFjY29yZGlvbi1jb250ZW50JyxcbiAgICAgICAgb2Zmc2V0OiAwIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICBnZXQoX3JlZiwgJGVsKSB7bGV0IHsgdGFyZ2V0cyB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiAkJCh0YXJnZXRzLCAkZWwpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChpdGVtcywgcHJldikge1xuICAgICAgICAgICAgaWYgKHByZXYgfHwgaGFzQ2xhc3MoaXRlbXMsIHRoaXMuY2xzT3BlbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPVxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgIT09IGZhbHNlICYmIGl0ZW1zW051bWJlcih0aGlzLmFjdGl2ZSldIHx8XG4gICAgICAgICAgICAhdGhpcy5jb2xsYXBzaWJsZSAmJiBpdGVtc1swXTtcblxuICAgICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgICB0aGlzLnRvZ2dsZShhY3RpdmUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0sXG5cblxuICAgICAgICB0b2dnbGVzKF9yZWYyKSB7bGV0IHsgdG9nZ2xlIH0gPSBfcmVmMjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5tYXAoKGl0ZW0pID0+ICQodG9nZ2xlLCBpdGVtKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGVudHM6IHtcbiAgICAgICAgICBnZXQoX3JlZjMpIHtsZXQgeyBjb250ZW50IH0gPSBfcmVmMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLm1hcCgoaXRlbSkgPT4gJChjb250ZW50LCBpdGVtKSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGl0ZW1zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgIGhpZGUoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAhaGFzQ2xhc3MoXG4gICAgICAgICAgICAgIHRoaXMuaXRlbXMuZmluZCgoaXRlbSkgPT4gd2l0aGluKGVsLCBpdGVtKSksXG4gICAgICAgICAgICAgIHRoaXMuY2xzT3BlbikpO1xuXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0gfSxcblxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5sYXp5bG9hZCgpO1xuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0cyArIFwiIFwiICsgdGhpcy4kcHJvcHMudG9nZ2xlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFzeW5jIGhhbmRsZXIoZSkge3ZhciBfdGhpcyRfb2ZmO1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIChfdGhpcyRfb2ZmID0gdGhpcy5fb2ZmKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkX29mZi5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX29mZiA9IGtlZXBTY3JvbGxQb3NpdGlvbihlLnRhcmdldCk7XG4gICAgICAgICAgYXdhaXQgdGhpcy50b2dnbGUoaW5kZXgodGhpcy50b2dnbGVzLCBlLmN1cnJlbnQpKTtcbiAgICAgICAgICB0aGlzLl9vZmYoKTtcbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXN5bmMgdG9nZ2xlKGl0ZW0sIGFuaW1hdGUpIHtcbiAgICAgICAgICBpdGVtID0gdGhpcy5pdGVtc1tnZXRJbmRleChpdGVtLCB0aGlzLml0ZW1zKV07XG4gICAgICAgICAgbGV0IGl0ZW1zID0gW2l0ZW1dO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZUl0ZW1zID0gZmlsdGVyJDEodGhpcy5pdGVtcywgXCIuXCIgKyB0aGlzLmNsc09wZW4pO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlICYmICFpbmNsdWRlcyhhY3RpdmVJdGVtcywgaXRlbXNbMF0pKSB7XG4gICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChhY3RpdmVJdGVtcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLmNvbGxhcHNpYmxlICYmIGFjdGl2ZUl0ZW1zLmxlbmd0aCA8IDIgJiYgaW5jbHVkZXMoYWN0aXZlSXRlbXMsIGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgaXRlbXMubWFwKChlbCkgPT5cbiAgICAgICAgICB0aGlzLnRvZ2dsZUVsZW1lbnQoZWwsICFpbmNsdWRlcyhhY3RpdmVJdGVtcywgZWwpLCAoZWwsIHNob3cpID0+IHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzLmNsc09wZW4sIHNob3cpO1xuICAgICAgICAgICAgYXR0cigkKHRoaXMuJHByb3BzLnRvZ2dsZSwgZWwpLCAnYXJpYS1leHBhbmRlZCcsIHNob3cpO1xuXG4gICAgICAgICAgICBpZiAoYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIXRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgIGhpZGUoJCh0aGlzLmNvbnRlbnQsIGVsKSwgIXNob3cpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9uKGVsLCBzaG93LCB0aGlzKTtcbiAgICAgICAgICB9KSkpO1xuXG5cbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gaGlkZShlbCwgaGlkZSkge1xuICAgICAgZWwgJiYgKGVsLmhpZGRlbiA9IGhpZGUpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHRyYW5zaXRpb24oZWwsIHNob3csIF9yZWY0KSB7dmFyIF9lbCRfd3JhcHBlcjtsZXQgeyBjb250ZW50LCBkdXJhdGlvbiwgdmVsb2NpdHksIHRyYW5zaXRpb24gfSA9IF9yZWY0O1xuICAgICAgY29udGVudCA9ICgoX2VsJF93cmFwcGVyID0gZWwuX3dyYXBwZXIpID09IG51bGwgPyB2b2lkIDAgOiBfZWwkX3dyYXBwZXIuZmlyc3RFbGVtZW50Q2hpbGQpIHx8ICQoY29udGVudCwgZWwpO1xuXG4gICAgICBpZiAoIWVsLl93cmFwcGVyKSB7XG4gICAgICAgIGVsLl93cmFwcGVyID0gd3JhcEFsbChjb250ZW50LCAnPGRpdj4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd3JhcHBlciA9IGVsLl93cmFwcGVyO1xuICAgICAgY3NzKHdyYXBwZXIsICdvdmVyZmxvdycsICdoaWRkZW4nKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSB0b0Zsb2F0KGNzcyh3cmFwcGVyLCAnaGVpZ2h0JykpO1xuXG4gICAgICBhd2FpdCBUcmFuc2l0aW9uLmNhbmNlbCh3cmFwcGVyKTtcbiAgICAgIGhpZGUoY29udGVudCwgZmFsc2UpO1xuXG4gICAgICBjb25zdCBlbmRIZWlnaHQgPVxuICAgICAgdG9GbG9hdChjc3MoY29udGVudCwgJ2hlaWdodCcpKSArXG4gICAgICB0b0Zsb2F0KGNzcyhjb250ZW50LCAnbWFyZ2luVG9wJykpICtcbiAgICAgIHRvRmxvYXQoY3NzKGNvbnRlbnQsICdtYXJnaW5Cb3R0b20nKSk7XG4gICAgICBjb25zdCBwZXJjZW50ID0gY3VycmVudEhlaWdodCAvIGVuZEhlaWdodDtcbiAgICAgIGR1cmF0aW9uID0gKHZlbG9jaXR5ICogZW5kSGVpZ2h0ICsgZHVyYXRpb24pICogKHNob3cgPyAxIC0gcGVyY2VudCA6IHBlcmNlbnQpO1xuICAgICAgY3NzKHdyYXBwZXIsICdoZWlnaHQnLCBjdXJyZW50SGVpZ2h0KTtcblxuICAgICAgYXdhaXQgVHJhbnNpdGlvbi5zdGFydCh3cmFwcGVyLCB7IGhlaWdodDogc2hvdyA/IGVuZEhlaWdodCA6IDAgfSwgZHVyYXRpb24sIHRyYW5zaXRpb24pO1xuXG4gICAgICB1bndyYXAoY29udGVudCk7XG4gICAgICBkZWxldGUgZWwuX3dyYXBwZXI7XG5cbiAgICAgIGlmICghc2hvdykge1xuICAgICAgICBoaWRlKGNvbnRlbnQsIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtlZXBTY3JvbGxQb3NpdGlvbihlbCkge1xuICAgICAgY29uc3Qgc2Nyb2xsUGFyZW50ID0gc2Nyb2xsUGFyZW50cyhlbClbMF07XG4gICAgICBsZXQgZnJhbWU7XG4gICAgICAoZnVuY3Rpb24gc2Nyb2xsKCkge1xuICAgICAgICBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyB0b3AgfSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIGlmICh0b3AgPCAwKSB7XG4gICAgICAgICAgICBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wICs9IHRvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2Nyb2xsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkoKTtcblxuICAgICAgcmV0dXJuICgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZSkpO1xuICAgIH1cblxuICAgIHZhciBhbGVydCA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBUb2dnbGFibGVdLFxuXG4gICAgICBhcmdzOiAnYW5pbWF0aW9uJyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgYW5pbWF0aW9uOiBCb29sZWFuLFxuICAgICAgICBjbG9zZTogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBhbmltYXRpb246IHRydWUsXG4gICAgICAgIHNlbENsb3NlOiAnLnVrLWFsZXJ0LWNsb3NlJyxcbiAgICAgICAgZHVyYXRpb246IDE1MCB9LFxuXG5cbiAgICAgIGV2ZW50czoge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlbENsb3NlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgZmFsc2UsIGFuaW1hdGUkMSk7XG4gICAgICAgICAgdGhpcy4kZGVzdHJveSh0cnVlKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gYW5pbWF0ZSQxKGVsLCBzaG93LCBfcmVmKSB7bGV0IHsgZHVyYXRpb24sIHRyYW5zaXRpb24sIHZlbG9jaXR5IH0gPSBfcmVmO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gdG9GbG9hdChjc3MoZWwsICdoZWlnaHQnKSk7XG4gICAgICBjc3MoZWwsICdoZWlnaHQnLCBoZWlnaHQpO1xuICAgICAgcmV0dXJuIFRyYW5zaXRpb24uc3RhcnQoXG4gICAgICBlbCxcbiAgICAgIHtcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogMCxcbiAgICAgICAgcGFkZGluZ1RvcDogMCxcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogMCxcbiAgICAgICAgYm9yZGVyVG9wOiAwLFxuICAgICAgICBib3JkZXJCb3R0b206IDAsXG4gICAgICAgIG9wYWNpdHk6IDAgfSxcblxuICAgICAgdmVsb2NpdHkgKiBoZWlnaHQgKyBkdXJhdGlvbixcbiAgICAgIHRyYW5zaXRpb24pO1xuXG4gICAgfVxuXG4gICAgdmFyIFZpZGVvID0ge1xuICAgICAgYXJnczogJ2F1dG9wbGF5JyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgYXV0b211dGU6IEJvb2xlYW4sXG4gICAgICAgIGF1dG9wbGF5OiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBhdXRvbXV0ZTogZmFsc2UsXG4gICAgICAgIGF1dG9wbGF5OiB0cnVlIH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmluVmlldyA9IHRoaXMuYXV0b3BsYXkgPT09ICdpbnZpZXcnO1xuXG4gICAgICAgIGlmICh0aGlzLmluVmlldyAmJiAhaGFzQXR0cih0aGlzLiRlbCwgJ3ByZWxvYWQnKSkge1xuICAgICAgICAgIHRoaXMuJGVsLnByZWxvYWQgPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNUYWcodGhpcy4kZWwsICdpZnJhbWUnKSAmJiAhaGFzQXR0cih0aGlzLiRlbCwgJ2FsbG93JykpIHtcbiAgICAgICAgICB0aGlzLiRlbC5hbGxvdyA9ICdhdXRvcGxheSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hdXRvbXV0ZSkge1xuICAgICAgICAgIG11dGUodGhpcy4kZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKG9ic2VydmVJbnRlcnNlY3Rpb24odGhpcy4kZWwsICgpID0+IHRoaXMuJGVtaXQoKSwge30sIGZhbHNlKSk7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBpZiAoIWlzVmlkZW8odGhpcy4kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZpc2libGU6IGlzVmlzaWJsZSh0aGlzLiRlbCkgJiYgY3NzKHRoaXMuJGVsLCAndmlzaWJpbGl0eScpICE9PSAnaGlkZGVuJyxcbiAgICAgICAgICAgIGluVmlldzogdGhpcy5pblZpZXcgJiYgaXNJblZpZXcodGhpcy4kZWwpIH07XG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmKSB7bGV0IHsgdmlzaWJsZSwgaW5WaWV3IH0gPSBfcmVmO1xuICAgICAgICAgIGlmICghdmlzaWJsZSB8fCB0aGlzLmluVmlldyAmJiAhaW5WaWV3KSB7XG4gICAgICAgICAgICBwYXVzZSh0aGlzLiRlbCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmF1dG9wbGF5ID09PSB0cnVlIHx8IHRoaXMuaW5WaWV3ICYmIGluVmlldykge1xuICAgICAgICAgICAgcGxheSh0aGlzLiRlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0gfTtcblxuICAgIHZhciBSZXNpemUgPSB7XG4gICAgICBjb25uZWN0ZWQoKSB7dmFyIF90aGlzJCRvcHRpb25zJHJlc2l6ZTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKFxuICAgICAgICBvYnNlcnZlUmVzaXplKCgoX3RoaXMkJG9wdGlvbnMkcmVzaXplID0gdGhpcy4kb3B0aW9ucy5yZXNpemVUYXJnZXRzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkJG9wdGlvbnMkcmVzaXplLmNhbGwodGhpcykpIHx8IHRoaXMuJGVsLCAoKSA9PlxuICAgICAgICB0aGlzLiRlbWl0KCdyZXNpemUnKSkpO1xuXG5cbiAgICAgIH0gfTtcblxuICAgIHZhciBjb3ZlciA9IHtcbiAgICAgIG1peGluczogW1Jlc2l6ZSwgVmlkZW9dLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICB3aWR0aDogTnVtYmVyLFxuICAgICAgICBoZWlnaHQ6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYXV0b211dGU6IHRydWUgfSxcblxuXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgJ2xvYWQgbG9hZGVkbWV0YWRhdGEnKCkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ3Jlc2l6ZScpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgcmVzaXplVGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLiRlbCwgZ2V0UG9zaXRpb25lZFBhcmVudCh0aGlzLiRlbCkgfHwgcGFyZW50KHRoaXMuJGVsKV07XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBjb25zdCB7IHJhdGlvLCBjb3ZlciB9ID0gRGltZW5zaW9ucztcbiAgICAgICAgICBjb25zdCB7ICRlbCwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcztcblxuICAgICAgICAgIGxldCBkaW0gPSB7IHdpZHRoLCBoZWlnaHQgfTtcblxuICAgICAgICAgIGlmICghZGltLndpZHRoIHx8ICFkaW0uaGVpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBpbnRyaW5zaWMgPSB7XG4gICAgICAgICAgICAgIHdpZHRoOiAkZWwubmF0dXJhbFdpZHRoIHx8ICRlbC52aWRlb1dpZHRoIHx8ICRlbC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiAkZWwubmF0dXJhbEhlaWdodCB8fCAkZWwudmlkZW9IZWlnaHQgfHwgJGVsLmNsaWVudEhlaWdodCB9O1xuXG5cbiAgICAgICAgICAgIGlmIChkaW0ud2lkdGgpIHtcbiAgICAgICAgICAgICAgZGltID0gcmF0aW8oaW50cmluc2ljLCAnd2lkdGgnLCBkaW0ud2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgZGltID0gcmF0aW8oaW50cmluc2ljLCAnaGVpZ2h0JywgZGltLmhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkaW0gPSBpbnRyaW5zaWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBvZmZzZXRIZWlnaHQ6IGNvdmVySGVpZ2h0LCBvZmZzZXRXaWR0aDogY292ZXJXaWR0aCB9ID1cbiAgICAgICAgICBnZXRQb3NpdGlvbmVkUGFyZW50KCRlbCkgfHwgcGFyZW50KCRlbCk7XG4gICAgICAgICAgY29uc3QgY292ZXJEaW0gPSBjb3ZlcihkaW0sIHtcbiAgICAgICAgICAgIHdpZHRoOiBjb3ZlcldpZHRoICsgKGNvdmVyV2lkdGggJSAyID8gMSA6IDApLFxuICAgICAgICAgICAgaGVpZ2h0OiBjb3ZlckhlaWdodCArIChjb3ZlckhlaWdodCAlIDIgPyAxIDogMCkgfSk7XG5cblxuICAgICAgICAgIGlmICghY292ZXJEaW0ud2lkdGggfHwgIWNvdmVyRGltLmhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb3ZlckRpbTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmKSB7bGV0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gX3JlZjtcbiAgICAgICAgICBjc3ModGhpcy4kZWwsIHsgaGVpZ2h0LCB3aWR0aCB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uZWRQYXJlbnQoZWwpIHtcbiAgICAgIHdoaWxlIChlbCA9IHBhcmVudChlbCkpIHtcbiAgICAgICAgaWYgKGNzcyhlbCwgJ3Bvc2l0aW9uJykgIT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIENvbnRhaW5lciA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNvbnRhaW5lcjogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY29udGFpbmVyOiB0cnVlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29udGFpbmVyKF9yZWYpIHtsZXQgeyBjb250YWluZXIgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5lciA9PT0gdHJ1ZSAmJiB0aGlzLiRjb250YWluZXIgfHwgY29udGFpbmVyICYmICQoY29udGFpbmVyKTtcbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgUG9zaXRpb24gPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBwb3M6IFN0cmluZyxcbiAgICAgICAgb2Zmc2V0OiBudWxsLFxuICAgICAgICBmbGlwOiBCb29sZWFuLFxuICAgICAgICBzaGlmdDogQm9vbGVhbixcbiAgICAgICAgaW5zZXQ6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBvczogXCJib3R0b20tXCIgKyAoaXNSdGwgPyAncmlnaHQnIDogJ2xlZnQnKSxcbiAgICAgICAgb2Zmc2V0OiBmYWxzZSxcbiAgICAgICAgZmxpcDogdHJ1ZSxcbiAgICAgICAgc2hpZnQ6IHRydWUsXG4gICAgICAgIGluc2V0OiBmYWxzZSB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLiRwcm9wcy5wb3Muc3BsaXQoJy0nKS5jb25jYXQoJ2NlbnRlcicpLnNsaWNlKDAsIDIpO1xuICAgICAgICBbdGhpcy5kaXIsIHRoaXMuYWxpZ25dID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMuYXhpcyA9IGluY2x1ZGVzKFsndG9wJywgJ2JvdHRvbSddLCB0aGlzLmRpcikgPyAneScgOiAneCc7XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHBvc2l0aW9uQXQoZWxlbWVudCwgdGFyZ2V0LCBib3VuZGFyeSkge1xuICAgICAgICAgIGxldCBvZmZzZXQgPSBbdGhpcy5nZXRQb3NpdGlvbk9mZnNldChlbGVtZW50KSwgdGhpcy5nZXRTaGlmdE9mZnNldChlbGVtZW50KV07XG4gICAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gW3RoaXMuZmxpcCAmJiAnZmxpcCcsIHRoaXMuc2hpZnQgJiYgJ3NoaWZ0J107XG5cbiAgICAgICAgICBjb25zdCBhdHRhY2ggPSB7XG4gICAgICAgICAgICBlbGVtZW50OiBbdGhpcy5pbnNldCA/IHRoaXMuZGlyIDogZmxpcFBvc2l0aW9uKHRoaXMuZGlyKSwgdGhpcy5hbGlnbl0sXG4gICAgICAgICAgICB0YXJnZXQ6IFt0aGlzLmRpciwgdGhpcy5hbGlnbl0gfTtcblxuXG4gICAgICAgICAgaWYgKHRoaXMuYXhpcyA9PT0gJ3knKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gYXR0YWNoKSB7XG4gICAgICAgICAgICAgIGF0dGFjaFtwcm9wXS5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgcGxhY2VtZW50LnJldmVyc2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBbc2Nyb2xsRWxlbWVudF0gPSBzY3JvbGxQYXJlbnRzKGVsZW1lbnQsIC9hdXRvfHNjcm9sbC8pO1xuICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0IH0gPSBzY3JvbGxFbGVtZW50O1xuXG4gICAgICAgICAgLy8gRW5zdXJlIG5vbmUgcG9zaXRpb25lZCBlbGVtZW50IGRvZXMgbm90IGdlbmVyYXRlIHNjcm9sbGJhcnNcbiAgICAgICAgICBjb25zdCBlbERpbSA9IGRpbWVuc2lvbnMkMShlbGVtZW50KTtcbiAgICAgICAgICBjc3MoZWxlbWVudCwgeyB0b3A6IC1lbERpbS5oZWlnaHQsIGxlZnQ6IC1lbERpbS53aWR0aCB9KTtcblxuICAgICAgICAgIHBvc2l0aW9uQXQoZWxlbWVudCwgdGFyZ2V0LCB7XG4gICAgICAgICAgICBhdHRhY2gsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgICAgIHZpZXdwb3J0T2Zmc2V0OiB0aGlzLmdldFZpZXdwb3J0T2Zmc2V0KGVsZW1lbnQpIH0pO1xuXG5cbiAgICAgICAgICAvLyBSZXN0b3JlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICAgIHNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgIHNjcm9sbEVsZW1lbnQuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UG9zaXRpb25PZmZzZXQoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0b1B4KFxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPT09IGZhbHNlID8gY3NzKGVsZW1lbnQsICctLXVrLXBvc2l0aW9uLW9mZnNldCcpIDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICB0aGlzLmF4aXMgPT09ICd4JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JyxcbiAgICAgICAgICAgIGVsZW1lbnQpICogKFxuXG4gICAgICAgICAgICBpbmNsdWRlcyhbJ2xlZnQnLCAndG9wJ10sIHRoaXMuZGlyKSA/IC0xIDogMSkgKiAoXG4gICAgICAgICAgICB0aGlzLmluc2V0ID8gLTEgOiAxKSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTaGlmdE9mZnNldChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ24gPT09ICdjZW50ZXInID9cbiAgICAgICAgICAwIDpcbiAgICAgICAgICB0b1B4KFxuICAgICAgICAgIGNzcyhlbGVtZW50LCAnLS11ay1wb3NpdGlvbi1zaGlmdC1vZmZzZXQnKSxcbiAgICAgICAgICB0aGlzLmF4aXMgPT09ICd5JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JyxcbiAgICAgICAgICBlbGVtZW50KSAqIChcbiAgICAgICAgICBpbmNsdWRlcyhbJ2xlZnQnLCAndG9wJ10sIHRoaXMuYWxpZ24pID8gMSA6IC0xKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRWaWV3cG9ydE9mZnNldChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRvUHgoY3NzKGVsZW1lbnQsICctLXVrLXBvc2l0aW9uLXZpZXdwb3J0LW9mZnNldCcpKTtcbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgU3R5bGUgPSB7XG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLl9zdHlsZSA9IGF0dHIodGhpcy4kZWwsICdzdHlsZScpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICBhdHRyKHRoaXMuJGVsLCAnc3R5bGUnLCB0aGlzLl9zdHlsZSk7XG4gICAgICB9IH07XG5cbiAgICBjb25zdCBhY3RpdmUkMSA9IFtdO1xuXG4gICAgdmFyIE1vZGFsID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIENvbnRhaW5lciwgVG9nZ2xhYmxlXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgc2VsUGFuZWw6IFN0cmluZyxcbiAgICAgICAgc2VsQ2xvc2U6IFN0cmluZyxcbiAgICAgICAgZXNjQ2xvc2U6IEJvb2xlYW4sXG4gICAgICAgIGJnQ2xvc2U6IEJvb2xlYW4sXG4gICAgICAgIHN0YWNrOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBjbHM6ICd1ay1vcGVuJyxcbiAgICAgICAgZXNjQ2xvc2U6IHRydWUsXG4gICAgICAgIGJnQ2xvc2U6IHRydWUsXG4gICAgICAgIG92ZXJsYXk6IHRydWUsXG4gICAgICAgIHN0YWNrOiBmYWxzZSB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHBhbmVsKF9yZWYsICRlbCkge2xldCB7IHNlbFBhbmVsIH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiAkKHNlbFBhbmVsLCAkZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zaXRpb25FbGVtZW50KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhbmVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJnQ2xvc2UoX3JlZjIpIHtsZXQgeyBiZ0Nsb3NlIH0gPSBfcmVmMjtcbiAgICAgICAgICByZXR1cm4gYmdDbG9zZSAmJiB0aGlzLnBhbmVsO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgYmVmb3JlRGlzY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVzKGFjdGl2ZSQxLCB0aGlzKSkge1xuICAgICAgICAgIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsQ2xvc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiAnYVtocmVmKj1cIiNcIl0nO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoX3JlZjMpIHtsZXQgeyBjdXJyZW50LCBkZWZhdWx0UHJldmVudGVkIH0gPSBfcmVmMztcbiAgICAgICAgICBjb25zdCB7IGhhc2ggfSA9IGN1cnJlbnQ7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICFkZWZhdWx0UHJldmVudGVkICYmXG4gICAgICAgICAgaGFzaCAmJlxuICAgICAgICAgIGlzU2FtZVNpdGVBbmNob3IoY3VycmVudCkgJiZcbiAgICAgICAgICAhd2l0aGluKGhhc2gsIHRoaXMuJGVsKSAmJlxuICAgICAgICAgICQoaGFzaCwgZG9jdW1lbnQuYm9keSkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAndG9nZ2xlJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSA9PT0gaW5jbHVkZXMoYWN0aXZlJDEsIHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2JlZm9yZXNob3cnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKGluY2x1ZGVzKGFjdGl2ZSQxLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5zdGFjayAmJiBhY3RpdmUkMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKGFjdGl2ZSQxLm1hcCgobW9kYWwpID0+IG1vZGFsLmhpZGUoKSkpLnRoZW4odGhpcy5zaG93KTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlJDEucHVzaCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzaG93JyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgb25jZShcbiAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICAnaGlkZScsXG4gICAgICAgICAgb24oZG9jdW1lbnQsICdmb2N1c2luJywgKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChsYXN0KGFjdGl2ZSQxKSA9PT0gdGhpcyAmJiAhd2l0aGluKGUudGFyZ2V0LCB0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgICAgdGhpcy4kZWwuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG5cblxuICAgICAgICAgIGlmICh0aGlzLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIG9uY2UodGhpcy4kZWwsICdoaWRkZW4nLCBwcmV2ZW50T3ZlcnNjcm9sbCh0aGlzLiRlbCksIHsgc2VsZjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIG9uY2UodGhpcy4kZWwsICdoaWRkZW4nLCBwcmV2ZW50QmFja2dyb3VuZFNjcm9sbCgpLCB7IHNlbGY6IHRydWUgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2spIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ3pJbmRleCcsIHRvRmxvYXQoY3NzKHRoaXMuJGVsLCAnekluZGV4JykpICsgYWN0aXZlJDEubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRDbGFzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuY2xzUGFnZSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5iZ0Nsb3NlKSB7XG4gICAgICAgICAgICBvbmNlKFxuICAgICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgICAnaGlkZScsXG4gICAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlckRvd24kMSwgKF9yZWY0KSA9PiB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmNDtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBsYXN0KGFjdGl2ZSQxKSAhPT0gdGhpcyB8fFxuICAgICAgICAgICAgICB0aGlzLm92ZXJsYXkgJiYgIXdpdGhpbih0YXJnZXQsIHRoaXMuJGVsKSB8fFxuICAgICAgICAgICAgICB3aXRoaW4odGFyZ2V0LCB0aGlzLnBhbmVsKSlcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9uY2UoXG4gICAgICAgICAgICAgIGRvY3VtZW50LFxuICAgICAgICAgICAgICBwb2ludGVyVXAkMSArIFwiIFwiICsgcG9pbnRlckNhbmNlbCArIFwiIHNjcm9sbFwiLFxuICAgICAgICAgICAgICAoX3JlZjUpID0+IHtsZXQgeyBkZWZhdWx0UHJldmVudGVkLCB0eXBlLCB0YXJnZXQ6IG5ld1RhcmdldCB9ID0gX3JlZjU7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFkZWZhdWx0UHJldmVudGVkICYmXG4gICAgICAgICAgICAgICAgdHlwZSA9PT0gcG9pbnRlclVwJDEgJiZcbiAgICAgICAgICAgICAgICB0YXJnZXQgPT09IG5ld1RhcmdldClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRydWUpO1xuXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHsgc2VsZjogdHJ1ZSB9KTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmVzY0Nsb3NlKSB7XG4gICAgICAgICAgICBvbmNlKFxuICAgICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgICAnaGlkZScsXG4gICAgICAgICAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNyAmJiBsYXN0KGFjdGl2ZSQxKSA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHsgc2VsZjogdHJ1ZSB9KTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Nob3duJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKCFpc0ZvY3VzYWJsZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIGF0dHIodGhpcy4kZWwsICd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghJCgnOmZvY3VzJywgdGhpcy4kZWwpKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGRlbicsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmIChpbmNsdWRlcyhhY3RpdmUkMSwgdGhpcykpIHtcbiAgICAgICAgICAgIGFjdGl2ZSQxLnNwbGljZShhY3RpdmUkMS5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjc3ModGhpcy4kZWwsICd6SW5kZXgnLCAnJyk7XG5cbiAgICAgICAgICBpZiAoIWFjdGl2ZSQxLnNvbWUoKG1vZGFsKSA9PiBtb2RhbC5jbHNQYWdlID09PSB0aGlzLmNsc1BhZ2UpKSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuY2xzUGFnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICB0b2dnbGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNUb2dnbGVkKCkgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyICYmIHBhcmVudCh0aGlzLiRlbCkgIT09IHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmQodGhpcy5jb250YWluZXIsIHRoaXMuJGVsKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnNob3coKS50aGVuKHJlc29sdmUpKSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy50b2dnbGVFbGVtZW50KHRoaXMuJGVsLCB0cnVlLCBhbmltYXRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwsIGZhbHNlLCBhbmltYXRlKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gYW5pbWF0ZShlbCwgc2hvdywgX3JlZjYpIHtsZXQgeyB0cmFuc2l0aW9uRWxlbWVudCwgX3RvZ2dsZSB9ID0gX3JlZjY7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgIG9uY2UoZWwsICdzaG93IGhpZGUnLCAoKSA9PiB7XG4gICAgICAgIGVsLl9yZWplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLl9yZWplY3QoKTtcbiAgICAgICAgZWwuX3JlamVjdCA9IHJlamVjdDtcblxuICAgICAgICBfdG9nZ2xlKGVsLCBzaG93KTtcblxuICAgICAgICBjb25zdCBvZmYgPSBvbmNlKFxuICAgICAgICB0cmFuc2l0aW9uRWxlbWVudCxcbiAgICAgICAgJ3RyYW5zaXRpb25zdGFydCcsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBvbmNlKHRyYW5zaXRpb25FbGVtZW50LCAndHJhbnNpdGlvbmVuZCB0cmFuc2l0aW9uY2FuY2VsJywgcmVzb2x2ZSwge1xuICAgICAgICAgICAgc2VsZjogdHJ1ZSB9KTtcblxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH0sXG4gICAgICAgIHsgc2VsZjogdHJ1ZSB9KTtcblxuXG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgb2ZmKCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCB0b01zKGNzcyh0cmFuc2l0aW9uRWxlbWVudCwgJ3RyYW5zaXRpb25EdXJhdGlvbicpKSk7XG4gICAgICB9KSkuXG4gICAgICB0aGVuKCgpID0+IGRlbGV0ZSBlbC5fcmVqZWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b01zKHRpbWUpIHtcbiAgICAgIHJldHVybiB0aW1lID8gZW5kc1dpdGgodGltZSwgJ21zJykgPyB0b0Zsb2F0KHRpbWUpIDogdG9GbG9hdCh0aW1lKSAqIDEwMDAgOiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXZlbnRPdmVyc2Nyb2xsKGVsKSB7XG4gICAgICBpZiAoQ1NTLnN1cHBvcnRzKCdvdmVyc2Nyb2xsLWJlaGF2aW9yJywgJ2NvbnRhaW4nKSkge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGZpbHRlckNoaWxkcmVuKGVsLCAoY2hpbGQpID0+IC9hdXRvfHNjcm9sbC8udGVzdChjc3MoY2hpbGQsICdvdmVyZmxvdycpKSk7XG4gICAgICAgIGNzcyhlbGVtZW50cywgJ292ZXJzY3JvbGxCZWhhdmlvcicsICdjb250YWluJyk7XG4gICAgICAgIHJldHVybiAoKSA9PiBjc3MoZWxlbWVudHMsICdvdmVyc2Nyb2xsQmVoYXZpb3InLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBzdGFydENsaWVudFk7XG5cbiAgICAgIGNvbnN0IGV2ZW50cyA9IFtcbiAgICAgIG9uKFxuICAgICAgZWwsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAoX3JlZjcpID0+IHtsZXQgeyB0YXJnZXRUb3VjaGVzIH0gPSBfcmVmNztcbiAgICAgICAgaWYgKHRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgc3RhcnRDbGllbnRZID0gdGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyBwYXNzaXZlOiB0cnVlIH0pLFxuXG5cbiAgICAgIG9uKFxuICAgICAgZWwsXG4gICAgICAndG91Y2htb3ZlJyxcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGlmIChlLnRhcmdldFRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IFtzY3JvbGxQYXJlbnRdID0gc2Nyb2xsUGFyZW50cyhlLnRhcmdldCwgL2F1dG98c2Nyb2xsLyk7XG4gICAgICAgIGlmICghd2l0aGluKHNjcm9sbFBhcmVudCwgZWwpKSB7XG4gICAgICAgICAgc2Nyb2xsUGFyZW50ID0gZWw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbGllbnRZID0gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFkgLSBzdGFydENsaWVudFk7XG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCB9ID0gc2Nyb2xsUGFyZW50O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgY2xpZW50SGVpZ2h0ID49IHNjcm9sbEhlaWdodCB8fFxuICAgICAgICBzY3JvbGxUb3AgPT09IDAgJiYgY2xpZW50WSA+IDAgfHxcbiAgICAgICAgc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsVG9wIDw9IGNsaWVudEhlaWdodCAmJiBjbGllbnRZIDwgMClcbiAgICAgICAge1xuICAgICAgICAgIGUuY2FuY2VsYWJsZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHBhc3NpdmU6IGZhbHNlIH0pXTtcblxuXG5cbiAgICAgIHJldHVybiAoKSA9PiBldmVudHMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICAgIH1cblxuICAgIGxldCBwcmV2ZW50ZWQ7XG4gICAgZnVuY3Rpb24gcHJldmVudEJhY2tncm91bmRTY3JvbGwoKSB7XG4gICAgICBpZiAocHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgICAgfVxuICAgICAgcHJldmVudGVkID0gdHJ1ZTtcblxuICAgICAgY29uc3QgeyBzY3JvbGxpbmdFbGVtZW50IH0gPSBkb2N1bWVudDtcbiAgICAgIGNzcyhzY3JvbGxpbmdFbGVtZW50LCB7XG4gICAgICAgIG92ZXJmbG93WTogJ2hpZGRlbicsXG4gICAgICAgIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gICAgICAgIHBhZGRpbmdSaWdodDogd2lkdGgod2luZG93KSAtIHNjcm9sbGluZ0VsZW1lbnQuY2xpZW50V2lkdGggfSk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICBjc3Moc2Nyb2xsaW5nRWxlbWVudCwgeyBvdmVyZmxvd1k6ICcnLCB0b3VjaEFjdGlvbjogJycsIHBhZGRpbmdSaWdodDogJycgfSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlckNoaWxkcmVuKGVsLCBmbikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgIGFwcGx5KGVsLCAobm9kZSkgPT4ge1xuICAgICAgICBpZiAoZm4obm9kZSkpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWVTaXRlQW5jaG9yKGEpIHtcbiAgICAgIHJldHVybiBbJ29yaWdpbicsICdwYXRobmFtZScsICdzZWFyY2gnXS5ldmVyeSgocGFydCkgPT4gYVtwYXJ0XSA9PT0gbG9jYXRpb25bcGFydF0pO1xuICAgIH1cblxuICAgIGxldCBhY3RpdmU7XG5cbiAgICB2YXIgZHJvcCA9IHtcbiAgICAgIG1peGluczogW0NvbnRhaW5lciwgTGF6eWxvYWQsIFBvc2l0aW9uLCBTdHlsZSwgVG9nZ2xhYmxlXSxcblxuICAgICAgYXJnczogJ3BvcycsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIG1vZGU6ICdsaXN0JyxcbiAgICAgICAgdG9nZ2xlOiBCb29sZWFuLFxuICAgICAgICBib3VuZGFyeTogQm9vbGVhbixcbiAgICAgICAgYm91bmRhcnlYOiBCb29sZWFuLFxuICAgICAgICBib3VuZGFyeVk6IEJvb2xlYW4sXG4gICAgICAgIHRhcmdldDogQm9vbGVhbixcbiAgICAgICAgdGFyZ2V0WDogQm9vbGVhbixcbiAgICAgICAgdGFyZ2V0WTogQm9vbGVhbixcbiAgICAgICAgc3RyZXRjaDogQm9vbGVhbixcbiAgICAgICAgZGVsYXlTaG93OiBOdW1iZXIsXG4gICAgICAgIGRlbGF5SGlkZTogTnVtYmVyLFxuICAgICAgICBhdXRvVXBkYXRlOiBCb29sZWFuLFxuICAgICAgICBjbHNEcm9wOiBTdHJpbmcsXG4gICAgICAgIGFuaW1hdGVPdXQ6IEJvb2xlYW4sXG4gICAgICAgIGJnU2Nyb2xsOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBtb2RlOiBbJ2NsaWNrJywgJ2hvdmVyJ10sXG4gICAgICAgIHRvZ2dsZTogJy0gKicsXG4gICAgICAgIGJvdW5kYXJ5OiBmYWxzZSxcbiAgICAgICAgYm91bmRhcnlYOiBmYWxzZSxcbiAgICAgICAgYm91bmRhcnlZOiBmYWxzZSxcbiAgICAgICAgdGFyZ2V0OiBmYWxzZSxcbiAgICAgICAgdGFyZ2V0WDogZmFsc2UsXG4gICAgICAgIHRhcmdldFk6IGZhbHNlLFxuICAgICAgICBzdHJldGNoOiBmYWxzZSxcbiAgICAgICAgZGVsYXlTaG93OiAwLFxuICAgICAgICBkZWxheUhpZGU6IDgwMCxcbiAgICAgICAgYXV0b1VwZGF0ZTogdHJ1ZSxcbiAgICAgICAgY2xzRHJvcDogZmFsc2UsXG4gICAgICAgIGFuaW1hdGVPdXQ6IGZhbHNlLFxuICAgICAgICBiZ1Njcm9sbDogdHJ1ZSxcbiAgICAgICAgYW5pbWF0aW9uOiBbJ3VrLWFuaW1hdGlvbi1mYWRlJ10sXG4gICAgICAgIGNsczogJ3VrLW9wZW4nLFxuICAgICAgICBjb250YWluZXI6IGZhbHNlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgYm91bmRhcnkoX3JlZiwgJGVsKSB7bGV0IHsgYm91bmRhcnksIGJvdW5kYXJ5WCwgYm91bmRhcnlZIH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgcXVlcnkoYm91bmRhcnlYIHx8IGJvdW5kYXJ5LCAkZWwpIHx8IHdpbmRvdyxcbiAgICAgICAgICBxdWVyeShib3VuZGFyeVkgfHwgYm91bmRhcnksICRlbCkgfHwgd2luZG93XTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHRhcmdldChfcmVmMiwgJGVsKSB7bGV0IHsgdGFyZ2V0LCB0YXJnZXRYLCB0YXJnZXRZIH0gPSBfcmVmMjtcbiAgICAgICAgICB0YXJnZXRYID0gdGFyZ2V0WCB8fCB0YXJnZXQgfHwgdGhpcy50YXJnZXRFbDtcbiAgICAgICAgICB0YXJnZXRZID0gdGFyZ2V0WSB8fCB0YXJnZXQgfHwgdGhpcy50YXJnZXRFbDtcblxuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdGFyZ2V0WCA9PT0gdHJ1ZSA/IHdpbmRvdyA6IHF1ZXJ5KHRhcmdldFgsICRlbCksXG4gICAgICAgICAgdGFyZ2V0WSA9PT0gdHJ1ZSA/IHdpbmRvdyA6IHF1ZXJ5KHRhcmdldFksICRlbCldO1xuXG4gICAgICAgIH0gfSxcblxuXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSBuZXcgTW91c2VUcmFja2VyKCk7XG4gICAgICB9LFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLmNsc0Ryb3AgPSB0aGlzLiRwcm9wcy5jbHNEcm9wIHx8IFwidWstXCIgKyB0aGlzLiRvcHRpb25zLm5hbWU7XG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0Ryb3ApO1xuXG4gICAgICAgIGlmICh0aGlzLnRvZ2dsZSAmJiAhdGhpcy50YXJnZXRFbCkge1xuICAgICAgICAgIHRoaXMudGFyZ2V0RWwgPSB0aGlzLiRjcmVhdGUoJ3RvZ2dsZScsIHF1ZXJ5KHRoaXMudG9nZ2xlLCB0aGlzLiRlbCksIHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy4kZWwsXG4gICAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUgfSkuXG4gICAgICAgICAgJGVsO1xuICAgICAgICAgIGF0dHIodGhpcy50YXJnZXRFbCwgJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLmxhenlsb2FkKHRoaXMudGFyZ2V0RWwpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICB0aGlzLmhpZGUoZmFsc2UpO1xuICAgICAgICAgIGFjdGl2ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiBcIi5cIiArIHRoaXMuY2xzRHJvcCArIFwiLWNsb3NlXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuICdhW2hyZWYqPVwiI1wiXSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfcmVmMykge2xldCB7IGRlZmF1bHRQcmV2ZW50ZWQsIGN1cnJlbnQgfSA9IF9yZWYzO1xuICAgICAgICAgIGNvbnN0IHsgaGFzaCB9ID0gY3VycmVudDtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIWRlZmF1bHRQcmV2ZW50ZWQgJiZcbiAgICAgICAgICBoYXNoICYmXG4gICAgICAgICAgaXNTYW1lU2l0ZUFuY2hvcihjdXJyZW50KSAmJlxuICAgICAgICAgICF3aXRoaW4oaGFzaCwgdGhpcy4kZWwpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnYmVmb3Jlc2Nyb2xsJyxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd0b2dnbGUnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcihlLCB0b2dnbGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KHRvZ2dsZSA9PSBudWxsID8gdm9pZCAwIDogdG9nZ2xlLiRlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvZ2dsZXNob3cnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcihlLCB0b2dnbGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5zaG93KHRvZ2dsZSA9PSBudWxsID8gdm9pZCAwIDogdG9nZ2xlLiRlbCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd0b2dnbGVoaWRlJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoIW1hdGNoZXModGhpcy4kZWwsICc6Zm9jdXMsOmhvdmVyJykpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogcG9pbnRlckVudGVyICsgXCIgZm9jdXNpblwiLFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gaW5jbHVkZXModGhpcy5tb2RlLCAnaG92ZXInKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAoIWlzVG91Y2goZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcnMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6IHBvaW50ZXJMZWF2ZSArIFwiIGZvY3Vzb3V0XCIsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdob3ZlcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmICghaXNUb3VjaChlKSAmJiBlLnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvZ2dsZWQnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcihlLCB0b2dnbGVkKSB7XG4gICAgICAgICAgaWYgKCF0b2dnbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jbGVhclRpbWVycygpO1xuICAgICAgICAgIHRoaXMucG9zaXRpb24oKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Nob3cnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBhY3RpdmUgPSB0aGlzO1xuXG4gICAgICAgICAgdGhpcy50cmFja2VyLmluaXQoKTtcblxuICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHRoaXMuJGVtaXQoKTtcbiAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IFtcbiAgICAgICAgICBvbihcbiAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICBwb2ludGVyRG93biQxLFxuICAgICAgICAgIChfcmVmNCkgPT4ge2xldCB7IHRhcmdldCB9ID0gX3JlZjQ7cmV0dXJuIChcbiAgICAgICAgICAgICAgIXdpdGhpbih0YXJnZXQsIHRoaXMuJGVsKSAmJlxuICAgICAgICAgICAgICBvbmNlKFxuICAgICAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICAgICAgcG9pbnRlclVwJDEgKyBcIiBcIiArIHBvaW50ZXJDYW5jZWwgKyBcIiBzY3JvbGxcIixcbiAgICAgICAgICAgICAgKF9yZWY1KSA9PiB7bGV0IHsgZGVmYXVsdFByZXZlbnRlZCwgdHlwZSwgdGFyZ2V0OiBuZXdUYXJnZXQgfSA9IF9yZWY1O1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhZGVmYXVsdFByZXZlbnRlZCAmJlxuICAgICAgICAgICAgICAgIHR5cGUgPT09IHBvaW50ZXJVcCQxICYmXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID09PSBuZXdUYXJnZXQgJiZcbiAgICAgICAgICAgICAgICAhKHRoaXMudGFyZ2V0RWwgJiYgd2l0aGluKHRhcmdldCwgdGhpcy50YXJnZXRFbCkpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0cnVlKSk7fSksXG5cblxuXG4gICAgICAgICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG5cbiAgICAgICAgICBvbih3aW5kb3csICdyZXNpemUnLCB1cGRhdGUpLFxuXG4gICAgICAgICAgKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gb2JzZXJ2ZVJlc2l6ZShcbiAgICAgICAgICAgIHNjcm9sbFBhcmVudHModGhpcy4kZWwpLmNvbmNhdCh0aGlzLnRhcmdldCksXG4gICAgICAgICAgICB1cGRhdGUpO1xuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIH0pKCksXG5cbiAgICAgICAgICAuLi4odGhpcy5hdXRvVXBkYXRlID9cbiAgICAgICAgICBbXG4gICAgICAgICAgb24oW2RvY3VtZW50LCBzY3JvbGxQYXJlbnRzKHRoaXMuJGVsKV0sICdzY3JvbGwnLCB1cGRhdGUsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6IHRydWUgfSldIDpcblxuXG4gICAgICAgICAgW10pLFxuXG4gICAgICAgICAgLi4uKHRoaXMuYmdTY3JvbGwgP1xuICAgICAgICAgIFtdIDpcbiAgICAgICAgICBbcHJldmVudE92ZXJzY3JvbGwodGhpcy4kZWwpLCBwcmV2ZW50QmFja2dyb3VuZFNjcm9sbCgpXSldO1xuXG5cbiAgICAgICAgICBvbmNlKHRoaXMuJGVsLCAnaGlkZScsICgpID0+IGhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IGhhbmRsZXIoKSksIHtcbiAgICAgICAgICAgIHNlbGY6IHRydWUgfSk7XG5cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2JlZm9yZWhpZGUnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICB0aGlzLmNsZWFyVGltZXJzKCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdoaWRlJyxcblxuICAgICAgICBoYW5kbGVyKF9yZWY2KSB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmNjtcbiAgICAgICAgICBpZiAodGhpcy4kZWwgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgYWN0aXZlID1cbiAgICAgICAgICAgIGFjdGl2ZSA9PT0gbnVsbCAmJiB3aXRoaW4odGFyZ2V0LCB0aGlzLiRlbCkgJiYgdGhpcy5pc1RvZ2dsZWQoKSA/XG4gICAgICAgICAgICB0aGlzIDpcbiAgICAgICAgICAgIGFjdGl2ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhY3RpdmUgPSB0aGlzLmlzQWN0aXZlKCkgPyBudWxsIDogYWN0aXZlO1xuICAgICAgICAgIHRoaXMudHJhY2tlci5jYW5jZWwoKTtcbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICB3cml0ZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSAmJiAhaGFzQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRW50ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBzaG93KHRhcmdldCwgZGVsYXkpIHtpZiAodGFyZ2V0ID09PSB2b2lkIDApIHt0YXJnZXQgPSB0aGlzLnRhcmdldEVsO31pZiAoZGVsYXkgPT09IHZvaWQgMCkge2RlbGF5ID0gdHJ1ZTt9XG4gICAgICAgICAgaWYgKHRoaXMuaXNUb2dnbGVkKCkgJiYgdGFyZ2V0ICYmIHRoaXMudGFyZ2V0RWwgJiYgdGFyZ2V0ICE9PSB0aGlzLnRhcmdldEVsKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnRhcmdldEVsID0gdGFyZ2V0O1xuXG4gICAgICAgICAgdGhpcy5jbGVhclRpbWVycygpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgIGlmIChkZWxheSAmJiBhY3RpdmUuaXNEZWxheWluZykge1xuICAgICAgICAgICAgICB0aGlzLnNob3dUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gbWF0Y2hlcyh0YXJnZXQsICc6aG92ZXInKSAmJiB0aGlzLnNob3coKSwgMTApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBwcmV2O1xuICAgICAgICAgICAgd2hpbGUgKGFjdGl2ZSAmJiBwcmV2ICE9PSBhY3RpdmUgJiYgIXdpdGhpbih0aGlzLiRlbCwgYWN0aXZlLiRlbCkpIHtcbiAgICAgICAgICAgICAgcHJldiA9IGFjdGl2ZTtcbiAgICAgICAgICAgICAgYWN0aXZlLmhpZGUoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5jb250YWluZXIgJiYgcGFyZW50KHRoaXMuJGVsKSAhPT0gdGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGFwcGVuZCh0aGlzLmNvbnRhaW5lciwgdGhpcy4kZWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc2hvd1RpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgICAoKSA9PiB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwsIHRydWUpLFxuICAgICAgICAgIGRlbGF5ICYmIHRoaXMuZGVsYXlTaG93IHx8IDApO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZShkZWxheSwgYW5pbWF0ZSkge2lmIChkZWxheSA9PT0gdm9pZCAwKSB7ZGVsYXkgPSB0cnVlO31pZiAoYW5pbWF0ZSA9PT0gdm9pZCAwKSB7YW5pbWF0ZSA9IHRydWU7fVxuICAgICAgICAgIGNvbnN0IGhpZGUgPSAoKSA9PiB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwsIGZhbHNlLCB0aGlzLmFuaW1hdGVPdXQgJiYgYW5pbWF0ZSk7XG5cbiAgICAgICAgICB0aGlzLmNsZWFyVGltZXJzKCk7XG5cbiAgICAgICAgICB0aGlzLmlzRGVsYXlpbmcgPSBnZXRQb3NpdGlvbmVkRWxlbWVudHModGhpcy4kZWwpLnNvbWUoKGVsKSA9PlxuICAgICAgICAgIHRoaXMudHJhY2tlci5tb3Zlc1RvKGVsKSk7XG5cblxuICAgICAgICAgIGlmIChkZWxheSAmJiB0aGlzLmlzRGVsYXlpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZVRpbWVyID0gc2V0VGltZW91dCh0aGlzLmhpZGUsIDUwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRlbGF5ICYmIHRoaXMuZGVsYXlIaWRlKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVUaW1lciA9IHNldFRpbWVvdXQoaGlkZSwgdGhpcy5kZWxheUhpZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyVGltZXJzKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNob3dUaW1lcik7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNob3dUaW1lciA9IG51bGw7XG4gICAgICAgICAgdGhpcy5oaWRlVGltZXIgPSBudWxsO1xuICAgICAgICAgIHRoaXMuaXNEZWxheWluZyA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQWN0aXZlKCkge1xuICAgICAgICAgIHJldHVybiBhY3RpdmUgPT09IHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zaXRpb24oKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRHJvcCArIFwiLXN0YWNrXCIpO1xuICAgICAgICAgIGF0dHIodGhpcy4kZWwsICdzdHlsZScsIHRoaXMuX3N0eWxlKTtcblxuICAgICAgICAgIC8vIEVuc3VyZSBub25lIHBvc2l0aW9uZWQgZWxlbWVudCBkb2VzIG5vdCBnZW5lcmF0ZSBzY3JvbGxiYXJzXG4gICAgICAgICAgdGhpcy4kZWwuaGlkZGVuID0gdHJ1ZTtcblxuICAgICAgICAgIGNvbnN0IHZpZXdwb3J0cyA9IHRoaXMudGFyZ2V0Lm1hcCgodGFyZ2V0KSA9PiBvZmZzZXRWaWV3cG9ydChzY3JvbGxQYXJlbnRzKHRhcmdldClbMF0pKTtcbiAgICAgICAgICBjb25zdCB2aWV3cG9ydE9mZnNldCA9IHRoaXMuZ2V0Vmlld3BvcnRPZmZzZXQodGhpcy4kZWwpO1xuXG4gICAgICAgICAgY29uc3QgZGlycyA9IFtcbiAgICAgICAgICBbMCwgWyd4JywgJ3dpZHRoJywgJ2xlZnQnLCAncmlnaHQnXV0sXG4gICAgICAgICAgWzEsIFsneScsICdoZWlnaHQnLCAndG9wJywgJ2JvdHRvbSddXV07XG5cblxuICAgICAgICAgIGZvciAoY29uc3QgW2ksIFtheGlzLCBwcm9wXV0gb2YgZGlycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXhpcyAhPT0gYXhpcyAmJiBpbmNsdWRlcyhbYXhpcywgdHJ1ZV0sIHRoaXMuc3RyZXRjaCkpIHtcbiAgICAgICAgICAgICAgY3NzKHRoaXMuJGVsLCB7XG4gICAgICAgICAgICAgICAgW3Byb3BdOiBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBvZmZzZXQodGhpcy5ib3VuZGFyeVtpXSlbcHJvcF0sXG4gICAgICAgICAgICAgICAgdmlld3BvcnRzW2ldW3Byb3BdIC0gMiAqIHZpZXdwb3J0T2Zmc2V0KSxcblxuICAgICAgICAgICAgICAgIFtcIm92ZXJmbG93LVwiICsgYXhpc106ICdhdXRvJyB9KTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG1heFdpZHRoID0gdmlld3BvcnRzWzBdLndpZHRoIC0gMiAqIHZpZXdwb3J0T2Zmc2V0O1xuXG4gICAgICAgICAgaWYgKHRoaXMuJGVsLm9mZnNldFdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0Ryb3AgKyBcIi1zdGFja1wiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjc3ModGhpcy4kZWwsICdtYXhXaWR0aCcsIG1heFdpZHRoKTtcblxuICAgICAgICAgIHRoaXMuJGVsLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpcy5wb3NpdGlvbkF0KHRoaXMuJGVsLCB0aGlzLnRhcmdldCwgdGhpcy5ib3VuZGFyeSk7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IFtpLCBbYXhpcywgcHJvcCwgc3RhcnQsIGVuZF1dIG9mIGRpcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF4aXMgPT09IGF4aXMgJiYgaW5jbHVkZXMoW2F4aXMsIHRydWVdLCB0aGlzLnN0cmV0Y2gpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uT2Zmc2V0ID0gTWF0aC5hYnModGhpcy5nZXRQb3NpdGlvbk9mZnNldCh0aGlzLiRlbCkpO1xuICAgICAgICAgICAgICBjb25zdCB0YXJnZXRPZmZzZXQgPSBvZmZzZXQodGhpcy50YXJnZXRbaV0pO1xuICAgICAgICAgICAgICBjb25zdCBlbE9mZnNldCA9IG9mZnNldCh0aGlzLiRlbCk7XG5cbiAgICAgICAgICAgICAgY3NzKHRoaXMuJGVsLCB7XG4gICAgICAgICAgICAgICAgW3Byb3BdOlxuICAgICAgICAgICAgICAgICh0YXJnZXRPZmZzZXRbc3RhcnRdID4gZWxPZmZzZXRbc3RhcnRdID9cbiAgICAgICAgICAgICAgICB0YXJnZXRPZmZzZXRbc3RhcnRdIC1cbiAgICAgICAgICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICAgICAgICBvZmZzZXQodGhpcy5ib3VuZGFyeVtpXSlbc3RhcnRdLFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0c1tpXVtzdGFydF0gKyB2aWV3cG9ydE9mZnNldCkgOlxuXG4gICAgICAgICAgICAgICAgTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgb2Zmc2V0KHRoaXMuYm91bmRhcnlbaV0pW2VuZF0sXG4gICAgICAgICAgICAgICAgdmlld3BvcnRzW2ldW2VuZF0gLSB2aWV3cG9ydE9mZnNldCkgLVxuICAgICAgICAgICAgICAgIHRhcmdldE9mZnNldFtlbmRdKSAtIHBvc2l0aW9uT2Zmc2V0LFxuICAgICAgICAgICAgICAgIFtcIm92ZXJmbG93LVwiICsgYXhpc106ICdhdXRvJyB9KTtcblxuXG4gICAgICAgICAgICAgIHRoaXMucG9zaXRpb25BdCh0aGlzLiRlbCwgdGhpcy50YXJnZXQsIHRoaXMuYm91bmRhcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb25lZEVsZW1lbnRzKGVsKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGFwcGx5KGVsLCAoZWwpID0+IGNzcyhlbCwgJ3Bvc2l0aW9uJykgIT09ICdzdGF0aWMnICYmIHJlc3VsdC5wdXNoKGVsKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBmb3JtQ3VzdG9tID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3NdLFxuXG4gICAgICBhcmdzOiAndGFyZ2V0JyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdGFyZ2V0OiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICB0YXJnZXQ6IGZhbHNlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgaW5wdXQoXywgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuICQoc2VsSW5wdXQsICRlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRhcmdldChfcmVmLCAkZWwpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRhcmdldCAmJiAoXG4gICAgICAgICAgICB0YXJnZXQgPT09IHRydWUgJiYgcGFyZW50KHRoaXMuaW5wdXQpID09PSAkZWwgJiYgdGhpcy5pbnB1dC5uZXh0RWxlbWVudFNpYmxpbmcgfHxcbiAgICAgICAgICAgICQodGFyZ2V0LCAkZWwpKSk7XG5cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHVwZGF0ZSgpIHt2YXIgX2lucHV0JGZpbGVzO1xuICAgICAgICBjb25zdCB7IHRhcmdldCwgaW5wdXQgfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3B0aW9uO1xuICAgICAgICBjb25zdCBwcm9wID0gaXNJbnB1dCh0YXJnZXQpID8gJ3ZhbHVlJyA6ICd0ZXh0Q29udGVudCc7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0YXJnZXRbcHJvcF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKF9pbnB1dCRmaWxlcyA9IGlucHV0LmZpbGVzKSAhPSBudWxsICYmIF9pbnB1dCRmaWxlc1swXSA/XG4gICAgICAgIGlucHV0LmZpbGVzWzBdLm5hbWUgOlxuICAgICAgICBtYXRjaGVzKGlucHV0LCAnc2VsZWN0JykgJiYgKFxuICAgICAgICBvcHRpb24gPSAkJCgnb3B0aW9uJywgaW5wdXQpLmZpbHRlcigoZWwpID0+IGVsLnNlbGVjdGVkKVswXSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICA/IG9wdGlvbi50ZXh0Q29udGVudCA6XG4gICAgICAgIGlucHV0LnZhbHVlO1xuXG4gICAgICAgIGlmIChwcmV2ICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NoYW5nZScsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdyZXNldCcsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb3Nlc3QodGhpcy4kZWwsICdmb3JtJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCk7XG4gICAgICAgIH0gfV0gfTtcblxuICAgIHZhciBNYXJnaW4gPSB7XG4gICAgICBtaXhpbnM6IFtSZXNpemVdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBtYXJnaW46IFN0cmluZyxcbiAgICAgICAgZmlyc3RDb2x1bW46IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1hcmdpbjogJ3VrLW1hcmdpbi1zbWFsbC10b3AnLFxuICAgICAgICBmaXJzdENvbHVtbjogJ3VrLWZpcnN0LWNvbHVtbicgfSxcblxuXG4gICAgICByZXNpemVUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuJGVsLCAuLi50b0FycmF5KHRoaXMuJGVsLmNoaWxkcmVuKV07XG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJPYnNlcnZlcihcbiAgICAgICAgb2JzZXJ2ZU11dGF0aW9uKHRoaXMuJGVsLCAoKSA9PiB0aGlzLiRyZXNldCgpLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlIH0pKTtcblxuXG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBjb25zdCByb3dzID0gZ2V0Um93cyh0aGlzLiRlbC5jaGlsZHJlbik7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93cyxcbiAgICAgICAgICAgIGNvbHVtbnM6IGdldENvbHVtbnMocm93cykgfTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYpIHtsZXQgeyBjb2x1bW5zLCByb3dzIH0gPSBfcmVmO1xuICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIHJvdykge1xuICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhjb2x1bW4sIHRoaXMubWFyZ2luLCByb3dzWzBdICE9PSByb3cpO1xuICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhjb2x1bW4sIHRoaXMuZmlyc3RDb2x1bW4sIGNvbHVtbnNbMF0uaW5jbHVkZXMoY29sdW1uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0Um93cyhpdGVtcykge1xuICAgICAgcmV0dXJuIHNvcnRCeShpdGVtcywgJ3RvcCcsICdib3R0b20nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb2x1bW5zKHJvd3MpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSBbXTtcblxuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICBjb25zdCBzb3J0ZWQgPSBzb3J0Qnkocm93LCAnbGVmdCcsICdyaWdodCcpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNvcnRlZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbHVtbnNbal0gPSBjb2x1bW5zW2pdID8gY29sdW1uc1tqXS5jb25jYXQoc29ydGVkW2pdKSA6IHNvcnRlZFtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNSdGwgPyBjb2x1bW5zLnJldmVyc2UoKSA6IGNvbHVtbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydEJ5KGl0ZW1zLCBzdGFydFByb3AsIGVuZFByb3ApIHtcbiAgICAgIGNvbnN0IHNvcnRlZCA9IFtbXV07XG5cbiAgICAgIGZvciAoY29uc3QgZWwgb2YgaXRlbXMpIHtcbiAgICAgICAgaWYgKCFpc1Zpc2libGUoZWwpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGltID0gZ2V0T2Zmc2V0KGVsKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gc29ydGVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudCA9IHNvcnRlZFtpXTtcblxuICAgICAgICAgIGlmICghY3VycmVudFswXSkge1xuICAgICAgICAgICAgY3VycmVudC5wdXNoKGVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBzdGFydERpbTtcbiAgICAgICAgICBpZiAoY3VycmVudFswXS5vZmZzZXRQYXJlbnQgPT09IGVsLm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgc3RhcnREaW0gPSBnZXRPZmZzZXQoY3VycmVudFswXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpbSA9IGdldE9mZnNldChlbCwgdHJ1ZSk7XG4gICAgICAgICAgICBzdGFydERpbSA9IGdldE9mZnNldChjdXJyZW50WzBdLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGltW3N0YXJ0UHJvcF0gPj0gc3RhcnREaW1bZW5kUHJvcF0gLSAxICYmIGRpbVtzdGFydFByb3BdICE9PSBzdGFydERpbVtzdGFydFByb3BdKSB7XG4gICAgICAgICAgICBzb3J0ZWQucHVzaChbZWxdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaW1bZW5kUHJvcF0gLSAxID4gc3RhcnREaW1bc3RhcnRQcm9wXSB8fCBkaW1bc3RhcnRQcm9wXSA9PT0gc3RhcnREaW1bc3RhcnRQcm9wXSkge1xuICAgICAgICAgICAgY3VycmVudC5wdXNoKGVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBzb3J0ZWQudW5zaGlmdChbZWxdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc29ydGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE9mZnNldChlbGVtZW50LCBvZmZzZXQpIHtpZiAob2Zmc2V0ID09PSB2b2lkIDApIHtvZmZzZXQgPSBmYWxzZTt9XG4gICAgICBsZXQgeyBvZmZzZXRUb3AsIG9mZnNldExlZnQsIG9mZnNldEhlaWdodCwgb2Zmc2V0V2lkdGggfSA9IGVsZW1lbnQ7XG5cbiAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgW29mZnNldFRvcCwgb2Zmc2V0TGVmdF0gPSBvZmZzZXRQb3NpdGlvbihlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICAgIGxlZnQ6IG9mZnNldExlZnQsXG4gICAgICAgIGJvdHRvbTogb2Zmc2V0VG9wICsgb2Zmc2V0SGVpZ2h0LFxuICAgICAgICByaWdodDogb2Zmc2V0TGVmdCArIG9mZnNldFdpZHRoIH07XG5cbiAgICB9XG5cbiAgICB2YXIgU2Nyb2xsID0ge1xuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICByZWdpc3RlclNjcm9sbExpc3RlbmVyKHRoaXMuX3VpZCwgKCkgPT4gdGhpcy4kZW1pdCgnc2Nyb2xsJykpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB1bnJlZ2lzdGVyU2Nyb2xsTGlzdGVuZXIodGhpcy5fdWlkKTtcbiAgICAgIH0gfTtcblxuXG4gICAgY29uc3Qgc2Nyb2xsTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIGxldCB1bmJpbmRTY3JvbGxMaXN0ZW5lcjtcbiAgICBmdW5jdGlvbiByZWdpc3RlclNjcm9sbExpc3RlbmVyKGlkLCBsaXN0ZW5lcikge1xuICAgICAgdW5iaW5kU2Nyb2xsTGlzdGVuZXIgPVxuICAgICAgdW5iaW5kU2Nyb2xsTGlzdGVuZXIgfHxcbiAgICAgIG9uKHdpbmRvdywgJ3Njcm9sbCcsICgpID0+IHNjcm9sbExpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoKSksIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSB9KTtcblxuXG4gICAgICBzY3JvbGxMaXN0ZW5lcnMuc2V0KGlkLCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5yZWdpc3RlclNjcm9sbExpc3RlbmVyKGlkKSB7XG4gICAgICBzY3JvbGxMaXN0ZW5lcnMuZGVsZXRlKGlkKTtcbiAgICAgIGlmICh1bmJpbmRTY3JvbGxMaXN0ZW5lciAmJiAhc2Nyb2xsTGlzdGVuZXJzLnNpemUpIHtcbiAgICAgICAgdW5iaW5kU2Nyb2xsTGlzdGVuZXIoKTtcbiAgICAgICAgdW5iaW5kU2Nyb2xsTGlzdGVuZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBncmlkID0ge1xuICAgICAgZXh0ZW5kczogTWFyZ2luLFxuXG4gICAgICBtaXhpbnM6IFtDbGFzc10sXG5cbiAgICAgIG5hbWU6ICdncmlkJyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbWFzb25yeTogQm9vbGVhbixcbiAgICAgICAgcGFyYWxsYXg6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWFyZ2luOiAndWstZ3JpZC1tYXJnaW4nLFxuICAgICAgICBjbHNTdGFjazogJ3VrLWdyaWQtc3RhY2snLFxuICAgICAgICBtYXNvbnJ5OiBmYWxzZSxcbiAgICAgICAgcGFyYWxsYXg6IDAgfSxcblxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMubWFzb25yeSAmJiBhZGRDbGFzcyh0aGlzLiRlbCwgJ3VrLWZsZXgtdG9wIHVrLWZsZXgtd3JhcC10b3AnKTtcbiAgICAgICAgdGhpcy5wYXJhbGxheCAmJiByZWdpc3RlclNjcm9sbExpc3RlbmVyKHRoaXMuX3VpZCwgKCkgPT4gdGhpcy4kZW1pdCgnc2Nyb2xsJykpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB1bnJlZ2lzdGVyU2Nyb2xsTGlzdGVuZXIodGhpcy5fdWlkKTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZTogW1xuICAgICAge1xuICAgICAgICB3cml0ZShfcmVmKSB7bGV0IHsgY29sdW1ucyB9ID0gX3JlZjtcbiAgICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNTdGFjaywgY29sdW1ucy5sZW5ndGggPCAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSxcblxuXG4gICAgICB7XG4gICAgICAgIHJlYWQoZGF0YSkge1xuICAgICAgICAgIGxldCB7IGNvbHVtbnMsIHJvd3MgfSA9IGRhdGE7XG5cbiAgICAgICAgICAvLyBGaWx0ZXIgY29tcG9uZW50IG1ha2VzIGVsZW1lbnRzIHBvc2l0aW9uZWQgYWJzb2x1dGVcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIWNvbHVtbnMubGVuZ3RoIHx8XG4gICAgICAgICAgIXRoaXMubWFzb25yeSAmJiAhdGhpcy5wYXJhbGxheCB8fFxuICAgICAgICAgIHBvc2l0aW9uZWRBYnNvbHV0ZSh0aGlzLiRlbCkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGF0YS50cmFuc2xhdGVzID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHRyYW5zbGF0ZXMgPSBmYWxzZTtcblxuICAgICAgICAgIGNvbnN0IG5vZGVzID0gY2hpbGRyZW4odGhpcy4kZWwpO1xuICAgICAgICAgIGNvbnN0IGNvbHVtbkhlaWdodHMgPSBnZXRDb2x1bW5IZWlnaHRzKGNvbHVtbnMpO1xuICAgICAgICAgIGNvbnN0IG1hcmdpbiA9IGdldE1hcmdpblRvcChub2RlcywgdGhpcy5tYXJnaW4pICogKHJvd3MubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgY29uc3QgZWxIZWlnaHQgPSBNYXRoLm1heCguLi5jb2x1bW5IZWlnaHRzKSArIG1hcmdpbjtcblxuICAgICAgICAgIGlmICh0aGlzLm1hc29ucnkpIHtcbiAgICAgICAgICAgIGNvbHVtbnMgPSBjb2x1bW5zLm1hcCgoY29sdW1uKSA9PiBzb3J0QnkkMShjb2x1bW4sICdvZmZzZXRUb3AnKSk7XG4gICAgICAgICAgICB0cmFuc2xhdGVzID0gZ2V0VHJhbnNsYXRlcyhyb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcGFkZGluZyA9IE1hdGguYWJzKHRoaXMucGFyYWxsYXgpO1xuICAgICAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgICAgICBwYWRkaW5nID0gY29sdW1uSGVpZ2h0cy5yZWR1Y2UoXG4gICAgICAgICAgICAobmV3UGFkZGluZywgaGd0LCBpKSA9PlxuICAgICAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgICBuZXdQYWRkaW5nLFxuICAgICAgICAgICAgaGd0ICsgbWFyZ2luICsgKGkgJSAyID8gcGFkZGluZyA6IHBhZGRpbmcgLyA4KSAtIGVsSGVpZ2h0KSxcblxuICAgICAgICAgICAgMCk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4geyBwYWRkaW5nLCBjb2x1bW5zLCB0cmFuc2xhdGVzLCBoZWlnaHQ6IHRyYW5zbGF0ZXMgPyBlbEhlaWdodCA6ICcnIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoX3JlZjIpIHtsZXQgeyBoZWlnaHQsIHBhZGRpbmcgfSA9IF9yZWYyO1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ3BhZGRpbmdCb3R0b20nLCBwYWRkaW5nIHx8ICcnKTtcbiAgICAgICAgICBoZWlnaHQgIT09IGZhbHNlICYmIGNzcyh0aGlzLiRlbCwgJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0sXG5cblxuICAgICAge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGlmICh0aGlzLnBhcmFsbGF4ICYmIHBvc2l0aW9uZWRBYnNvbHV0ZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2Nyb2xsZWQ6IHRoaXMucGFyYWxsYXggP1xuICAgICAgICAgICAgc2Nyb2xsZWRPdmVyKHRoaXMuJGVsKSAqIE1hdGguYWJzKHRoaXMucGFyYWxsYXgpIDpcbiAgICAgICAgICAgIGZhbHNlIH07XG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmMykge2xldCB7IGNvbHVtbnMsIHNjcm9sbGVkLCB0cmFuc2xhdGVzIH0gPSBfcmVmMztcbiAgICAgICAgICBpZiAoc2Nyb2xsZWQgPT09IGZhbHNlICYmICF0cmFuc2xhdGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29sdW1ucy5mb3JFYWNoKChjb2x1bW4sIGkpID0+XG4gICAgICAgICAgY29sdW1uLmZvckVhY2goKGVsLCBqKSA9PlxuICAgICAgICAgIGNzcyhcbiAgICAgICAgICBlbCxcbiAgICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgICAhc2Nyb2xsZWQgJiYgIXRyYW5zbGF0ZXMgP1xuICAgICAgICAgICcnIDogXCJ0cmFuc2xhdGVZKFwiICsgKFxuXG4gICAgICAgICAgKHRyYW5zbGF0ZXMgJiYgLXRyYW5zbGF0ZXNbaV1bal0pICsgKFxuICAgICAgICAgIHNjcm9sbGVkID8gaSAlIDIgPyBzY3JvbGxlZCA6IHNjcm9sbGVkIC8gOCA6IDApKSArIFwicHgpXCIpKSk7XG5cblxuXG5cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsnc2Nyb2xsJywgJ3Jlc2l6ZSddIH1dIH07XG5cblxuXG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbmVkQWJzb2x1dGUoZWwpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbihlbCkuc29tZSgoZWwpID0+IGNzcyhlbCwgJ3Bvc2l0aW9uJykgPT09ICdhYnNvbHV0ZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRyYW5zbGF0ZXMocm93cywgY29sdW1ucykge1xuICAgICAgY29uc3Qgcm93SGVpZ2h0cyA9IHJvd3MubWFwKChyb3cpID0+IE1hdGgubWF4KC4uLnJvdy5tYXAoKGVsKSA9PiBlbC5vZmZzZXRIZWlnaHQpKSk7XG5cbiAgICAgIHJldHVybiBjb2x1bW5zLm1hcCgoZWxlbWVudHMpID0+IHtcbiAgICAgICAgbGV0IHByZXYgPSAwO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMubWFwKFxuICAgICAgICAoZWxlbWVudCwgcm93KSA9PlxuICAgICAgICBwcmV2ICs9IHJvdyA/IHJvd0hlaWdodHNbcm93IC0gMV0gLSBlbGVtZW50c1tyb3cgLSAxXS5vZmZzZXRIZWlnaHQgOiAwKTtcblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TWFyZ2luVG9wKG5vZGVzLCBjbHMpIHtcbiAgICAgIGNvbnN0IFtub2RlXSA9IG5vZGVzLmZpbHRlcigoZWwpID0+IGhhc0NsYXNzKGVsLCBjbHMpKTtcblxuICAgICAgcmV0dXJuIHRvRmxvYXQobm9kZSA/IGNzcyhub2RlLCAnbWFyZ2luVG9wJykgOiBjc3Mobm9kZXNbMF0sICdwYWRkaW5nTGVmdCcpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb2x1bW5IZWlnaHRzKGNvbHVtbnMpIHtcbiAgICAgIHJldHVybiBjb2x1bW5zLm1hcCgoY29sdW1uKSA9PiBjb2x1bW4ucmVkdWNlKChzdW0sIGVsKSA9PiBzdW0gKyBlbC5vZmZzZXRIZWlnaHQsIDApKTtcbiAgICB9XG5cbiAgICB2YXIgaGVpZ2h0TWF0Y2ggPSB7XG4gICAgICBtaXhpbnM6IFtSZXNpemVdLFxuXG4gICAgICBhcmdzOiAndGFyZ2V0JyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdGFyZ2V0OiBTdHJpbmcsXG4gICAgICAgIHJvdzogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0OiAnPiAqJyxcbiAgICAgICAgcm93OiB0cnVlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgICBnZXQoX3JlZiwgJGVsKSB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuICQkKHRhcmdldCwgJGVsKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goKSB7XG4gICAgICAgICAgICB0aGlzLiRyZXNldCgpO1xuICAgICAgICAgIH0gfSB9LFxuXG5cblxuICAgICAgcmVzaXplVGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLiRlbCwgLi4udGhpcy5lbGVtZW50c107XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93czogKHRoaXMucm93ID8gZ2V0Um93cyh0aGlzLmVsZW1lbnRzKSA6IFt0aGlzLmVsZW1lbnRzXSkubWFwKG1hdGNoJDEpIH07XG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmMikge2xldCB7IHJvd3MgfSA9IF9yZWYyO1xuICAgICAgICAgIGZvciAoY29uc3QgeyBoZWlnaHRzLCBlbGVtZW50cyB9IG9mIHJvd3MpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsLCBpKSA9PiBjc3MoZWwsICdtaW5IZWlnaHQnLCBoZWlnaHRzW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gbWF0Y2gkMShlbGVtZW50cykge1xuICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHsgaGVpZ2h0czogWycnXSwgZWxlbWVudHMgfTtcbiAgICAgIH1cblxuICAgICAgY3NzKGVsZW1lbnRzLCAnbWluSGVpZ2h0JywgJycpO1xuICAgICAgbGV0IGhlaWdodHMgPSBlbGVtZW50cy5tYXAoZ2V0SGVpZ2h0KTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLmhlaWdodHMpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHRzOiBlbGVtZW50cy5tYXAoKGVsLCBpKSA9PiBoZWlnaHRzW2ldLnRvRml4ZWQoMikgPT09IG1heC50b0ZpeGVkKDIpID8gJycgOiBtYXgpLFxuICAgICAgICBlbGVtZW50cyB9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SGVpZ2h0KGVsZW1lbnQpIHtcbiAgICAgIGxldCBzdHlsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFpc1Zpc2libGUoZWxlbWVudCkpIHtcbiAgICAgICAgc3R5bGUgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIGNzcyhlbGVtZW50LCAnZGlzcGxheScsICdibG9jaycsICdpbXBvcnRhbnQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGVpZ2h0ID0gZGltZW5zaW9ucyQxKGVsZW1lbnQpLmhlaWdodCAtIGJveE1vZGVsQWRqdXN0KGVsZW1lbnQsICdoZWlnaHQnLCAnY29udGVudC1ib3gnKTtcblxuICAgICAgaWYgKHN0eWxlICE9PSBmYWxzZSkge1xuICAgICAgICBjc3MoZWxlbWVudCwgJ2Rpc3BsYXknLCBzdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuXG4gICAgdmFyIGhlaWdodFZpZXdwb3J0ID0ge1xuICAgICAgbWl4aW5zOiBbUmVzaXplXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZXhwYW5kOiBCb29sZWFuLFxuICAgICAgICBvZmZzZXRUb3A6IEJvb2xlYW4sXG4gICAgICAgIG9mZnNldEJvdHRvbTogQm9vbGVhbixcbiAgICAgICAgbWluSGVpZ2h0OiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGV4cGFuZDogZmFsc2UsXG4gICAgICAgIG9mZnNldFRvcDogZmFsc2UsXG4gICAgICAgIG9mZnNldEJvdHRvbTogZmFsc2UsXG4gICAgICAgIG1pbkhlaWdodDogMCB9LFxuXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBvZmZzZXRUb3AgY2hhbmdlXG4gICAgICAgIHJldHVybiBbdGhpcy4kZWwsIC4uLnNjcm9sbFBhcmVudHModGhpcy4kZWwsIC9hdXRvfHNjcm9sbC8pXTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKF9yZWYpIHtsZXQgeyBtaW5IZWlnaHQ6IHByZXYgfSA9IF9yZWY7XG4gICAgICAgICAgaWYgKCFpc1Zpc2libGUodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IG1pbkhlaWdodCA9ICcnO1xuICAgICAgICAgIGNvbnN0IGJveCA9IGJveE1vZGVsQWRqdXN0KHRoaXMuJGVsLCAnaGVpZ2h0JywgJ2NvbnRlbnQtYm94Jyk7XG5cbiAgICAgICAgICBjb25zdCB7IGJvZHksIHNjcm9sbGluZ0VsZW1lbnQgfSA9IGRvY3VtZW50O1xuICAgICAgICAgIGNvbnN0IFtzY3JvbGxFbGVtZW50XSA9IHNjcm9sbFBhcmVudHModGhpcy4kZWwsIC9hdXRvfHNjcm9sbC8pO1xuICAgICAgICAgIGNvbnN0IHsgaGVpZ2h0OiB2aWV3cG9ydEhlaWdodCB9ID0gb2Zmc2V0Vmlld3BvcnQoXG4gICAgICAgICAgc2Nyb2xsRWxlbWVudCA9PT0gYm9keSA/IHNjcm9sbGluZ0VsZW1lbnQgOiBzY3JvbGxFbGVtZW50KTtcblxuXG4gICAgICAgICAgaWYgKHRoaXMuZXhwYW5kKSB7XG4gICAgICAgICAgICBtaW5IZWlnaHQgPSBNYXRoLm1heChcbiAgICAgICAgICAgIHZpZXdwb3J0SGVpZ2h0IC0gKFxuICAgICAgICAgICAgZGltZW5zaW9ucyQxKHNjcm9sbEVsZW1lbnQpLmhlaWdodCAtIGRpbWVuc2lvbnMkMSh0aGlzLiRlbCkuaGVpZ2h0KSAtXG4gICAgICAgICAgICBib3gsXG4gICAgICAgICAgICAwKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpc1Njcm9sbGluZ0VsZW1lbnQgPVxuICAgICAgICAgICAgc2Nyb2xsaW5nRWxlbWVudCA9PT0gc2Nyb2xsRWxlbWVudCB8fCBib2R5ID09PSBzY3JvbGxFbGVtZW50O1xuXG4gICAgICAgICAgICAvLyBvbiBtb2JpbGUgZGV2aWNlcyAoaU9TIGFuZCBBbmRyb2lkKSB3aW5kb3cuaW5uZXJIZWlnaHQgIT09IDEwMHZoXG4gICAgICAgICAgICBtaW5IZWlnaHQgPSBcImNhbGMoXCIgKyAoaXNTY3JvbGxpbmdFbGVtZW50ID8gJzEwMHZoJyA6IHZpZXdwb3J0SGVpZ2h0ICsgXCJweFwiKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub2Zmc2V0VG9wKSB7XG4gICAgICAgICAgICAgIGlmIChpc1Njcm9sbGluZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3AgPSBvZmZzZXRQb3NpdGlvbih0aGlzLiRlbClbMF0gLSBvZmZzZXRQb3NpdGlvbihzY3JvbGxFbGVtZW50KVswXTtcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQgKz0gdG9wID4gMCAmJiB0b3AgPCB2aWV3cG9ydEhlaWdodCAvIDIgPyBcIiAtIFwiICsgdG9wICsgXCJweFwiIDogJyc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IFwiIC0gXCIgKyBjc3Moc2Nyb2xsRWxlbWVudCwgJ3BhZGRpbmdUb3AnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vZmZzZXRCb3R0b20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IFwiIC0gXCIgKyBkaW1lbnNpb25zJDEodGhpcy4kZWwubmV4dEVsZW1lbnRTaWJsaW5nKS5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTnVtZXJpYyh0aGlzLm9mZnNldEJvdHRvbSkpIHtcbiAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IFwiIC0gXCIgKyB0aGlzLm9mZnNldEJvdHRvbSArIFwidmhcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vZmZzZXRCb3R0b20gJiYgZW5kc1dpdGgodGhpcy5vZmZzZXRCb3R0b20sICdweCcpKSB7XG4gICAgICAgICAgICAgIG1pbkhlaWdodCArPSBcIiAtIFwiICsgdG9GbG9hdCh0aGlzLm9mZnNldEJvdHRvbSkgKyBcInB4XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHRoaXMub2Zmc2V0Qm90dG9tKSkge1xuICAgICAgICAgICAgICBtaW5IZWlnaHQgKz0gXCIgLSBcIiArIGRpbWVuc2lvbnMkMShxdWVyeSh0aGlzLm9mZnNldEJvdHRvbSwgdGhpcy4kZWwpKS5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbkhlaWdodCArPSAoYm94ID8gXCIgLSBcIiArIGJveCArIFwicHhcIiA6ICcnKSArIFwiKVwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IG1pbkhlaWdodCwgcHJldiB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYyKSB7bGV0IHsgbWluSGVpZ2h0IH0gPSBfcmVmMjtcbiAgICAgICAgICBjc3ModGhpcy4kZWwsIHsgbWluSGVpZ2h0IH0pO1xuXG4gICAgICAgICAgaWYgKHRoaXMubWluSGVpZ2h0ICYmIHRvRmxvYXQoY3NzKHRoaXMuJGVsLCAnbWluSGVpZ2h0JykpIDwgdGhpcy5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ21pbkhlaWdodCcsIHRoaXMubWluSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0gfTtcblxuICAgIHZhciBTVkcgPSB7XG4gICAgICBhcmdzOiAnc3JjJyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaWQ6IEJvb2xlYW4sXG4gICAgICAgIGljb246IFN0cmluZyxcbiAgICAgICAgc3JjOiBTdHJpbmcsXG4gICAgICAgIHN0eWxlOiBTdHJpbmcsXG4gICAgICAgIHdpZHRoOiBOdW1iZXIsXG4gICAgICAgIGhlaWdodDogTnVtYmVyLFxuICAgICAgICByYXRpbzogTnVtYmVyLFxuICAgICAgICBjbGFzczogU3RyaW5nLFxuICAgICAgICBzdHJva2VBbmltYXRpb246IEJvb2xlYW4sXG4gICAgICAgIGZvY3VzYWJsZTogQm9vbGVhbiwgLy8gSUUgMTFcbiAgICAgICAgYXR0cmlidXRlczogJ2xpc3QnIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICByYXRpbzogMSxcbiAgICAgICAgaW5jbHVkZTogWydzdHlsZScsICdjbGFzcycsICdmb2N1c2FibGUnXSxcbiAgICAgICAgY2xhc3M6ICcnLFxuICAgICAgICBzdHJva2VBbmltYXRpb246IGZhbHNlIH0sXG5cblxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jbGFzcyArPSAnIHVrLXN2Zyc7XG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pY29uICYmIGluY2x1ZGVzKHRoaXMuc3JjLCAnIycpKSB7XG4gICAgICAgICAgW3RoaXMuc3JjLCB0aGlzLmljb25dID0gdGhpcy5zcmMuc3BsaXQoJyMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3ZnID0gdGhpcy5nZXRTdmcoKS50aGVuKChlbCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN2ZyA9IGluc2VydFNWRyhlbCwgdGhpcy4kZWwpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zdmdFbCAmJiBzdmcgIT09IHRoaXMuc3ZnRWwpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlJDEodGhpcy5zdmdFbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlBdHRyaWJ1dGVzKHN2ZywgZWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdmdFbCA9IHN2ZztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG5vb3ApO1xuXG4gICAgICAgIGlmICh0aGlzLnN0cm9rZUFuaW1hdGlvbikge1xuICAgICAgICAgIHRoaXMuc3ZnLnRoZW4oKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIGFwcGx5QW5pbWF0aW9uKGVsKTtcbiAgICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKFxuICAgICAgICAgICAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKGVsLCAocmVjb3Jkcywgb2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBhcHBseUFuaW1hdGlvbihlbCk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnN2Zy50aGVuKChzdmcpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzVm9pZEVsZW1lbnQodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW1vdmUkMShzdmcpO1xuICAgICAgICAgIHRoaXMuc3ZnRWwgPSBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN2ZyA9IG51bGw7XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIGdldFN2ZygpIHtcbiAgICAgICAgICBpZiAoaXNUYWcodGhpcy4kZWwsICdpbWcnKSAmJiAhdGhpcy4kZWwuY29tcGxldGUgJiYgdGhpcy4kZWwubG9hZGluZyA9PT0gJ2xhenknKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+XG4gICAgICAgICAgICBvbmNlKHRoaXMuJGVsLCAnbG9hZCcsICgpID0+IHJlc29sdmUodGhpcy5nZXRTdmcoKSkpKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwYXJzZVNWRyhhd2FpdCBsb2FkU1ZHKHRoaXMuc3JjKSwgdGhpcy5pY29uKSB8fCBQcm9taXNlLnJlamVjdCgnU1ZHIG5vdCBmb3VuZC4nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhcHBseUF0dHJpYnV0ZXMoZWwsIHJlZikge1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiB0aGlzLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZXModGhpcy5pbmNsdWRlLCBwcm9wKSAmJiBwcm9wIGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgYXR0cihlbCwgcHJvcCwgdGhpc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBbcHJvcCwgdmFsdWVdID0gdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0uc3BsaXQoJzonLCAyKTtcbiAgICAgICAgICAgIGF0dHIoZWwsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgICAgIHJlbW92ZUF0dHIoZWwsICdpZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByb3BzID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcbiAgICAgICAgICBsZXQgZGltZW5zaW9ucyA9IHByb3BzLm1hcCgocHJvcCkgPT4gdGhpc1twcm9wXSk7XG5cbiAgICAgICAgICBpZiAoIWRpbWVuc2lvbnMuc29tZSgodmFsKSA9PiB2YWwpKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zID0gcHJvcHMubWFwKChwcm9wKSA9PiBhdHRyKHJlZiwgcHJvcCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHZpZXdCb3ggPSBhdHRyKHJlZiwgJ3ZpZXdCb3gnKTtcbiAgICAgICAgICBpZiAodmlld0JveCAmJiAhZGltZW5zaW9ucy5zb21lKCh2YWwpID0+IHZhbCkpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB2aWV3Qm94LnNwbGl0KCcgJykuc2xpY2UoMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGltZW5zaW9ucy5mb3JFYWNoKCh2YWwsIGkpID0+IGF0dHIoZWwsIHByb3BzW2ldLCB0b0Zsb2F0KHZhbCkgKiB0aGlzLnJhdGlvIHx8IG51bGwpKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgY29uc3QgbG9hZFNWRyA9IG1lbW9pemUoYXN5bmMgKHNyYykgPT4ge1xuICAgICAgaWYgKHNyYykge1xuICAgICAgICBpZiAoc3RhcnRzV2l0aChzcmMsICdkYXRhOicpKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzcmMuc3BsaXQoJywnKVsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChhd2FpdCBmZXRjaChzcmMpKS50ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VTVkcoc3ZnLCBpY29uKSB7dmFyIF9zdmc7XG4gICAgICBpZiAoaWNvbiAmJiBpbmNsdWRlcyhzdmcsICc8c3ltYm9sJykpIHtcbiAgICAgICAgc3ZnID0gcGFyc2VTeW1ib2xzKHN2ZywgaWNvbikgfHwgc3ZnO1xuICAgICAgfVxuXG4gICAgICBzdmcgPSAkKHN2Zy5zdWJzdHIoc3ZnLmluZGV4T2YoJzxzdmcnKSkpO1xuICAgICAgcmV0dXJuICgoX3N2ZyA9IHN2ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdmcuaGFzQ2hpbGROb2RlcygpKSAmJiBzdmc7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ltYm9sUmUgPSAvPHN5bWJvbChbXl0qP2lkPShbJ1wiXSkoLis/KVxcMlteXSo/PFxcLylzeW1ib2w+L2c7XG4gICAgY29uc3Qgc3ltYm9scyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VTeW1ib2xzKHN2ZywgaWNvbikge1xuICAgICAgaWYgKCFzeW1ib2xzW3N2Z10pIHtcbiAgICAgICAgc3ltYm9sc1tzdmddID0ge307XG5cbiAgICAgICAgc3ltYm9sUmUubGFzdEluZGV4ID0gMDtcblxuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIHdoaWxlIChtYXRjaCA9IHN5bWJvbFJlLmV4ZWMoc3ZnKSkge1xuICAgICAgICAgIHN5bWJvbHNbc3ZnXVttYXRjaFszXV0gPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlwiICsgbWF0Y2hbMV0gKyBcInN2Zz5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3ltYm9sc1tzdmddW2ljb25dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5QW5pbWF0aW9uKGVsKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBnZXRNYXhQYXRoTGVuZ3RoKGVsKTtcblxuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS11ay1hbmltYXRpb24tc3Ryb2tlJywgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXhQYXRoTGVuZ3RoKGVsKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKFxuICAgICAgTWF0aC5tYXgoXG4gICAgICAwLFxuICAgICAgLi4uJCQoJ1tzdHJva2VdJywgZWwpLm1hcCgoc3Ryb2tlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHN0cm9rZS5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH0pKSk7XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2VydFNWRyhlbCwgcm9vdCkge1xuICAgICAgaWYgKGlzVm9pZEVsZW1lbnQocm9vdCkgfHwgaXNUYWcocm9vdCwgJ2NhbnZhcycpKSB7XG4gICAgICAgIHJvb3QuaGlkZGVuID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBuZXh0ID0gcm9vdC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIHJldHVybiBlcXVhbHMoZWwsIG5leHQpID8gbmV4dCA6IGFmdGVyKHJvb3QsIGVsKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGFzdCA9IHJvb3QubGFzdEVsZW1lbnRDaGlsZDtcbiAgICAgIHJldHVybiBlcXVhbHMoZWwsIGxhc3QpID8gbGFzdCA6IGFwcGVuZChyb290LCBlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1YWxzKGVsLCBvdGhlcikge1xuICAgICAgcmV0dXJuIGlzVGFnKGVsLCAnc3ZnJykgJiYgaXNUYWcob3RoZXIsICdzdmcnKSAmJiBpbm5lckhUTUwoZWwpID09PSBpbm5lckhUTUwob3RoZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlubmVySFRNTChlbCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgIGVsLmlubmVySFRNTCB8fFxuICAgICAgbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhlbCkucmVwbGFjZSgvPHN2Zy4qPz4oLio/KTxcXC9zdmc+L2csICckMScpKS5cbiAgICAgIHJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgfVxuXG4gICAgdmFyIGNsb3NlSWNvbiA9IFwiPHN2ZyB3aWR0aD1cXFwiMTRcXFwiIGhlaWdodD1cXFwiMTRcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNCAxNFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiB4MT1cXFwiMVxcXCIgeTE9XFxcIjFcXFwiIHgyPVxcXCIxM1xcXCIgeTI9XFxcIjEzXFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgeDE9XFxcIjEzXFxcIiB5MT1cXFwiMVxcXCIgeDI9XFxcIjFcXFwiIHkyPVxcXCIxM1xcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIGNsb3NlTGFyZ2UgPSBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuNFxcXCIgeDE9XFxcIjFcXFwiIHkxPVxcXCIxXFxcIiB4Mj1cXFwiMTlcXFwiIHkyPVxcXCIxOVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIHgxPVxcXCIxOVxcXCIgeTE9XFxcIjFcXFwiIHgyPVxcXCIxXFxcIiB5Mj1cXFwiMTlcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBtYXJrZXIgPSBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiOVxcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMTFcXFwiLz48cmVjdCB4PVxcXCI0XFxcIiB5PVxcXCI5XFxcIiB3aWR0aD1cXFwiMTFcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIG5hdlBhcmVudEljb24gPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMTJcXFwiIGhlaWdodD1cXFwiMTJcXFwiIHZpZXdCb3g9XFxcIjAgMCAxMiAxMlxcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIHBvaW50cz1cXFwiMSAzLjUgNiA4LjUgMTEgMy41XFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgbmF2UGFyZW50SWNvbkxhcmdlID0gXCI8c3ZnIHdpZHRoPVxcXCIxNFxcXCIgaGVpZ2h0PVxcXCIxNFxcXCIgdmlld0JveD1cXFwiMCAwIDE0IDE0XFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBwb2ludHM9XFxcIjEgNCA3IDEwIDEzIDRcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBuYXZiYXJQYXJlbnRJY29uID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjEyXFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiB2aWV3Qm94PVxcXCIwIDAgMTIgMTJcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBwb2ludHM9XFxcIjEgMy41IDYgOC41IDExIDMuNVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIG5hdmJhclRvZ2dsZUljb24gPSBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHN0eWxlPi51ay1uYXZiYXItdG9nZ2xlLWFuaW1hdGUgc3ZnID4gW2NsYXNzKj0nbGluZS0nXSB7XFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogMC4ycyBlYXNlLWluLW91dDtcXG4gICAgICAgICAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiB0cmFuc2Zvcm0sIG9wYWNpdHksO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcXG4gICAgICAgICAgICBvcGFjaXR5OiAxO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLnVrLW5hdmJhci10b2dnbGUgc3ZnID4gLmxpbmUtMyB7IG9wYWNpdHk6IDA7IH1cXG4gICAgICAgIC51ay1uYXZiYXItdG9nZ2xlLWFuaW1hdGVbYXJpYS1leHBhbmRlZD1cXFwidHJ1ZVxcXCJdIHN2ZyA+IC5saW5lLTMgeyBvcGFjaXR5OiAxOyB9XFxuXFxuICAgICAgICAudWstbmF2YmFyLXRvZ2dsZS1hbmltYXRlW2FyaWEtZXhwYW5kZWQ9XFxcInRydWVcXFwiXSBzdmcgPiAubGluZS0yIHsgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpOyB9XFxuICAgICAgICAudWstbmF2YmFyLXRvZ2dsZS1hbmltYXRlW2FyaWEtZXhwYW5kZWQ9XFxcInRydWVcXFwiXSBzdmcgPiAubGluZS0zIHsgdHJhbnNmb3JtOiByb3RhdGUoLTQ1ZGVnKTsgfVxcblxcbiAgICAgICAgLnVrLW5hdmJhci10b2dnbGUtYW5pbWF0ZVthcmlhLWV4cGFuZGVkPVxcXCJ0cnVlXFxcIl0gc3ZnID4gLmxpbmUtMSxcXG4gICAgICAgIC51ay1uYXZiYXItdG9nZ2xlLWFuaW1hdGVbYXJpYS1leHBhbmRlZD1cXFwidHJ1ZVxcXCJdIHN2ZyA+IC5saW5lLTQgeyBvcGFjaXR5OiAwOyB9XFxuICAgICAgICAudWstbmF2YmFyLXRvZ2dsZS1hbmltYXRlW2FyaWEtZXhwYW5kZWQ9XFxcInRydWVcXFwiXSBzdmcgPiAubGluZS0xIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDZweCkgc2NhbGVYKDApOyB9XFxuICAgICAgICAudWstbmF2YmFyLXRvZ2dsZS1hbmltYXRlW2FyaWEtZXhwYW5kZWQ9XFxcInRydWVcXFwiXSBzdmcgPiAubGluZS00IHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC02cHgpIHNjYWxlWCgwKTsgfTwvc3R5bGU+PHJlY3QgY2xhc3M9XFxcImxpbmUtMVxcXCIgeT1cXFwiM1xcXCIgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48cmVjdCBjbGFzcz1cXFwibGluZS0yXFxcIiB5PVxcXCI5XFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IGNsYXNzPVxcXCJsaW5lLTNcXFwiIHk9XFxcIjlcXFwiIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyXFxcIi8+PHJlY3QgY2xhc3M9XFxcImxpbmUtNFxcXCIgeT1cXFwiMTVcXFwiIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgb3ZlcmxheUljb24gPSBcIjxzdmcgd2lkdGg9XFxcIjQwXFxcIiBoZWlnaHQ9XFxcIjQwXFxcIiB2aWV3Qm94PVxcXCIwIDAgNDAgNDBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiMTlcXFwiIHk9XFxcIjBcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjQwXFxcIi8+PHJlY3QgeD1cXFwiMFxcXCIgeT1cXFwiMTlcXFwiIHdpZHRoPVxcXCI0MFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgcGFnaW5hdGlvbk5leHQgPSBcIjxzdmcgd2lkdGg9XFxcIjdcXFwiIGhlaWdodD1cXFwiMTJcXFwiIHZpZXdCb3g9XFxcIjAgMCA3IDEyXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBwb2ludHM9XFxcIjEgMSA2IDYgMSAxMVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHBhZ2luYXRpb25QcmV2aW91cyA9IFwiPHN2ZyB3aWR0aD1cXFwiN1xcXCIgaGVpZ2h0PVxcXCIxMlxcXCIgdmlld0JveD1cXFwiMCAwIDcgMTJcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIHBvaW50cz1cXFwiNiAxIDEgNiA2IDExXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc2VhcmNoSWNvbiA9IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCI5XFxcIiBjeT1cXFwiOVxcXCIgcj1cXFwiN1xcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xNCwxNCBMMTgsMTggTDE0LDE0IFpcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzZWFyY2hMYXJnZSA9IFwiPHN2ZyB3aWR0aD1cXFwiNDBcXFwiIGhlaWdodD1cXFwiNDBcXFwiIHZpZXdCb3g9XFxcIjAgMCA0MCA0MFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjhcXFwiIGN4PVxcXCIxNy41XFxcIiBjeT1cXFwiMTcuNVxcXCIgcj1cXFwiMTYuNVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjhcXFwiIHgxPVxcXCIzOFxcXCIgeTE9XFxcIjM5XFxcIiB4Mj1cXFwiMjlcXFwiIHkyPVxcXCIzMFxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNlYXJjaE5hdmJhciA9IFwiPHN2ZyB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxMC41XFxcIiBjeT1cXFwiMTAuNVxcXCIgcj1cXFwiOS41XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgeDE9XFxcIjIzXFxcIiB5MT1cXFwiMjNcXFwiIHgyPVxcXCIxN1xcXCIgeTI9XFxcIjE3XFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc2xpZGVuYXZOZXh0ID0gXCI8c3ZnIHdpZHRoPVxcXCIxNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDE0IDI0XFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS40XFxcIiBwb2ludHM9XFxcIjEuMjI1LDIzIDEyLjc3NSwxMiAxLjIyNSwxIFxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNsaWRlbmF2TmV4dExhcmdlID0gXCI8c3ZnIHdpZHRoPVxcXCIyNVxcXCIgaGVpZ2h0PVxcXCI0MFxcXCIgdmlld0JveD1cXFwiMCAwIDI1IDQwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMlxcXCIgcG9pbnRzPVxcXCI0LjAwMiwzOC41NDcgMjIuNTI3LDIwLjAyNCA0LDEuNSBcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzbGlkZW5hdlByZXZpb3VzID0gXCI8c3ZnIHdpZHRoPVxcXCIxNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDE0IDI0XFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS40XFxcIiBwb2ludHM9XFxcIjEyLjc3NSwxIDEuMjI1LDEyIDEyLjc3NSwyMyBcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzbGlkZW5hdlByZXZpb3VzTGFyZ2UgPSBcIjxzdmcgd2lkdGg9XFxcIjI1XFxcIiBoZWlnaHQ9XFxcIjQwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjUgNDBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIyXFxcIiBwb2ludHM9XFxcIjIwLjUyNywxLjUgMiwyMC4wMjQgMjAuNTI1LDM4LjU0NyBcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzcGlubmVyID0gXCI8c3ZnIHdpZHRoPVxcXCIzMFxcXCIgaGVpZ2h0PVxcXCIzMFxcXCIgdmlld0JveD1cXFwiMCAwIDMwIDMwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBjeD1cXFwiMTVcXFwiIGN5PVxcXCIxNVxcXCIgcj1cXFwiMTRcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciB0b3RvcCA9IFwiPHN2ZyB3aWR0aD1cXFwiMThcXFwiIGhlaWdodD1cXFwiMTBcXFwiIHZpZXdCb3g9XFxcIjAgMCAxOCAxMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgcG9pbnRzPVxcXCIxIDkgOSAxIDE3IDkgXFxcIi8+PC9zdmc+XCI7XG5cbiAgICBjb25zdCBpY29ucyA9IHtcbiAgICAgIHNwaW5uZXIsXG4gICAgICB0b3RvcCxcbiAgICAgIG1hcmtlcixcbiAgICAgICdjbG9zZS1pY29uJzogY2xvc2VJY29uLFxuICAgICAgJ2Nsb3NlLWxhcmdlJzogY2xvc2VMYXJnZSxcbiAgICAgICduYXYtcGFyZW50LWljb24nOiBuYXZQYXJlbnRJY29uLFxuICAgICAgJ25hdi1wYXJlbnQtaWNvbi1sYXJnZSc6IG5hdlBhcmVudEljb25MYXJnZSxcbiAgICAgICduYXZiYXItcGFyZW50LWljb24nOiBuYXZiYXJQYXJlbnRJY29uLFxuICAgICAgJ25hdmJhci10b2dnbGUtaWNvbic6IG5hdmJhclRvZ2dsZUljb24sXG4gICAgICAnb3ZlcmxheS1pY29uJzogb3ZlcmxheUljb24sXG4gICAgICAncGFnaW5hdGlvbi1uZXh0JzogcGFnaW5hdGlvbk5leHQsXG4gICAgICAncGFnaW5hdGlvbi1wcmV2aW91cyc6IHBhZ2luYXRpb25QcmV2aW91cyxcbiAgICAgICdzZWFyY2gtaWNvbic6IHNlYXJjaEljb24sXG4gICAgICAnc2VhcmNoLWxhcmdlJzogc2VhcmNoTGFyZ2UsXG4gICAgICAnc2VhcmNoLW5hdmJhcic6IHNlYXJjaE5hdmJhcixcbiAgICAgICdzbGlkZW5hdi1uZXh0Jzogc2xpZGVuYXZOZXh0LFxuICAgICAgJ3NsaWRlbmF2LW5leHQtbGFyZ2UnOiBzbGlkZW5hdk5leHRMYXJnZSxcbiAgICAgICdzbGlkZW5hdi1wcmV2aW91cyc6IHNsaWRlbmF2UHJldmlvdXMsXG4gICAgICAnc2xpZGVuYXYtcHJldmlvdXMtbGFyZ2UnOiBzbGlkZW5hdlByZXZpb3VzTGFyZ2UgfTtcblxuXG4gICAgY29uc3QgSWNvbiA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwkMyxcblxuICAgICAgZXh0ZW5kczogU1ZHLFxuXG4gICAgICBhcmdzOiAnaWNvbicsXG5cbiAgICAgIHByb3BzOiBbJ2ljb24nXSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBpbmNsdWRlOiBbJ2ZvY3VzYWJsZSddIH0sXG5cblxuICAgICAgaXNJY29uOiB0cnVlLFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgJ3VrLWljb24nKTtcbiAgICAgIH0sXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXN5bmMgZ2V0U3ZnKCkge1xuICAgICAgICAgIGNvbnN0IGljb24gPSBnZXRJY29uKHRoaXMuaWNvbik7XG5cbiAgICAgICAgICBpZiAoIWljb24pIHtcbiAgICAgICAgICAgIHRocm93ICdJY29uIG5vdCBmb3VuZC4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpY29uO1xuICAgICAgICB9IH0gfTtcblxuICAgIGNvbnN0IEljb25Db21wb25lbnQgPSB7XG4gICAgICBhcmdzOiBmYWxzZSxcblxuICAgICAgZXh0ZW5kczogSWNvbixcblxuICAgICAgZGF0YTogKHZtKSA9PiAoe1xuICAgICAgICBpY29uOiBoeXBoZW5hdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucy5uYW1lKSB9KSxcblxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy4kb3B0aW9ucy5pZCk7XG4gICAgICB9IH07XG5cblxuICAgIGNvbnN0IE5hdlBhcmVudEljb24gPSB7XG4gICAgICBleHRlbmRzOiBJY29uQ29tcG9uZW50LFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICBjb25zdCBpY29uID0gdGhpcy4kcHJvcHMuaWNvbjtcbiAgICAgICAgdGhpcy5pY29uID0gY2xvc2VzdCh0aGlzLiRlbCwgJy51ay1uYXYtcHJpbWFyeScpID8gaWNvbiArIFwiLWxhcmdlXCIgOiBpY29uO1xuICAgICAgfSB9O1xuXG5cbiAgICBjb25zdCBTbGlkZW5hdiA9IHtcbiAgICAgIGV4dGVuZHM6IEljb25Db21wb25lbnQsXG5cbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCAndWstc2xpZGVuYXYnKTtcbiAgICAgICAgY29uc3QgaWNvbiA9IHRoaXMuJHByb3BzLmljb247XG4gICAgICAgIHRoaXMuaWNvbiA9IGhhc0NsYXNzKHRoaXMuJGVsLCAndWstc2xpZGVuYXYtbGFyZ2UnKSA/IGljb24gKyBcIi1sYXJnZVwiIDogaWNvbjtcbiAgICAgIH0gfTtcblxuXG4gICAgY29uc3QgU2VhcmNoID0ge1xuICAgICAgZXh0ZW5kczogSWNvbkNvbXBvbmVudCxcblxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5pY29uID1cbiAgICAgICAgaGFzQ2xhc3ModGhpcy4kZWwsICd1ay1zZWFyY2gtaWNvbicpICYmIHBhcmVudHModGhpcy4kZWwsICcudWstc2VhcmNoLWxhcmdlJykubGVuZ3RoID9cbiAgICAgICAgJ3NlYXJjaC1sYXJnZScgOlxuICAgICAgICBwYXJlbnRzKHRoaXMuJGVsLCAnLnVrLXNlYXJjaC1uYXZiYXInKS5sZW5ndGggP1xuICAgICAgICAnc2VhcmNoLW5hdmJhcicgOlxuICAgICAgICB0aGlzLiRwcm9wcy5pY29uO1xuICAgICAgfSB9O1xuXG5cbiAgICBjb25zdCBDbG9zZSA9IHtcbiAgICAgIGV4dGVuZHM6IEljb25Db21wb25lbnQsXG5cbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuaWNvbiA9IFwiY2xvc2UtXCIgKyAoaGFzQ2xhc3ModGhpcy4kZWwsICd1ay1jbG9zZS1sYXJnZScpID8gJ2xhcmdlJyA6ICdpY29uJyk7XG4gICAgICB9IH07XG5cblxuICAgIGNvbnN0IFNwaW5uZXIgPSB7XG4gICAgICBleHRlbmRzOiBJY29uQ29tcG9uZW50LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIGdldFN2ZygpIHtcbiAgICAgICAgICBjb25zdCBpY29uID0gYXdhaXQgSWNvbi5tZXRob2RzLmdldFN2Zy5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgaWYgKHRoaXMucmF0aW8gIT09IDEpIHtcbiAgICAgICAgICAgIGNzcygkKCdjaXJjbGUnLCBpY29uKSwgJ3N0cm9rZVdpZHRoJywgMSAvIHRoaXMucmF0aW8pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpY29uO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBjb25zdCBwYXJzZWQgPSB7fTtcbiAgICBmdW5jdGlvbiBpbnN0YWxsJDMoVUlraXQpIHtcbiAgICAgIFVJa2l0Lmljb24uYWRkID0gKG5hbWUsIHN2ZykgPT4ge1xuICAgICAgICBjb25zdCBhZGRlZCA9IGlzU3RyaW5nKG5hbWUpID8geyBbbmFtZV06IHN2ZyB9IDogbmFtZTtcbiAgICAgICAgZWFjaChhZGRlZCwgKHN2ZywgbmFtZSkgPT4ge1xuICAgICAgICAgIGljb25zW25hbWVdID0gc3ZnO1xuICAgICAgICAgIGRlbGV0ZSBwYXJzZWRbbmFtZV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChVSWtpdC5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICBhcHBseShkb2N1bWVudC5ib2R5LCAoZWwpID0+XG4gICAgICAgICAgZWFjaChVSWtpdC5nZXRDb21wb25lbnRzKGVsKSwgKGNtcCkgPT4ge1xuICAgICAgICAgICAgY21wLiRvcHRpb25zLmlzSWNvbiAmJiBjbXAuaWNvbiBpbiBhZGRlZCAmJiBjbXAuJHJlc2V0KCk7XG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SWNvbihpY29uKSB7XG4gICAgICBpZiAoIWljb25zW2ljb25dKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcnNlZFtpY29uXSkge1xuICAgICAgICBwYXJzZWRbaWNvbl0gPSAkKChpY29uc1thcHBseVJ0bChpY29uKV0gfHwgaWNvbnNbaWNvbl0pLnRyaW0oKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZWRbaWNvbl0uY2xvbmVOb2RlKHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5UnRsKGljb24pIHtcbiAgICAgIHJldHVybiBpc1J0bCA/IHN3YXAoc3dhcChpY29uLCAnbGVmdCcsICdyaWdodCcpLCAncHJldmlvdXMnLCAnbmV4dCcpIDogaWNvbjtcbiAgICB9XG5cbiAgICBjb25zdCBuYXRpdmVMYXp5TG9hZCA9IGluQnJvd3NlciAmJiAnbG9hZGluZycgaW4gSFRNTEltYWdlRWxlbWVudC5wcm90b3R5cGU7XG5cbiAgICB2YXIgaW1nID0ge1xuICAgICAgYXJnczogJ2RhdGFTcmMnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBkYXRhU3JjOiBTdHJpbmcsXG4gICAgICAgIHNvdXJjZXM6IFN0cmluZyxcbiAgICAgICAgb2Zmc2V0VG9wOiBTdHJpbmcsXG4gICAgICAgIG9mZnNldExlZnQ6IFN0cmluZyxcbiAgICAgICAgdGFyZ2V0OiBTdHJpbmcsXG4gICAgICAgIGxvYWRpbmc6IFN0cmluZyB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZGF0YVNyYzogJycsXG4gICAgICAgIHNvdXJjZXM6IGZhbHNlLFxuICAgICAgICBvZmZzZXRUb3A6ICc1MHZoJyxcbiAgICAgICAgb2Zmc2V0TGVmdDogJzUwdncnLFxuICAgICAgICB0YXJnZXQ6IGZhbHNlLFxuICAgICAgICBsb2FkaW5nOiAnbGF6eScgfSxcblxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmcgIT09ICdsYXp5Jykge1xuICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IFt0aGlzLiRlbCwgLi4ucXVlcnlBbGwodGhpcy4kcHJvcHMudGFyZ2V0LCB0aGlzLiRlbCldO1xuXG4gICAgICAgIGlmIChuYXRpdmVMYXp5TG9hZCAmJiBpc0ltZyh0aGlzLiRlbCkpIHtcbiAgICAgICAgICB0aGlzLiRlbC5sb2FkaW5nID0gJ2xhenknO1xuICAgICAgICAgIHNldFNyY0F0dHJzKHRoaXMuJGVsKTtcblxuICAgICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZW5zdXJlU3JjQXR0cmlidXRlKHRoaXMuJGVsKTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIoXG4gICAgICAgIG9ic2VydmVJbnRlcnNlY3Rpb24oXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcm9vdE1hcmdpbjogdG9QeCh0aGlzLm9mZnNldFRvcCwgJ2hlaWdodCcpICsgXCJweCBcIiArIHRvUHgoXG4gICAgICAgICAgdGhpcy5vZmZzZXRMZWZ0LFxuICAgICAgICAgICd3aWR0aCcpICsgXCJweFwiIH0pKTtcblxuXG5cblxuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YS5pbWFnZSkge1xuICAgICAgICAgIHRoaXMuX2RhdGEuaW1hZ2Uub25sb2FkID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgbG9hZCgpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZGF0YS5pbWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuaW1hZ2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaW1hZ2UgPSBpc0ltZyh0aGlzLiRlbCkgP1xuICAgICAgICAgIHRoaXMuJGVsIDpcbiAgICAgICAgICBnZXRJbWFnZUZyb21FbGVtZW50KHRoaXMuJGVsLCB0aGlzLmRhdGFTcmMsIHRoaXMuc291cmNlcyk7XG5cbiAgICAgICAgICByZW1vdmVBdHRyKGltYWdlLCAnbG9hZGluZycpO1xuICAgICAgICAgIHNldFNyY0F0dHJzKHRoaXMuJGVsLCBpbWFnZS5jdXJyZW50U3JjKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5pbWFnZSA9IGltYWdlO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBzZXRTcmNBdHRycyhlbCwgc3JjKSB7XG4gICAgICBpZiAoaXNJbWcoZWwpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXJlbnQoZWwpO1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGlzUGljdHVyZShwYXJlbnROb2RlKSA/IGNoaWxkcmVuKHBhcmVudE5vZGUpIDogW2VsXTtcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHNldFNvdXJjZVByb3BzKGVsLCBlbCkpO1xuICAgICAgfSBlbHNlIGlmIChzcmMpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gIWluY2x1ZGVzKGVsLnN0eWxlLmJhY2tncm91bmRJbWFnZSwgc3JjKTtcbiAgICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICAgIGNzcyhlbCwgJ2JhY2tncm91bmRJbWFnZScsIFwidXJsKFwiICsgZXNjYXBlKHNyYykgKyBcIilcIik7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgY3JlYXRlRXZlbnQoJ2xvYWQnLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3JjUHJvcHMgPSBbJ2RhdGEtc3JjJywgJ2RhdGEtc3Jjc2V0JywgJ3NpemVzJ107XG4gICAgZnVuY3Rpb24gc2V0U291cmNlUHJvcHMoc291cmNlRWwsIHRhcmdldEVsKSB7XG4gICAgICBzcmNQcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YShzb3VyY2VFbCwgcHJvcCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGF0dHIodGFyZ2V0RWwsIHByb3AucmVwbGFjZSgvXihkYXRhLSkrLywgJycpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEltYWdlRnJvbUVsZW1lbnQoZWwsIHNyYywgc291cmNlcykge1xuICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG5cbiAgICAgIHdyYXBJblBpY3R1cmUoaW1nLCBzb3VyY2VzKTtcbiAgICAgIHNldFNvdXJjZVByb3BzKGVsLCBpbWcpO1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgc2V0U3JjQXR0cnMoZWwsIGltZy5jdXJyZW50U3JjKTtcbiAgICAgIH07XG4gICAgICBhdHRyKGltZywgJ3NyYycsIHNyYyk7XG4gICAgICByZXR1cm4gaW1nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBJblBpY3R1cmUoaW1nLCBzb3VyY2VzKSB7XG4gICAgICBzb3VyY2VzID0gcGFyc2VTb3VyY2VzKHNvdXJjZXMpO1xuXG4gICAgICBpZiAoc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcGljdHVyZSA9IGZyYWdtZW50KCc8cGljdHVyZT4nKTtcbiAgICAgICAgZm9yIChjb25zdCBhdHRycyBvZiBzb3VyY2VzKSB7XG4gICAgICAgICAgY29uc3Qgc291cmNlID0gZnJhZ21lbnQoJzxzb3VyY2U+Jyk7XG4gICAgICAgICAgYXR0cihzb3VyY2UsIGF0dHJzKTtcbiAgICAgICAgICBhcHBlbmQocGljdHVyZSwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmQocGljdHVyZSwgaW1nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNvdXJjZXMoc291cmNlcykge1xuICAgICAgaWYgKCFzb3VyY2VzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0c1dpdGgoc291cmNlcywgJ1snKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNvdXJjZXMgPSBKU09OLnBhcnNlKHNvdXJjZXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc291cmNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2VzID0gcGFyc2VPcHRpb25zKHNvdXJjZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzQXJyYXkoc291cmNlcykpIHtcbiAgICAgICAgc291cmNlcyA9IFtzb3VyY2VzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNvdXJjZXMuZmlsdGVyKChzb3VyY2UpID0+ICFpc0VtcHR5KHNvdXJjZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuc3VyZVNyY0F0dHJpYnV0ZShlbCkge1xuICAgICAgaWYgKGlzSW1nKGVsKSAmJiAhaGFzQXR0cihlbCwgJ3NyYycpKSB7XG4gICAgICAgIGF0dHIoZWwsICdzcmMnLCAnZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PC9zdmc+Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQaWN0dXJlKGVsKSB7XG4gICAgICByZXR1cm4gaXNUYWcoZWwsICdwaWN0dXJlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJbWcoZWwpIHtcbiAgICAgIHJldHVybiBpc1RhZyhlbCwgJ2ltZycpO1xuICAgIH1cblxuICAgIHZhciBNZWRpYSA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIG1lZGlhOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBtZWRpYTogZmFsc2UgfSxcblxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhID0gdG9NZWRpYSh0aGlzLm1lZGlhLCB0aGlzLiRlbCk7XG4gICAgICAgIHRoaXMubWF0Y2hNZWRpYSA9IHRydWU7XG4gICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgIHRoaXMubWVkaWFPYmogPSB3aW5kb3cubWF0Y2hNZWRpYShtZWRpYSk7XG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hNZWRpYSA9IHRoaXMubWVkaWFPYmoubWF0Y2hlcztcbiAgICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsIGNyZWF0ZUV2ZW50KCdtZWRpYWNoYW5nZScsIGZhbHNlLCB0cnVlLCBbdGhpcy5tZWRpYU9ial0pKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMub2ZmTWVkaWFPYmogPSBvbih0aGlzLm1lZGlhT2JqLCAnY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgncmVzaXplJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7dmFyIF90aGlzJG9mZk1lZGlhT2JqO1xuICAgICAgICAoX3RoaXMkb2ZmTWVkaWFPYmogPSB0aGlzLm9mZk1lZGlhT2JqKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb2ZmTWVkaWFPYmouY2FsbCh0aGlzKTtcbiAgICAgIH0gfTtcblxuXG4gICAgZnVuY3Rpb24gdG9NZWRpYSh2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBpZiAoc3RhcnRzV2l0aCh2YWx1ZSwgJ0AnKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9GbG9hdChjc3MoZWxlbWVudCwgXCItLXVrLWJyZWFrcG9pbnQtXCIgKyB2YWx1ZS5zdWJzdHIoMSkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlICYmIGlzTnVtZXJpYyh2YWx1ZSkgPyBcIihtaW4td2lkdGg6IFwiICsgdmFsdWUgKyBcInB4KVwiIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIGxlYWRlciA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBNZWRpYSwgUmVzaXplXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZmlsbDogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBmaWxsOiAnJyxcbiAgICAgICAgY2xzV3JhcHBlcjogJ3VrLWxlYWRlci1maWxsJyxcbiAgICAgICAgY2xzSGlkZTogJ3VrLWxlYWRlci1oaWRlJyxcbiAgICAgICAgYXR0ckZpbGw6ICdkYXRhLWZpbGwnIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgZmlsbChfcmVmKSB7bGV0IHsgZmlsbCB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gZmlsbCB8fCBjc3ModGhpcy4kZWwsICctLXVrLWxlYWRlci1maWxsLWNvbnRlbnQnKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgW3RoaXMud3JhcHBlcl0gPSB3cmFwSW5uZXIodGhpcy4kZWwsIFwiPHNwYW4gY2xhc3M9XFxcIlwiICsgdGhpcy5jbHNXcmFwcGVyICsgXCJcXFwiPlwiKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdW53cmFwKHRoaXMud3JhcHBlci5jaGlsZE5vZGVzKTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC50cnVuYyh0aGlzLiRlbC5vZmZzZXRXaWR0aCAvIDIpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgZmlsbDogdGhpcy5maWxsLFxuICAgICAgICAgICAgaGlkZTogIXRoaXMubWF0Y2hNZWRpYSB9O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoX3JlZjIpIHtsZXQgeyB3aWR0aCwgZmlsbCwgaGlkZSB9ID0gX3JlZjI7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3ModGhpcy53cmFwcGVyLCB0aGlzLmNsc0hpZGUsIGhpZGUpO1xuICAgICAgICAgIGF0dHIodGhpcy53cmFwcGVyLCB0aGlzLmF0dHJGaWxsLCBuZXcgQXJyYXkod2lkdGgpLmpvaW4oZmlsbCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9IH07XG5cbiAgICB2YXIgbW9kYWwgPSB7XG4gICAgICBpbnN0YWxsOiBpbnN0YWxsJDIsXG5cbiAgICAgIG1peGluczogW01vZGFsXSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBjbHNQYWdlOiAndWstbW9kYWwtcGFnZScsXG4gICAgICAgIHNlbFBhbmVsOiAnLnVrLW1vZGFsLWRpYWxvZycsXG4gICAgICAgIHNlbENsb3NlOlxuICAgICAgICAnLnVrLW1vZGFsLWNsb3NlLCAudWstbW9kYWwtY2xvc2UtZGVmYXVsdCwgLnVrLW1vZGFsLWNsb3NlLW91dHNpZGUsIC51ay1tb2RhbC1jbG9zZS1mdWxsJyB9LFxuXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnc2hvdycsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmIChoYXNDbGFzcyh0aGlzLnBhbmVsLCAndWstbWFyZ2luLWF1dG8tdmVydGljYWwnKSkge1xuICAgICAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsICd1ay1mbGV4Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoZWlnaHQodGhpcy4kZWwpOyAvLyBmb3JjZSByZWZsb3dcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGRlbicsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ2Rpc3BsYXknLCAnJyk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsICd1ay1mbGV4Jyk7XG4gICAgICAgIH0gfV0gfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIGluc3RhbGwkMihfcmVmKSB7bGV0IHsgbW9kYWwgfSA9IF9yZWY7XG4gICAgICBtb2RhbC5kaWFsb2cgPSBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkaWFsb2cgPSBtb2RhbChcIjxkaXYgY2xhc3M9XFxcInVrLW1vZGFsXFxcIj4gPGRpdiBjbGFzcz1cXFwidWstbW9kYWwtZGlhbG9nXFxcIj5cIiArXG5cbiAgICAgICAgY29udGVudCArIFwiPC9kaXY+IDwvZGl2PlwiLFxuXG4gICAgICAgIG9wdGlvbnMpO1xuXG5cbiAgICAgICAgZGlhbG9nLnNob3coKTtcblxuICAgICAgICBvbihcbiAgICAgICAgZGlhbG9nLiRlbCxcbiAgICAgICAgJ2hpZGRlbicsXG4gICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICBkaWFsb2cuJGRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHsgc2VsZjogdHJ1ZSB9KTtcblxuXG4gICAgICAgIHJldHVybiBkaWFsb2c7XG4gICAgICB9O1xuXG4gICAgICBtb2RhbC5hbGVydCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcGVuRGlhbG9nKFxuICAgICAgICAoX3JlZjIpID0+IHtsZXQgeyBsYWJlbHMgfSA9IF9yZWYyO3JldHVybiBcIjxkaXYgY2xhc3M9XFxcInVrLW1vZGFsLWJvZHlcXFwiPlwiICsgKFxuICAgICAgICAgIGlzU3RyaW5nKG1lc3NhZ2UpID8gbWVzc2FnZSA6IGh0bWwobWVzc2FnZSkpICsgXCI8L2Rpdj4gPGRpdiBjbGFzcz1cXFwidWstbW9kYWwtZm9vdGVyIHVrLXRleHQtcmlnaHRcXFwiPiA8YnV0dG9uIGNsYXNzPVxcXCJ1ay1idXR0b24gdWstYnV0dG9uLXByaW1hcnkgdWstbW9kYWwtY2xvc2VcXFwiIGF1dG9mb2N1cz5cIiArXG5cblxuXG4gICAgICAgICAgbGFiZWxzLm9rICsgXCI8L2J1dHRvbj4gPC9kaXY+XCI7fSxcblxuXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIChkZWZlcnJlZCkgPT4gZGVmZXJyZWQucmVzb2x2ZSgpKTtcblxuICAgICAgfTtcblxuICAgICAgbW9kYWwuY29uZmlybSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcGVuRGlhbG9nKFxuICAgICAgICAoX3JlZjMpID0+IHtsZXQgeyBsYWJlbHMgfSA9IF9yZWYzO3JldHVybiBcIjxmb3JtPiA8ZGl2IGNsYXNzPVxcXCJ1ay1tb2RhbC1ib2R5XFxcIj5cIiArIChcbiAgICAgICAgICBpc1N0cmluZyhtZXNzYWdlKSA/IG1lc3NhZ2UgOiBodG1sKG1lc3NhZ2UpKSArIFwiPC9kaXY+IDxkaXYgY2xhc3M9XFxcInVrLW1vZGFsLWZvb3RlciB1ay10ZXh0LXJpZ2h0XFxcIj4gPGJ1dHRvbiBjbGFzcz1cXFwidWstYnV0dG9uIHVrLWJ1dHRvbi1kZWZhdWx0IHVrLW1vZGFsLWNsb3NlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiPlwiICtcblxuXG4gICAgICAgICAgbGFiZWxzLmNhbmNlbCArIFwiPC9idXR0b24+IDxidXR0b24gY2xhc3M9XFxcInVrLWJ1dHRvbiB1ay1idXR0b24tcHJpbWFyeVxcXCIgYXV0b2ZvY3VzPlwiICtcblxuICAgICAgICAgIGxhYmVscy5vayArIFwiPC9idXR0b24+IDwvZGl2PiA8L2Zvcm0+XCI7fSxcblxuXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIChkZWZlcnJlZCkgPT4gZGVmZXJyZWQucmVqZWN0KCkpO1xuXG4gICAgICB9O1xuXG4gICAgICBtb2RhbC5wcm9tcHQgPSBmdW5jdGlvbiAobWVzc2FnZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wZW5EaWFsb2coXG4gICAgICAgIChfcmVmNCkgPT4ge2xldCB7IGxhYmVscyB9ID0gX3JlZjQ7cmV0dXJuIFwiPGZvcm0gY2xhc3M9XFxcInVrLWZvcm0tc3RhY2tlZFxcXCI+IDxkaXYgY2xhc3M9XFxcInVrLW1vZGFsLWJvZHlcXFwiPiA8bGFiZWw+XCIgKyAoXG5cbiAgICAgICAgICBpc1N0cmluZyhtZXNzYWdlKSA/IG1lc3NhZ2UgOiBodG1sKG1lc3NhZ2UpKSArIFwiPC9sYWJlbD4gPGlucHV0IGNsYXNzPVxcXCJ1ay1pbnB1dFxcXCIgdmFsdWU9XFxcIlwiICsgKFxuICAgICAgICAgIHZhbHVlIHx8ICcnKSArIFwiXFxcIiBhdXRvZm9jdXM+IDwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJ1ay1tb2RhbC1mb290ZXIgdWstdGV4dC1yaWdodFxcXCI+IDxidXR0b24gY2xhc3M9XFxcInVrLWJ1dHRvbiB1ay1idXR0b24tZGVmYXVsdCB1ay1tb2RhbC1jbG9zZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj5cIiArXG5cblxuXG4gICAgICAgICAgbGFiZWxzLmNhbmNlbCArIFwiPC9idXR0b24+IDxidXR0b24gY2xhc3M9XFxcInVrLWJ1dHRvbiB1ay1idXR0b24tcHJpbWFyeVxcXCI+XCIgK1xuXG4gICAgICAgICAgbGFiZWxzLm9rICsgXCI8L2J1dHRvbj4gPC9kaXY+IDwvZm9ybT5cIjt9LFxuXG5cbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgKGRlZmVycmVkKSA9PiBkZWZlcnJlZC5yZXNvbHZlKG51bGwpLFxuICAgICAgICAoZGlhbG9nKSA9PiAkKCdpbnB1dCcsIGRpYWxvZy4kZWwpLnZhbHVlKTtcblxuICAgICAgfTtcblxuICAgICAgbW9kYWwubGFiZWxzID0ge1xuICAgICAgICBvazogJ09rJyxcbiAgICAgICAgY2FuY2VsOiAnQ2FuY2VsJyB9O1xuXG5cbiAgICAgIGZ1bmN0aW9uIG9wZW5EaWFsb2codG1wbCwgb3B0aW9ucywgaGlkZUZuLCBzdWJtaXRGbikge1xuICAgICAgICBvcHRpb25zID0geyBiZ0Nsb3NlOiBmYWxzZSwgZXNjQ2xvc2U6IHRydWUsIGxhYmVsczogbW9kYWwubGFiZWxzLCAuLi5vcHRpb25zIH07XG5cbiAgICAgICAgY29uc3QgZGlhbG9nID0gbW9kYWwuZGlhbG9nKHRtcGwob3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuXG4gICAgICAgIGxldCByZXNvbHZlZCA9IGZhbHNlO1xuXG4gICAgICAgIG9uKGRpYWxvZy4kZWwsICdzdWJtaXQnLCAnZm9ybScsIChlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc3VibWl0Rm4gPT0gbnVsbCA/IHZvaWQgMCA6IHN1Ym1pdEZuKGRpYWxvZykpO1xuICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICBkaWFsb2cuaGlkZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBvbihkaWFsb2cuJGVsLCAnaGlkZScsICgpID0+ICFyZXNvbHZlZCAmJiBoaWRlRm4oZGVmZXJyZWQpKTtcblxuICAgICAgICBkZWZlcnJlZC5wcm9taXNlLmRpYWxvZyA9IGRpYWxvZztcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmF2ID0ge1xuICAgICAgZXh0ZW5kczogQWNjb3JkaW9uLFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRhcmdldHM6ICc+IC51ay1wYXJlbnQnLFxuICAgICAgICB0b2dnbGU6ICc+IGEnLFxuICAgICAgICBjb250ZW50OiAnPiB1bCcgfSB9O1xuXG4gICAgdmFyIG5hdmJhciA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBDb250YWluZXJdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBkcm9wZG93bjogU3RyaW5nLFxuICAgICAgICBhbGlnbjogU3RyaW5nLFxuICAgICAgICBjbHNEcm9wOiBTdHJpbmcsXG4gICAgICAgIGJvdW5kYXJ5OiBCb29sZWFuLFxuICAgICAgICBkcm9wYmFyOiBCb29sZWFuLFxuICAgICAgICBkcm9wYmFyQW5jaG9yOiBCb29sZWFuLFxuICAgICAgICBkdXJhdGlvbjogTnVtYmVyLFxuICAgICAgICBtb2RlOiBCb29sZWFuLFxuICAgICAgICBvZmZzZXQ6IEJvb2xlYW4sXG4gICAgICAgIHN0cmV0Y2g6IEJvb2xlYW4sXG4gICAgICAgIGRlbGF5U2hvdzogQm9vbGVhbixcbiAgICAgICAgZGVsYXlIaWRlOiBCb29sZWFuLFxuICAgICAgICB0YXJnZXQ6IEJvb2xlYW4sXG4gICAgICAgIHRhcmdldFg6IEJvb2xlYW4sXG4gICAgICAgIHRhcmdldFk6IEJvb2xlYW4sXG4gICAgICAgIGFuaW1hdGlvbjogQm9vbGVhbixcbiAgICAgICAgYW5pbWF0ZU91dDogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZHJvcGRvd246ICcudWstbmF2YmFyLW5hdiA+IGxpID4gYSwgLnVrLW5hdmJhci1pdGVtLCAudWstbmF2YmFyLXRvZ2dsZScsXG4gICAgICAgIGFsaWduOiBpc1J0bCA/ICdyaWdodCcgOiAnbGVmdCcsXG4gICAgICAgIGNsc0Ryb3A6ICd1ay1uYXZiYXItZHJvcGRvd24nLFxuICAgICAgICBib3VuZGFyeTogdHJ1ZSxcbiAgICAgICAgZHJvcGJhcjogZmFsc2UsXG4gICAgICAgIGRyb3BiYXJBbmNob3I6IGZhbHNlLFxuICAgICAgICBkdXJhdGlvbjogMjAwLFxuICAgICAgICBjb250YWluZXI6IGZhbHNlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgZHJvcGJhckFuY2hvcihfcmVmLCAkZWwpIHtsZXQgeyBkcm9wYmFyQW5jaG9yIH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiBxdWVyeShkcm9wYmFyQW5jaG9yLCAkZWwpIHx8ICRlbDtcbiAgICAgICAgfSxcblxuICAgICAgICBkcm9wYmFyOiB7XG4gICAgICAgICAgZ2V0KF9yZWYyKSB7bGV0IHsgZHJvcGJhciB9ID0gX3JlZjI7XG4gICAgICAgICAgICBpZiAoIWRyb3BiYXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRyb3BiYXIgPVxuICAgICAgICAgICAgdGhpcy5fZHJvcGJhciB8fFxuICAgICAgICAgICAgcXVlcnkoZHJvcGJhciwgdGhpcy4kZWwpIHx8XG4gICAgICAgICAgICAkKCcrIC51ay1uYXZiYXItZHJvcGJhcicsIHRoaXMuJGVsKTtcblxuICAgICAgICAgICAgcmV0dXJuIGRyb3BiYXIgPyBkcm9wYmFyIDogdGhpcy5fZHJvcGJhciA9ICQoJzxkaXY+PC9kaXY+Jyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGRyb3BiYXIpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGRyb3BiYXIsICd1ay1kcm9wYmFyJywgJ3VrLWRyb3BiYXItdG9wJywgJ3VrLW5hdmJhci1kcm9wYmFyJyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgICAgZHJvcENvbnRhaW5lcihfLCAkZWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIgfHwgJGVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyb3Bkb3duczoge1xuICAgICAgICAgIGdldChfcmVmMywgJGVsKSB7bGV0IHsgY2xzRHJvcCB9ID0gX3JlZjM7XG4gICAgICAgICAgICBjb25zdCBkcm9wZG93bnMgPSAkJChcIi5cIiArIGNsc0Ryb3AsICRlbCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRyb3BDb250YWluZXIgIT09ICRlbCkge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mICQkKFwiLlwiICsgY2xzRHJvcCwgdGhpcy5kcm9wQ29udGFpbmVyKSkge3ZhciBfdGhpcyRnZXREcm9wZG93bjtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoX3RoaXMkZ2V0RHJvcGRvd24gPSB0aGlzLmdldERyb3Bkb3duKGVsKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGdldERyb3Bkb3duLnRhcmdldEVsO1xuICAgICAgICAgICAgICAgIGlmICghaW5jbHVkZXMoZHJvcGRvd25zLCBlbCkgJiYgdGFyZ2V0ICYmIHdpdGhpbih0YXJnZXQsIHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgICAgICAgZHJvcGRvd25zLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZHJvcGRvd25zO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChkcm9wZG93bnMpIHtcbiAgICAgICAgICAgIHRoaXMuJGNyZWF0ZShcbiAgICAgICAgICAgICdkcm9wJyxcbiAgICAgICAgICAgIGRyb3Bkb3ducy5maWx0ZXIoKGVsKSA9PiAhdGhpcy5nZXREcm9wZG93bihlbCkpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi50aGlzLiRwcm9wcyxcbiAgICAgICAgICAgICAgZmxpcDogZmFsc2UsXG4gICAgICAgICAgICAgIHNoaWZ0OiB0cnVlLFxuICAgICAgICAgICAgICBwb3M6IFwiYm90dG9tLVwiICsgdGhpcy5hbGlnbixcbiAgICAgICAgICAgICAgYm91bmRhcnk6IHRoaXMuYm91bmRhcnkgPT09IHRydWUgPyB0aGlzLiRlbCA6IHRoaXMuYm91bmRhcnkgfSk7XG5cblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSxcblxuXG4gICAgICAgIHRvZ2dsZXM6IHtcbiAgICAgICAgICBnZXQoX3JlZjQsICRlbCkge2xldCB7IGRyb3Bkb3duIH0gPSBfcmVmNDtcbiAgICAgICAgICAgIHJldHVybiAkJChkcm9wZG93biwgJGVsKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goKSB7XG4gICAgICAgICAgICBjb25zdCBqdXN0aWZ5ID0gaGFzQ2xhc3ModGhpcy4kZWwsICd1ay1uYXZiYXItanVzdGlmeScpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgJCQoXG4gICAgICAgICAgICAnLnVrLW5hdmJhci1uYXYsIC51ay1uYXZiYXItbGVmdCwgLnVrLW5hdmJhci1yaWdodCcsXG4gICAgICAgICAgICB0aGlzLiRlbCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNzcyhjb250YWluZXIsICdmbGV4R3JvdycsIGp1c3RpZnkgPyAkJCh0aGlzLmRyb3Bkb3duLCBjb250YWluZXIpLmxlbmd0aCA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0gfSxcblxuXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5kcm9wYmFyICYmIHJlbW92ZSQxKHRoaXMuZHJvcGJhcik7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9kcm9wYmFyO1xuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdtb3VzZW92ZXIgZm9jdXNpbicsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd247XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfcmVmNSkge2xldCB7IGN1cnJlbnQgfSA9IF9yZWY1O1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZ2V0QWN0aXZlKCk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIGFjdGl2ZSAmJlxuICAgICAgICAgIGluY2x1ZGVzKGFjdGl2ZS5tb2RlLCAnaG92ZXInKSAmJlxuICAgICAgICAgIGFjdGl2ZS50YXJnZXRFbCAmJlxuICAgICAgICAgICF3aXRoaW4oYWN0aXZlLnRhcmdldEVsLCBjdXJyZW50KSAmJlxuICAgICAgICAgICFhY3RpdmUuaXNEZWxheWluZylcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhY3RpdmUuaGlkZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAna2V5ZG93bicsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd247XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgY29uc3QgeyBjdXJyZW50LCBrZXlDb2RlIH0gPSBlO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZ2V0QWN0aXZlKCk7XG5cbiAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLkRPV04gJiYgaGFzQXR0cihjdXJyZW50LCAnYXJpYS1leHBhbmRlZCcpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmICghYWN0aXZlIHx8IGFjdGl2ZS50YXJnZXRFbCAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgICBjdXJyZW50LmNsaWNrKCk7XG4gICAgICAgICAgICAgIG9uY2UodGhpcy5kcm9wQ29udGFpbmVyLCAnc2hvdycsIChfcmVmNikgPT4ge2xldCB7IHRhcmdldCB9ID0gX3JlZjY7cmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIGZvY3VzRmlyc3RGb2N1c2FibGVFbGVtZW50KHRhcmdldCkpO30pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb2N1c0ZpcnN0Rm9jdXNhYmxlRWxlbWVudChhY3RpdmUuJGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYW5kbGVOYXZJdGVtTmF2aWdhdGlvbihlLCB0aGlzLnRvZ2dsZXMsIGFjdGl2ZSk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdrZXlkb3duJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wQ29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiBcIi5cIiArIHRoaXMuY2xzRHJvcDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBjb25zdCB7IGN1cnJlbnQsIGtleUNvZGUgfSA9IGU7XG5cbiAgICAgICAgICBpZiAoIWluY2x1ZGVzKHRoaXMuZHJvcGRvd25zLCBjdXJyZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZ2V0QWN0aXZlKCk7XG4gICAgICAgICAgY29uc3QgZWxlbWVudHMgPSAkJChzZWxGb2N1c2FibGUsIGN1cnJlbnQpO1xuICAgICAgICAgIGNvbnN0IGkgPSBmaW5kSW5kZXgoZWxlbWVudHMsIChlbCkgPT4gbWF0Y2hlcyhlbCwgJzpmb2N1cycpKTtcblxuICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXlNYXAuVVApIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICBlbGVtZW50c1tpIC0gMV0uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLkRPV04pIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChpIDwgZWxlbWVudHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBlbGVtZW50c1tpICsgMV0uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLkVTQykge3ZhciBfYWN0aXZlJHRhcmdldEVsO1xuICAgICAgICAgICAgYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiAoX2FjdGl2ZSR0YXJnZXRFbCA9IGFjdGl2ZS50YXJnZXRFbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hY3RpdmUkdGFyZ2V0RWwuZm9jdXMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYW5kbGVOYXZJdGVtTmF2aWdhdGlvbihlLCB0aGlzLnRvZ2dsZXMsIGFjdGl2ZSk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdtb3VzZWxlYXZlJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wYmFyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wYmFyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmUoKTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICBhY3RpdmUgJiZcbiAgICAgICAgICBpbmNsdWRlcyhhY3RpdmUubW9kZSwgJ2hvdmVyJykgJiZcbiAgICAgICAgICAhdGhpcy5kcm9wZG93bnMuc29tZSgoZWwpID0+IG1hdGNoZXMoZWwsICc6aG92ZXInKSkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgYWN0aXZlLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdiZWZvcmVzaG93JyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wQ29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wYmFyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoX3JlZjcpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWY3O1xuICAgICAgICAgIGlmICghdGhpcy5pc0Ryb3BiYXJEcm9wKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5kcm9wYmFyLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgIT09IHRoaXMuZHJvcGJhckFuY2hvcikge1xuICAgICAgICAgICAgYWZ0ZXIodGhpcy5kcm9wYmFyQW5jaG9yLCB0aGlzLmRyb3BiYXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFkZENsYXNzKHRhcmdldCwgdGhpcy5jbHNEcm9wICsgXCItZHJvcGJhclwiKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Nob3cnLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BDb250YWluZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BiYXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfcmVmOCkge2xldCB7IHRhcmdldCB9ID0gX3JlZjg7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzRHJvcGJhckRyb3AodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGRyb3AgPSB0aGlzLmdldERyb3Bkb3duKHRhcmdldCk7XG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBvYnNlcnZlUmVzaXplKFtkcm9wLiRlbCwgLi4uZHJvcC50YXJnZXRdLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRPZmZzZXRzID0gcGFyZW50cyh0YXJnZXQsIFwiLlwiICsgdGhpcy5jbHNEcm9wKS5cbiAgICAgICAgICAgIGNvbmNhdCh0YXJnZXQpLlxuICAgICAgICAgICAgbWFwKChlbCkgPT4gb2Zmc2V0KGVsKSk7XG4gICAgICAgICAgICBjb25zdCBtaW5Ub3AgPSBNYXRoLm1pbiguLi50YXJnZXRPZmZzZXRzLm1hcCgoX3JlZjkpID0+IHtsZXQgeyB0b3AgfSA9IF9yZWY5O3JldHVybiB0b3A7fSkpO1xuICAgICAgICAgICAgY29uc3QgbWF4Qm90dG9tID0gTWF0aC5tYXgoLi4udGFyZ2V0T2Zmc2V0cy5tYXAoKF9yZWYxMCkgPT4ge2xldCB7IGJvdHRvbSB9ID0gX3JlZjEwO3JldHVybiBib3R0b207fSkpO1xuICAgICAgICAgICAgY29uc3QgZHJvcGJhck9mZnNldCA9IG9mZnNldCh0aGlzLmRyb3BiYXIpO1xuICAgICAgICAgICAgY3NzKHRoaXMuZHJvcGJhciwgJ3RvcCcsIHRoaXMuZHJvcGJhci5vZmZzZXRUb3AgLSAoZHJvcGJhck9mZnNldC50b3AgLSBtaW5Ub3ApKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFxuICAgICAgICAgICAgbWF4Qm90dG9tIC0gbWluVG9wICsgdG9GbG9hdChjc3ModGFyZ2V0LCAnbWFyZ2luQm90dG9tJykpLFxuICAgICAgICAgICAgdGFyZ2V0KTtcblxuICAgICAgICAgIH0pO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnYmVmb3JlaGlkZScsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcENvbnRhaW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGJhcjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmdldEFjdGl2ZSgpO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIG1hdGNoZXModGhpcy5kcm9wYmFyLCAnOmhvdmVyJykgJiZcbiAgICAgICAgICAoYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuJGVsKSA9PT0gZS50YXJnZXQgJiZcbiAgICAgICAgICAhdGhpcy50b2dnbGVzLnNvbWUoKGVsKSA9PiBhY3RpdmUudGFyZ2V0RWwgIT09IGVsICYmIG1hdGNoZXMoZWwsICc6Zm9jdXMnKSkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGUnLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BDb250YWluZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BiYXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfcmVmMTEpIHt2YXIgX3RoaXMkX29ic2VydmVyO2xldCB7IHRhcmdldCB9ID0gX3JlZjExO1xuICAgICAgICAgIGlmICghdGhpcy5pc0Ryb3BiYXJEcm9wKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAoX3RoaXMkX29ic2VydmVyID0gdGhpcy5fb2JzZXJ2ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRfb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmUoKTtcblxuICAgICAgICAgIGlmICghYWN0aXZlIHx8IChhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS4kZWwpID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2V0QWN0aXZlKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLmRyb3Bkb3ducywgYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuJGVsKSAmJiBhY3RpdmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNpdGlvblRvKG5ld0hlaWdodCwgZWwpIHtcbiAgICAgICAgICBjb25zdCB7IGRyb3BiYXIgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3Qgb2xkSGVpZ2h0ID0gaGVpZ2h0KGRyb3BiYXIpO1xuXG4gICAgICAgICAgZWwgPSBvbGRIZWlnaHQgPCBuZXdIZWlnaHQgJiYgZWw7XG5cbiAgICAgICAgICBjc3MoZWwsICdjbGlwUGF0aCcsIFwicG9seWdvbigwIDAsMTAwJSAwLDEwMCUgXCIgKyBvbGRIZWlnaHQgKyBcInB4LDAgXCIgKyBvbGRIZWlnaHQgKyBcInB4KVwiKTtcblxuICAgICAgICAgIGhlaWdodChkcm9wYmFyLCBvbGRIZWlnaHQpO1xuXG4gICAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwoW2VsLCBkcm9wYmFyXSk7XG4gICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQoZHJvcGJhciwgeyBoZWlnaHQ6IG5ld0hlaWdodCB9LCB0aGlzLmR1cmF0aW9uKSxcbiAgICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsaXBQYXRoOiBcInBvbHlnb24oMCAwLDEwMCUgMCwxMDAlIFwiICsgbmV3SGVpZ2h0ICsgXCJweCwwIFwiICsgbmV3SGVpZ2h0ICsgXCJweClcIiB9LFxuXG4gICAgICAgICAgdGhpcy5kdXJhdGlvbildKS5cblxuXG4gICAgICAgICAgY2F0Y2gobm9vcCkuXG4gICAgICAgICAgdGhlbigoKSA9PiBjc3MoZWwsIHsgY2xpcFBhdGg6ICcnIH0pKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXREcm9wZG93bihlbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRnZXRDb21wb25lbnQoZWwsICdkcm9wJykgfHwgdGhpcy4kZ2V0Q29tcG9uZW50KGVsLCAnZHJvcGRvd24nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0Ryb3BiYXJEcm9wKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RHJvcGRvd24oZWwpICYmIGhhc0NsYXNzKGVsLCB0aGlzLmNsc0Ryb3ApO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBoYW5kbGVOYXZJdGVtTmF2aWdhdGlvbihlLCB0b2dnbGVzLCBhY3RpdmUpIHtcbiAgICAgIGNvbnN0IHsgY3VycmVudCwga2V5Q29kZSB9ID0gZTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IChhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS50YXJnZXRFbCkgfHwgY3VycmVudDtcbiAgICAgIGNvbnN0IGkgPSB0b2dnbGVzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgICAgLy8gTGVmdFxuICAgICAgaWYgKGtleUNvZGUgPT09IGtleU1hcC5MRUZUICYmIGkgPiAwKSB7XG4gICAgICAgIGFjdGl2ZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlLmhpZGUoZmFsc2UpO1xuICAgICAgICB0b2dnbGVzW2kgLSAxXS5mb2N1cygpO1xuICAgICAgfVxuXG4gICAgICAvLyBSaWdodFxuICAgICAgaWYgKGtleUNvZGUgPT09IGtleU1hcC5SSUdIVCAmJiBpIDwgdG9nZ2xlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGFjdGl2ZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlLmhpZGUoZmFsc2UpO1xuICAgICAgICB0b2dnbGVzW2kgKyAxXS5mb2N1cygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLlRBQikge1xuICAgICAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICAgICAgYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuaGlkZShmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9jdXNGaXJzdEZvY3VzYWJsZUVsZW1lbnQoZWwpIHtcbiAgICAgIGlmICghJCgnOmZvY3VzJywgZWwpKSB7dmFyIF8kO1xuICAgICAgICAoXyQgPSAkKHNlbEZvY3VzYWJsZSwgZWwpKSA9PSBudWxsID8gdm9pZCAwIDogXyQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBrZXlNYXAgPSB7XG4gICAgICBUQUI6IDksXG4gICAgICBFU0M6IDI3LFxuICAgICAgTEVGVDogMzcsXG4gICAgICBVUDogMzgsXG4gICAgICBSSUdIVDogMzksXG4gICAgICBET1dOOiA0MCB9O1xuXG4gICAgdmFyIFN3aXBlID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgc3dpcGluZzogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc3dpcGluZzogdHJ1ZSB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHN3aXBlVGFyZ2V0KHByb3BzLCAkZWwpIHtcbiAgICAgICAgICByZXR1cm4gJGVsO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3dpcGluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVyRXZlbnQodGhpcywge1xuICAgICAgICAgIGVsOiB0aGlzLnN3aXBlVGFyZ2V0LFxuICAgICAgICAgIG5hbWU6IHBvaW50ZXJEb3duJDEsXG4gICAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGlmICghaXNUb3VjaChlKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBTd2lwZSBHZXN0dXJlXG4gICAgICAgICAgICBjb25zdCBwb3MgPSBnZXRFdmVudFBvcyhlKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9ICd0YWdOYW1lJyBpbiBlLnRhcmdldCA/IGUudGFyZ2V0IDogcGFyZW50KGUudGFyZ2V0KTtcbiAgICAgICAgICAgIG9uY2UoZG9jdW1lbnQsIHBvaW50ZXJVcCQxICsgXCIgXCIgKyBwb2ludGVyQ2FuY2VsICsgXCIgc2Nyb2xsXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3MoZSk7XG5cbiAgICAgICAgICAgICAgLy8gc3dpcGVcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBlLnR5cGUgIT09ICdzY3JvbGwnICYmIHRhcmdldCAmJiB4ICYmIE1hdGguYWJzKHBvcy54IC0geCkgPiAxMDAgfHxcbiAgICAgICAgICAgICAgeSAmJiBNYXRoLmFicyhwb3MueSAtIHkpID4gMTAwKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgJ3N3aXBlJyk7XG4gICAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzd2lwZVwiICsgc3dpcGVEaXJlY3Rpb24ocG9zLngsIHBvcy55LCB4LCB5KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gfSk7XG5cbiAgICAgIH0gfTtcblxuXG4gICAgZnVuY3Rpb24gc3dpcGVEaXJlY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyh4MSAtIHgyKSA+PSBNYXRoLmFicyh5MSAtIHkyKSA/XG4gICAgICB4MSAtIHgyID4gMCA/XG4gICAgICAnTGVmdCcgOlxuICAgICAgJ1JpZ2h0JyA6XG4gICAgICB5MSAtIHkyID4gMCA/XG4gICAgICAnVXAnIDpcbiAgICAgICdEb3duJztcbiAgICB9XG5cbiAgICB2YXIgb2ZmY2FudmFzID0ge1xuICAgICAgbWl4aW5zOiBbTW9kYWwsIFN3aXBlXSxcblxuICAgICAgYXJnczogJ21vZGUnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBtb2RlOiBTdHJpbmcsXG4gICAgICAgIGZsaXA6IEJvb2xlYW4sXG4gICAgICAgIG92ZXJsYXk6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1vZGU6ICdzbGlkZScsXG4gICAgICAgIGZsaXA6IGZhbHNlLFxuICAgICAgICBvdmVybGF5OiBmYWxzZSxcbiAgICAgICAgY2xzUGFnZTogJ3VrLW9mZmNhbnZhcy1wYWdlJyxcbiAgICAgICAgY2xzQ29udGFpbmVyOiAndWstb2ZmY2FudmFzLWNvbnRhaW5lcicsXG4gICAgICAgIHNlbFBhbmVsOiAnLnVrLW9mZmNhbnZhcy1iYXInLFxuICAgICAgICBjbHNGbGlwOiAndWstb2ZmY2FudmFzLWZsaXAnLFxuICAgICAgICBjbHNDb250YWluZXJBbmltYXRpb246ICd1ay1vZmZjYW52YXMtY29udGFpbmVyLWFuaW1hdGlvbicsXG4gICAgICAgIGNsc1NpZGViYXJBbmltYXRpb246ICd1ay1vZmZjYW52YXMtYmFyLWFuaW1hdGlvbicsXG4gICAgICAgIGNsc01vZGU6ICd1ay1vZmZjYW52YXMnLFxuICAgICAgICBjbHNPdmVybGF5OiAndWstb2ZmY2FudmFzLW92ZXJsYXknLFxuICAgICAgICBzZWxDbG9zZTogJy51ay1vZmZjYW52YXMtY2xvc2UnLFxuICAgICAgICBjb250YWluZXI6IGZhbHNlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xzRmxpcChfcmVmKSB7bGV0IHsgZmxpcCwgY2xzRmxpcCB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gZmxpcCA/IGNsc0ZsaXAgOiAnJztcbiAgICAgICAgfSxcblxuICAgICAgICBjbHNPdmVybGF5KF9yZWYyKSB7bGV0IHsgb3ZlcmxheSwgY2xzT3ZlcmxheSB9ID0gX3JlZjI7XG4gICAgICAgICAgcmV0dXJuIG92ZXJsYXkgPyBjbHNPdmVybGF5IDogJyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xzTW9kZShfcmVmMykge2xldCB7IG1vZGUsIGNsc01vZGUgfSA9IF9yZWYzO1xuICAgICAgICAgIHJldHVybiBjbHNNb2RlICsgXCItXCIgKyBtb2RlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsc1NpZGViYXJBbmltYXRpb24oX3JlZjQpIHtsZXQgeyBtb2RlLCBjbHNTaWRlYmFyQW5pbWF0aW9uIH0gPSBfcmVmNDtcbiAgICAgICAgICByZXR1cm4gbW9kZSA9PT0gJ25vbmUnIHx8IG1vZGUgPT09ICdyZXZlYWwnID8gJycgOiBjbHNTaWRlYmFyQW5pbWF0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsc0NvbnRhaW5lckFuaW1hdGlvbihfcmVmNSkge2xldCB7IG1vZGUsIGNsc0NvbnRhaW5lckFuaW1hdGlvbiB9ID0gX3JlZjU7XG4gICAgICAgICAgcmV0dXJuIG1vZGUgIT09ICdwdXNoJyAmJiBtb2RlICE9PSAncmV2ZWFsJyA/ICcnIDogY2xzQ29udGFpbmVyQW5pbWF0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zaXRpb25FbGVtZW50KF9yZWY2KSB7bGV0IHsgbW9kZSB9ID0gX3JlZjY7XG4gICAgICAgICAgcmV0dXJuIG1vZGUgPT09ICdyZXZlYWwnID8gcGFyZW50KHRoaXMucGFuZWwpIDogdGhpcy5wYW5lbDtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpICYmICFpc1Zpc2libGUodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0sXG5cblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd0b3VjaG1vdmUnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUuY2FuY2VsYWJsZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzaG93JyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ3JldmVhbCcgJiYgIWhhc0NsYXNzKHBhcmVudCh0aGlzLnBhbmVsKSwgdGhpcy5jbHNNb2RlKSkge1xuICAgICAgICAgICAgd3JhcEFsbCh0aGlzLnBhbmVsLCAnPGRpdj4nKTtcbiAgICAgICAgICAgIGFkZENsYXNzKHBhcmVudCh0aGlzLnBhbmVsKSwgdGhpcy5jbHNNb2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7IGJvZHksIHNjcm9sbGluZ0VsZW1lbnQgfSA9IGRvY3VtZW50O1xuXG4gICAgICAgICAgYWRkQ2xhc3MoYm9keSwgdGhpcy5jbHNDb250YWluZXIsIHRoaXMuY2xzRmxpcCk7XG4gICAgICAgICAgY3NzKGJvZHksICd0b3VjaC1hY3Rpb24nLCAncGFuLXkgcGluY2gtem9vbScpO1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICAgICAgICBjc3ModGhpcy5wYW5lbCwgJ21heFdpZHRoJywgc2Nyb2xsaW5nRWxlbWVudC5jbGllbnRXaWR0aCk7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzT3ZlcmxheSk7XG4gICAgICAgICAgYWRkQ2xhc3MoXG4gICAgICAgICAgdGhpcy5wYW5lbCxcbiAgICAgICAgICB0aGlzLmNsc1NpZGViYXJBbmltYXRpb24sXG4gICAgICAgICAgdGhpcy5tb2RlID09PSAncmV2ZWFsJyA/ICcnIDogdGhpcy5jbHNNb2RlKTtcblxuXG4gICAgICAgICAgaGVpZ2h0KGJvZHkpOyAvLyBmb3JjZSByZWZsb3dcbiAgICAgICAgICBhZGRDbGFzcyhib2R5LCB0aGlzLmNsc0NvbnRhaW5lckFuaW1hdGlvbik7XG5cbiAgICAgICAgICB0aGlzLmNsc0NvbnRhaW5lckFuaW1hdGlvbiAmJiBzdXBwcmVzc1VzZXJTY2FsZSgpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZScsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksIHRoaXMuY2xzQ29udGFpbmVyQW5pbWF0aW9uKTtcbiAgICAgICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ3RvdWNoLWFjdGlvbicsICcnKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGRlbicsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuY2xzQ29udGFpbmVyQW5pbWF0aW9uICYmIHJlc3VtZVVzZXJTY2FsZSgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ3JldmVhbCcpIHtcbiAgICAgICAgICAgIHVud3JhcCh0aGlzLnBhbmVsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLnBhbmVsLCB0aGlzLmNsc1NpZGViYXJBbmltYXRpb24sIHRoaXMuY2xzTW9kZSk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzT3ZlcmxheSk7XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCAnZGlzcGxheScsICcnKTtcbiAgICAgICAgICBjc3ModGhpcy5wYW5lbCwgJ21heFdpZHRoJywgJycpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksIHRoaXMuY2xzQ29udGFpbmVyLCB0aGlzLmNsc0ZsaXApO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc3dpcGVMZWZ0IHN3aXBlUmlnaHQnLFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpICYmIGVuZHNXaXRoKGUudHlwZSwgJ0xlZnQnKSBeIHRoaXMuZmxpcCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dIH07XG5cblxuXG5cbiAgICAvLyBDaHJvbWUgaW4gcmVzcG9uc2l2ZSBtb2RlIHpvb21zIHBhZ2UgdXBvbiBvcGVuaW5nIG9mZmNhbnZhc1xuICAgIGZ1bmN0aW9uIHN1cHByZXNzVXNlclNjYWxlKCkge1xuICAgICAgZ2V0Vmlld3BvcnQoKS5jb250ZW50ICs9ICcsdXNlci1zY2FsYWJsZT0wJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXN1bWVVc2VyU2NhbGUoKSB7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0KCk7XG4gICAgICB2aWV3cG9ydC5jb250ZW50ID0gdmlld3BvcnQuY29udGVudC5yZXBsYWNlKC8sdXNlci1zY2FsYWJsZT0wJC8sICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWaWV3cG9ydCgpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICQoJ21ldGFbbmFtZT1cInZpZXdwb3J0XCJdJywgZG9jdW1lbnQuaGVhZCkgfHwgYXBwZW5kKGRvY3VtZW50LmhlYWQsICc8bWV0YSBuYW1lPVwidmlld3BvcnRcIj4nKSk7XG5cbiAgICB9XG5cbiAgICB2YXIgb3ZlcmZsb3dBdXRvID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIFJlc2l6ZV0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHNlbENvbnRhaW5lcjogU3RyaW5nLFxuICAgICAgICBzZWxDb250ZW50OiBTdHJpbmcsXG4gICAgICAgIG1pbkhlaWdodDogTnVtYmVyIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBzZWxDb250YWluZXI6ICcudWstbW9kYWwnLFxuICAgICAgICBzZWxDb250ZW50OiAnLnVrLW1vZGFsLWRpYWxvZycsXG4gICAgICAgIG1pbkhlaWdodDogMTUwIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29udGFpbmVyKF9yZWYsICRlbCkge2xldCB7IHNlbENvbnRhaW5lciB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gY2xvc2VzdCgkZWwsIHNlbENvbnRhaW5lcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGVudChfcmVmMiwgJGVsKSB7bGV0IHsgc2VsQ29udGVudCB9ID0gX3JlZjI7XG4gICAgICAgICAgcmV0dXJuIGNsb3Nlc3QoJGVsLCBzZWxDb250ZW50KTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5jb250YWluZXIsIHRoaXMuY29udGVudF07XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuY29udGVudCB8fCAhdGhpcy5jb250YWluZXIgfHwgIWlzVmlzaWJsZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF4OiBNYXRoLm1heChcbiAgICAgICAgICAgIHRoaXMubWluSGVpZ2h0LFxuICAgICAgICAgICAgaGVpZ2h0KHRoaXMuY29udGFpbmVyKSAtIChkaW1lbnNpb25zJDEodGhpcy5jb250ZW50KS5oZWlnaHQgLSBoZWlnaHQodGhpcy4kZWwpKSkgfTtcblxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoX3JlZjMpIHtsZXQgeyBtYXggfSA9IF9yZWYzO1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgeyBtaW5IZWlnaHQ6IHRoaXMubWluSGVpZ2h0LCBtYXhIZWlnaHQ6IG1heCB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSB9O1xuXG4gICAgdmFyIHJlc3BvbnNpdmUgPSB7XG4gICAgICBtaXhpbnM6IFtSZXNpemVdLFxuXG4gICAgICBwcm9wczogWyd3aWR0aCcsICdoZWlnaHQnXSxcblxuICAgICAgcmVzaXplVGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLiRlbCwgcGFyZW50KHRoaXMuJGVsKV07XG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCAndWstcmVzcG9uc2l2ZS13aWR0aCcpO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgcmV0dXJuIGlzVmlzaWJsZSh0aGlzLiRlbCkgJiYgdGhpcy53aWR0aCAmJiB0aGlzLmhlaWdodCA/XG4gICAgICAgICAgeyB3aWR0aDogd2lkdGgocGFyZW50KHRoaXMuJGVsKSksIGhlaWdodDogdGhpcy5oZWlnaHQgfSA6XG4gICAgICAgICAgZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoZGltKSB7XG4gICAgICAgICAgaGVpZ2h0KFxuICAgICAgICAgIHRoaXMuJGVsLFxuICAgICAgICAgIERpbWVuc2lvbnMuY29udGFpbihcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGggfSxcblxuICAgICAgICAgIGRpbSkuXG4gICAgICAgICAgaGVpZ2h0KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9IH07XG5cbiAgICB2YXIgc2Nyb2xsID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgb2Zmc2V0OiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG9mZnNldDogMCB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgcmVnaXN0ZXJDbGljayh0aGlzKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdW5yZWdpc3RlckNsaWNrKHRoaXMpO1xuICAgICAgfSxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBzY3JvbGxUbyhlbCkge1xuICAgICAgICAgIGVsID0gZWwgJiYgJChlbCkgfHwgZG9jdW1lbnQuYm9keTtcblxuICAgICAgICAgIGlmICh0cmlnZ2VyKHRoaXMuJGVsLCAnYmVmb3Jlc2Nyb2xsJywgW3RoaXMsIGVsXSkpIHtcbiAgICAgICAgICAgIGF3YWl0IHNjcm9sbEludG9WaWV3KGVsLCB7IG9mZnNldDogdGhpcy5vZmZzZXQgfSk7XG4gICAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnc2Nyb2xsZWQnLCBbdGhpcywgZWxdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGNvbnN0IGNvbXBvbmVudHMkMiA9IG5ldyBTZXQoKTtcbiAgICBmdW5jdGlvbiByZWdpc3RlckNsaWNrKGNtcCkge1xuICAgICAgaWYgKCFjb21wb25lbnRzJDIuc2l6ZSkge1xuICAgICAgICBvbihkb2N1bWVudCwgJ2NsaWNrJywgY2xpY2tIYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50cyQyLmFkZChjbXApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXJDbGljayhjbXApIHtcbiAgICAgIGNvbXBvbmVudHMkMi5kZWxldGUoY21wKTtcblxuICAgICAgaWYgKCFjb21wb25lbnRzJDIuc2l6ZSkge1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdjbGljaycsIGNsaWNrSGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpY2tIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBjb21wb25lbnRzJDIpIHtcbiAgICAgICAgaWYgKHdpdGhpbihlLnRhcmdldCwgY29tcG9uZW50LiRlbCkpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgY29tcG9uZW50LnNjcm9sbFRvKGdldFRhcmdldEVsZW1lbnQoY29tcG9uZW50LiRlbCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VGFyZ2V0RWxlbWVudChlbCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRlY29kZVVSSUNvbXBvbmVudChlbC5oYXNoKS5zdWJzdHJpbmcoMSkpO1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxzcHkgPSB7XG4gICAgICBtaXhpbnM6IFtTY3JvbGxdLFxuXG4gICAgICBhcmdzOiAnY2xzJyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2xzOiBTdHJpbmcsXG4gICAgICAgIHRhcmdldDogU3RyaW5nLFxuICAgICAgICBoaWRkZW46IEJvb2xlYW4sXG4gICAgICAgIG9mZnNldFRvcDogTnVtYmVyLFxuICAgICAgICBvZmZzZXRMZWZ0OiBOdW1iZXIsXG4gICAgICAgIHJlcGVhdDogQm9vbGVhbixcbiAgICAgICAgZGVsYXk6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6ICgpID0+ICh7XG4gICAgICAgIGNsczogJycsXG4gICAgICAgIHRhcmdldDogZmFsc2UsXG4gICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgb2Zmc2V0VG9wOiAwLFxuICAgICAgICBvZmZzZXRMZWZ0OiAwLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgaW5WaWV3Q2xhc3M6ICd1ay1zY3JvbGxzcHktaW52aWV3JyB9KSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgIGdldChfcmVmLCAkZWwpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0ID8gJCQodGFyZ2V0LCAkZWwpIDogWyRlbF07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGVsZW1lbnRzLCBwcmV2KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgY3NzKGZpbHRlciQxKGVsZW1lbnRzLCBcIjpub3QoLlwiICsgdGhpcy5pblZpZXdDbGFzcyArIFwiKVwiKSwgJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNFcXVhbChlbGVtZW50cywgcHJldikpIHtcbiAgICAgICAgICAgICAgdGhpcy4kcmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0gfSxcblxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5fZGF0YS5lbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKFxuICAgICAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKFxuICAgICAgICB0aGlzLmVsZW1lbnRzLFxuICAgICAgICAocmVjb3JkcykgPT4ge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fZGF0YS5lbGVtZW50cztcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFyZ2V0OiBlbCwgaXNJbnRlcnNlY3RpbmcgfSBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnRzLmhhcyhlbCkpIHtcbiAgICAgICAgICAgICAgZWxlbWVudHMuc2V0KGVsLCB7XG4gICAgICAgICAgICAgICAgY2xzOiBkYXRhKGVsLCAndWstc2Nyb2xsc3B5LWNsYXNzJykgfHwgdGhpcy5jbHMgfSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBlbGVtZW50cy5nZXQoZWwpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlcGVhdCAmJiBzdGF0ZS5zaG93KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5zaG93ID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4kZW1pdCgpO1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcm9vdE1hcmdpbjogdG9QeCh0aGlzLm9mZnNldFRvcCwgJ2hlaWdodCcpIC0gMSArIFwicHggXCIgKyAoXG4gICAgICAgICAgdG9QeCh0aGlzLm9mZnNldExlZnQsICd3aWR0aCcpIC0gMSkgKyBcInB4XCIgfSxcblxuXG4gICAgICAgIGZhbHNlKSk7XG5cblxuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtlbCwgc3RhdGVdIG9mIHRoaXMuX2RhdGEuZWxlbWVudHMuZW50cmllcygpKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsIHRoaXMuaW5WaWV3Q2xhc3MsIChzdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuY2xzKSB8fCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZTogW1xuICAgICAge1xuICAgICAgICB3cml0ZShkYXRhKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbZWwsIHN0YXRlXSBvZiBkYXRhLmVsZW1lbnRzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNob3cgJiYgIXN0YXRlLmludmlldyAmJiAhc3RhdGUucXVldWVkKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnF1ZXVlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgZGF0YS5wcm9taXNlID0gKGRhdGEucHJvbWlzZSB8fCBQcm9taXNlLnJlc29sdmUoKSkuXG4gICAgICAgICAgICAgIHRoZW4oKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGhpcy5kZWxheSkpKS5cbiAgICAgICAgICAgICAgdGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGUoZWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgc3RhdGUucXVldWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCk7XG4gICAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5zaG93ICYmIHN0YXRlLmludmlldyAmJiAhc3RhdGUucXVldWVkICYmIHRoaXMucmVwZWF0KSB7XG4gICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGVsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICB0b2dnbGUoZWwsIGludmlldykge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fZGF0YS5lbGVtZW50cy5nZXQoZWwpO1xuXG4gICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXRlLm9mZiA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUub2ZmKCk7XG5cbiAgICAgICAgICBjc3MoZWwsICd2aXNpYmlsaXR5JywgIWludmlldyAmJiB0aGlzLmhpZGRlbiA/ICdoaWRkZW4nIDogJycpO1xuXG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMuaW5WaWV3Q2xhc3MsIGludmlldyk7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHN0YXRlLmNscyk7XG5cbiAgICAgICAgICBpZiAoL1xcYnVrLWFuaW1hdGlvbi0vLnRlc3Qoc3RhdGUuY2xzKSkge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlQW5pbWF0aW9uQ2xhc3NlcyA9ICgpID0+IHJlbW92ZUNsYXNzZXMoZWwsICd1ay1hbmltYXRpb24tW1xcXFx3LV0rJyk7XG4gICAgICAgICAgICBpZiAoaW52aWV3KSB7XG4gICAgICAgICAgICAgIHN0YXRlLm9mZiA9IG9uY2UoZWwsICdhbmltYXRpb25jYW5jZWwgYW5pbWF0aW9uZW5kJywgcmVtb3ZlQW5pbWF0aW9uQ2xhc3Nlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZW1vdmVBbmltYXRpb25DbGFzc2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJpZ2dlcihlbCwgaW52aWV3ID8gJ2ludmlldycgOiAnb3V0dmlldycpO1xuXG4gICAgICAgICAgc3RhdGUuaW52aWV3ID0gaW52aWV3O1xuXG4gICAgICAgICAgLy8gY2hhbmdlIHRvIGB2aXNpYmlsaXR5OiBoaWRkZW5gIGRvZXMgbm90IHRyaWdnZXIgb2JzZXJ2ZXJzXG4gICAgICAgICAgdGhpcy4kdXBkYXRlKGVsKTtcbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgc2Nyb2xsc3B5TmF2ID0ge1xuICAgICAgbWl4aW5zOiBbU2Nyb2xsXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2xzOiBTdHJpbmcsXG4gICAgICAgIGNsb3Nlc3Q6IFN0cmluZyxcbiAgICAgICAgc2Nyb2xsOiBCb29sZWFuLFxuICAgICAgICBvdmVyZmxvdzogQm9vbGVhbixcbiAgICAgICAgb2Zmc2V0OiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNsczogJ3VrLWFjdGl2ZScsXG4gICAgICAgIGNsb3Nlc3Q6IGZhbHNlLFxuICAgICAgICBzY3JvbGw6IGZhbHNlLFxuICAgICAgICBvdmVyZmxvdzogdHJ1ZSxcbiAgICAgICAgb2Zmc2V0OiAwIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgbGlua3M6IHtcbiAgICAgICAgICBnZXQoXywgJGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQoJ2FbaHJlZio9XCIjXCJdJywgJGVsKS5maWx0ZXIoKGVsKSA9PiBlbC5oYXNoICYmIGlzU2FtZVNpdGVBbmNob3IoZWwpKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2gobGlua3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbCkge1xuICAgICAgICAgICAgICB0aGlzLiRjcmVhdGUoJ3Njcm9sbCcsIGxpbmtzLCB7IG9mZnNldDogdGhpcy5vZmZzZXQgfHwgMCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0sXG5cblxuICAgICAgICBlbGVtZW50cyhfcmVmKSB7bGV0IHsgY2xvc2VzdDogc2VsZWN0b3IgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIGNsb3Nlc3QodGhpcy5saW5rcywgc2VsZWN0b3IgfHwgJyonKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHVwZGF0ZTogW1xuICAgICAge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldHMgPSB0aGlzLmxpbmtzLm1hcChnZXRUYXJnZXRFbGVtZW50KS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gdGFyZ2V0cztcblxuICAgICAgICAgIGlmICghbGVuZ3RoIHx8ICFpc1Zpc2libGUodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgW3Njcm9sbEVsZW1lbnRdID0gc2Nyb2xsUGFyZW50cyh0YXJnZXRzLCAvYXV0b3xzY3JvbGwvLCB0cnVlKTtcbiAgICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0IH0gPSBzY3JvbGxFbGVtZW50O1xuICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gb2Zmc2V0Vmlld3BvcnQoc2Nyb2xsRWxlbWVudCk7XG4gICAgICAgICAgY29uc3QgbWF4ID0gc2Nyb2xsSGVpZ2h0IC0gdmlld3BvcnQuaGVpZ2h0O1xuICAgICAgICAgIGxldCBhY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChzY3JvbGxUb3AgPT09IG1heCkge1xuICAgICAgICAgICAgYWN0aXZlID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQodGFyZ2V0c1tpXSkudG9wIC0gdmlld3BvcnQudG9wIC0gdGhpcy5vZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWN0aXZlID0gK2k7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhY3RpdmUgPT09IGZhbHNlICYmIHRoaXMub3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgYWN0aXZlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4geyBhY3RpdmUgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmMikge2xldCB7IGFjdGl2ZSB9ID0gX3JlZjI7XG4gICAgICAgICAgY29uc3QgY2hhbmdlZCA9IGFjdGl2ZSAhPT0gZmFsc2UgJiYgIWhhc0NsYXNzKHRoaXMuZWxlbWVudHNbYWN0aXZlXSwgdGhpcy5jbHMpO1xuXG4gICAgICAgICAgdGhpcy5saW5rcy5mb3JFYWNoKChlbCkgPT4gZWwuYmx1cigpKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWxlbWVudHNbaV0sIHRoaXMuY2xzLCAraSA9PT0gYWN0aXZlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ2FjdGl2ZScsIFthY3RpdmUsIHRoaXMuZWxlbWVudHNbYWN0aXZlXV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsnc2Nyb2xsJywgJ3Jlc2l6ZSddIH1dIH07XG5cbiAgICB2YXIgc3RpY2t5ID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIE1lZGlhLCBSZXNpemUsIFNjcm9sbF0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHBvc2l0aW9uOiBTdHJpbmcsXG4gICAgICAgIHRvcDogbnVsbCxcbiAgICAgICAgYm90dG9tOiBudWxsLFxuICAgICAgICBzdGFydDogbnVsbCxcbiAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICBvZmZzZXQ6IFN0cmluZyxcbiAgICAgICAgb3ZlcmZsb3dGbGlwOiBCb29sZWFuLFxuICAgICAgICBhbmltYXRpb246IFN0cmluZyxcbiAgICAgICAgY2xzQWN0aXZlOiBTdHJpbmcsXG4gICAgICAgIGNsc0luYWN0aXZlOiBTdHJpbmcsXG4gICAgICAgIGNsc0ZpeGVkOiBTdHJpbmcsXG4gICAgICAgIGNsc0JlbG93OiBTdHJpbmcsXG4gICAgICAgIHNlbFRhcmdldDogU3RyaW5nLFxuICAgICAgICBzaG93T25VcDogQm9vbGVhbixcbiAgICAgICAgdGFyZ2V0T2Zmc2V0OiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICAgICAgdG9wOiBmYWxzZSxcbiAgICAgICAgYm90dG9tOiBmYWxzZSxcbiAgICAgICAgc3RhcnQ6IGZhbHNlLFxuICAgICAgICBlbmQ6IGZhbHNlLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIG92ZXJmbG93RmxpcDogZmFsc2UsXG4gICAgICAgIGFuaW1hdGlvbjogJycsXG4gICAgICAgIGNsc0FjdGl2ZTogJ3VrLWFjdGl2ZScsXG4gICAgICAgIGNsc0luYWN0aXZlOiAnJyxcbiAgICAgICAgY2xzRml4ZWQ6ICd1ay1zdGlja3ktZml4ZWQnLFxuICAgICAgICBjbHNCZWxvdzogJ3VrLXN0aWNreS1iZWxvdycsXG4gICAgICAgIHNlbFRhcmdldDogJycsXG4gICAgICAgIHNob3dPblVwOiBmYWxzZSxcbiAgICAgICAgdGFyZ2V0T2Zmc2V0OiBmYWxzZSB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHNlbFRhcmdldChfcmVmLCAkZWwpIHtsZXQgeyBzZWxUYXJnZXQgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIHNlbFRhcmdldCAmJiAkKHNlbFRhcmdldCwgJGVsKSB8fCAkZWw7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICByZXNpemVUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfSxcblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gY29lcmNlKHRoaXMuc3RhcnQgfHwgdGhpcy50b3ApO1xuICAgICAgICB0aGlzLmVuZCA9IGNvZXJjZSh0aGlzLmVuZCB8fCB0aGlzLmJvdHRvbSk7XG5cbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9XG4gICAgICAgICQoJysgLnVrLXN0aWNreS1wbGFjZWhvbGRlcicsIHRoaXMuJGVsKSB8fFxuICAgICAgICAkKCc8ZGl2IGNsYXNzPVwidWstc3RpY2t5LXBsYWNlaG9sZGVyXCI+PC9kaXY+Jyk7XG4gICAgICAgIHRoaXMuaXNGaXhlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldEFjdGl2ZShmYWxzZSk7XG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRml4ZWQpIHtcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLnNlbFRhcmdldCwgdGhpcy5jbHNJbmFjdGl2ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdmUkMSh0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IG51bGw7XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Jlc2l6ZScsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ3Jlc2l6ZScpO1xuICAgICAgICB9IH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2xvYWQgaGFzaGNoYW5nZSBwb3BzdGF0ZScsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0T2Zmc2V0ICE9PSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsaW5nRWxlbWVudCB9ID0gZG9jdW1lbnQ7XG5cbiAgICAgICAgICBpZiAoIWxvY2F0aW9uLmhhc2ggfHwgc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE9mZnNldCA9IG9mZnNldCgkKGxvY2F0aW9uLmhhc2gpKTtcbiAgICAgICAgICAgIGNvbnN0IGVsT2Zmc2V0ID0gb2Zmc2V0KHRoaXMuJGVsKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNGaXhlZCAmJiBpbnRlcnNlY3RSZWN0KHRhcmdldE9mZnNldCwgZWxPZmZzZXQpKSB7XG4gICAgICAgICAgICAgIHNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wID1cbiAgICAgICAgICAgICAgdGFyZ2V0T2Zmc2V0LnRvcCAtXG4gICAgICAgICAgICAgIGVsT2Zmc2V0LmhlaWdodCAtXG4gICAgICAgICAgICAgIHRvUHgodGhpcy50YXJnZXRPZmZzZXQsICdoZWlnaHQnLCB0aGlzLnBsYWNlaG9sZGVyKSAtXG4gICAgICAgICAgICAgIHRvUHgodGhpcy5vZmZzZXQsICdoZWlnaHQnLCB0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIHVwZGF0ZTogW1xuICAgICAge1xuICAgICAgICByZWFkKF9yZWYyLCB0eXBlcykge2xldCB7IGhlaWdodDogaGVpZ2h0JDEsIG1hcmdpbiB9ID0gX3JlZjI7XG4gICAgICAgICAgdGhpcy5pbmFjdGl2ZSA9ICF0aGlzLm1hdGNoTWVkaWEgfHwgIWlzVmlzaWJsZSh0aGlzLiRlbCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pbmFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGhpZGUgPSB0aGlzLmFjdGl2ZSAmJiB0eXBlcy5oYXMoJ3Jlc2l6ZScpO1xuICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICBjc3ModGhpcy5zZWxUYXJnZXQsICd0cmFuc2l0aW9uJywgJzBzJyk7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICBoZWlnaHQkMSA9IG9mZnNldCh0aGlzLiRlbCkuaGVpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luID0gY3NzKHRoaXMuJGVsLCAnbWFyZ2luJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGNzcyh0aGlzLnNlbFRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLmlzRml4ZWQgPyB0aGlzLnBsYWNlaG9sZGVyIDogdGhpcy4kZWw7XG4gICAgICAgICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gaGVpZ2h0KHdpbmRvdyk7XG5cbiAgICAgICAgICBsZXQgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICAgIGlmICh0aGlzLm92ZXJmbG93RmxpcCAmJiBoZWlnaHQkMSA+IHdpbmRvd0hlaWdodCkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gJ3RvcCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBvZmZzZXQkMSA9IHRvUHgodGhpcy5vZmZzZXQsICdoZWlnaHQnLCByZWZlcmVuY2VFbGVtZW50KTtcbiAgICAgICAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nICYmIChoZWlnaHQkMSA8IHdpbmRvd0hlaWdodCB8fCB0aGlzLm92ZXJmbG93RmxpcCkpIHtcbiAgICAgICAgICAgIG9mZnNldCQxICs9IHdpbmRvd0hlaWdodCAtIGhlaWdodCQxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gdGhpcy5vdmVyZmxvd0ZsaXAgP1xuICAgICAgICAgIDAgOlxuICAgICAgICAgIE1hdGgubWF4KDAsIGhlaWdodCQxICsgb2Zmc2V0JDEgLSB3aW5kb3dIZWlnaHQpO1xuICAgICAgICAgIGNvbnN0IHRvcE9mZnNldCA9IG9mZnNldChyZWZlcmVuY2VFbGVtZW50KS50b3A7XG5cbiAgICAgICAgICBjb25zdCBzdGFydCA9XG4gICAgICAgICAgKHRoaXMuc3RhcnQgPT09IGZhbHNlID9cbiAgICAgICAgICB0b3BPZmZzZXQgOlxuICAgICAgICAgIHBhcnNlUHJvcCh0aGlzLnN0YXJ0LCB0aGlzLiRlbCwgdG9wT2Zmc2V0KSkgLSBvZmZzZXQkMTtcbiAgICAgICAgICBjb25zdCBlbmQgPVxuICAgICAgICAgIHRoaXMuZW5kID09PSBmYWxzZSA/XG4gICAgICAgICAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxIZWlnaHQgLSB3aW5kb3dIZWlnaHQgOlxuICAgICAgICAgIHBhcnNlUHJvcCh0aGlzLmVuZCwgdGhpcy4kZWwsIHRvcE9mZnNldCArIGhlaWdodCQxLCB0cnVlKSAtXG4gICAgICAgICAgb2Zmc2V0KHRoaXMuJGVsKS5oZWlnaHQgK1xuICAgICAgICAgIG92ZXJmbG93IC1cbiAgICAgICAgICBvZmZzZXQkMTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0JDEsXG4gICAgICAgICAgICBvdmVyZmxvdyxcbiAgICAgICAgICAgIHRvcE9mZnNldCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0JDEsXG4gICAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgICB3aWR0aDogZGltZW5zaW9ucyQxKHJlZmVyZW5jZUVsZW1lbnQpLndpZHRoLFxuICAgICAgICAgICAgdG9wOiBvZmZzZXRQb3NpdGlvbihyZWZlcmVuY2VFbGVtZW50KVswXSB9O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoX3JlZjMpIHtsZXQgeyBoZWlnaHQsIG1hcmdpbiB9ID0gX3JlZjM7XG4gICAgICAgICAgY29uc3QgeyBwbGFjZWhvbGRlciB9ID0gdGhpcztcblxuICAgICAgICAgIGNzcyhwbGFjZWhvbGRlciwgeyBoZWlnaHQsIG1hcmdpbiB9KTtcblxuICAgICAgICAgIGlmICghd2l0aGluKHBsYWNlaG9sZGVyLCBkb2N1bWVudCkpIHtcbiAgICAgICAgICAgIGFmdGVyKHRoaXMuJGVsLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICBwbGFjZWhvbGRlci5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSxcblxuXG4gICAgICB7XG4gICAgICAgIHJlYWQoX3JlZjQpXG5cblxuXG5cblxuXG4gICAgICAgIHtsZXQgeyBzY3JvbGw6IHByZXZTY3JvbGwgPSAwLCBkaXI6IHByZXZEaXIgPSAnZG93bicsIG92ZXJmbG93LCBvdmVyZmxvd1Njcm9sbCA9IDAsIHN0YXJ0LCBlbmQgfSA9IF9yZWY0O1xuICAgICAgICAgIGNvbnN0IHNjcm9sbCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgIGNvbnN0IGRpciA9IHByZXZTY3JvbGwgPD0gc2Nyb2xsID8gJ2Rvd24nIDogJ3VwJztcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICBwcmV2RGlyLFxuICAgICAgICAgICAgc2Nyb2xsLFxuICAgICAgICAgICAgcHJldlNjcm9sbCxcbiAgICAgICAgICAgIG9mZnNldFBhcmVudFRvcDogb2Zmc2V0KFxuICAgICAgICAgICAgKHRoaXMuaXNGaXhlZCA/IHRoaXMucGxhY2Vob2xkZXIgOiB0aGlzLiRlbCkub2Zmc2V0UGFyZW50KS5cbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIG92ZXJmbG93U2Nyb2xsOiBjbGFtcChcbiAgICAgICAgICAgIG92ZXJmbG93U2Nyb2xsICsgY2xhbXAoc2Nyb2xsLCBzdGFydCwgZW5kKSAtIGNsYW1wKHByZXZTY3JvbGwsIHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIG92ZXJmbG93KSB9O1xuXG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShkYXRhLCB0eXBlcykge1xuICAgICAgICAgIGNvbnN0IGlzU2Nyb2xsVXBkYXRlID0gdHlwZXMuaGFzKCdzY3JvbGwnKTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpbml0VGltZXN0YW1wID0gMCxcbiAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgIHByZXZEaXIsXG4gICAgICAgICAgICBzY3JvbGwsXG4gICAgICAgICAgICBwcmV2U2Nyb2xsID0gMCxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgdG9wT2Zmc2V0LFxuICAgICAgICAgICAgaGVpZ2h0IH0gPVxuICAgICAgICAgIGRhdGE7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgc2Nyb2xsIDwgMCB8fFxuICAgICAgICAgIHNjcm9sbCA9PT0gcHJldlNjcm9sbCAmJiBpc1Njcm9sbFVwZGF0ZSB8fFxuICAgICAgICAgIHRoaXMuc2hvd09uVXAgJiYgIWlzU2Nyb2xsVXBkYXRlICYmICF0aGlzLmlzRml4ZWQpXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgaWYgKG5vdyAtIGluaXRUaW1lc3RhbXAgPiAzMDAgfHwgZGlyICE9PSBwcmV2RGlyKSB7XG4gICAgICAgICAgICBkYXRhLmluaXRTY3JvbGwgPSBzY3JvbGw7XG4gICAgICAgICAgICBkYXRhLmluaXRUaW1lc3RhbXAgPSBub3c7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuc2hvd09uVXAgJiZcbiAgICAgICAgICAhdGhpcy5pc0ZpeGVkICYmXG4gICAgICAgICAgTWF0aC5hYnMoZGF0YS5pbml0U2Nyb2xsIC0gc2Nyb2xsKSA8PSAzMCAmJlxuICAgICAgICAgIE1hdGguYWJzKHByZXZTY3JvbGwgLSBzY3JvbGwpIDw9IDEwKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5pbmFjdGl2ZSB8fFxuICAgICAgICAgIHNjcm9sbCA8IHN0YXJ0IHx8XG4gICAgICAgICAgdGhpcy5zaG93T25VcCAmJiAoXG4gICAgICAgICAgc2Nyb2xsIDw9IHN0YXJ0IHx8XG4gICAgICAgICAgZGlyID09PSAnZG93bicgJiYgaXNTY3JvbGxVcGRhdGUgfHxcbiAgICAgICAgICBkaXIgPT09ICd1cCcgJiYgIXRoaXMuaXNGaXhlZCAmJiBzY3JvbGwgPD0gdG9wT2Zmc2V0ICsgaGVpZ2h0KSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNGaXhlZCkge1xuICAgICAgICAgICAgICBpZiAoQW5pbWF0aW9uLmluUHJvZ3Jlc3ModGhpcy4kZWwpICYmIHRvcCA+IHNjcm9sbCkge1xuICAgICAgICAgICAgICAgIEFuaW1hdGlvbi5jYW5jZWwodGhpcy4kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmlzRml4ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uICYmIHNjcm9sbCA+IHRvcE9mZnNldCkge1xuICAgICAgICAgICAgICBBbmltYXRpb24uY2FuY2VsKHRoaXMuJGVsKTtcbiAgICAgICAgICAgICAgQW5pbWF0aW9uLm91dCh0aGlzLiRlbCwgdGhpcy5hbmltYXRpb24pLnRoZW4oKCkgPT4gdGhpcy5oaWRlKCksIG5vb3ApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRml4ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFuaW1hdGlvbiAmJiBzY3JvbGwgPiB0b3BPZmZzZXQpIHtcbiAgICAgICAgICAgIEFuaW1hdGlvbi5jYW5jZWwodGhpcy4kZWwpO1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICBBbmltYXRpb24uaW4odGhpcy4kZWwsIHRoaXMuYW5pbWF0aW9uKS5jYXRjaChub29wKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnLCAnc2Nyb2xsJ10gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgdGhpcy5pc0ZpeGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZSgpIHtcbiAgICAgICAgICB0aGlzLnNldEFjdGl2ZShmYWxzZSk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRml4ZWQsIHRoaXMuY2xzQmVsb3cpO1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgeyBwb3NpdGlvbjogJycsIHRvcDogJycsIHdpZHRoOiAnJyB9KTtcbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmhpZGRlbiA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlKCkge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIHNjcm9sbCA9IDAsXG4gICAgICAgICAgICBvdmVyZmxvdyxcbiAgICAgICAgICAgIG92ZXJmbG93U2Nyb2xsID0gMCxcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgdG9wT2Zmc2V0LFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50VG9wIH0gPVxuICAgICAgICAgIHRoaXMuX2RhdGE7XG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gc3RhcnQgIT09IDAgfHwgc2Nyb2xsID4gc3RhcnQ7XG4gICAgICAgICAgbGV0IHBvc2l0aW9uID0gJ2ZpeGVkJztcblxuICAgICAgICAgIGlmIChzY3JvbGwgPiBlbmQpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBlbmQgLSBvZmZzZXRQYXJlbnRUb3A7XG4gICAgICAgICAgICBwb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG92ZXJmbG93KSB7XG4gICAgICAgICAgICBvZmZzZXQgLT0gb3ZlcmZsb3dTY3JvbGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCB7XG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHRvcDogb2Zmc2V0ICsgXCJweFwiLFxuICAgICAgICAgICAgd2lkdGggfSk7XG5cblxuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlKGFjdGl2ZSk7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzQmVsb3csIHNjcm9sbCA+IHRvcE9mZnNldCArIGhlaWdodCk7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRml4ZWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEFjdGl2ZShhY3RpdmUpIHtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5hY3RpdmU7XG4gICAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgcmVwbGFjZUNsYXNzKHRoaXMuc2VsVGFyZ2V0LCB0aGlzLmNsc0luYWN0aXZlLCB0aGlzLmNsc0FjdGl2ZSk7XG4gICAgICAgICAgICBwcmV2ICE9PSBhY3RpdmUgJiYgdHJpZ2dlcih0aGlzLiRlbCwgJ2FjdGl2ZScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBsYWNlQ2xhc3ModGhpcy5zZWxUYXJnZXQsIHRoaXMuY2xzQWN0aXZlLCB0aGlzLmNsc0luYWN0aXZlKTtcbiAgICAgICAgICAgIHByZXYgIT09IGFjdGl2ZSAmJiB0cmlnZ2VyKHRoaXMuJGVsLCAnaW5hY3RpdmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvcCh2YWx1ZSwgZWwsIHByb3BPZmZzZXQsIHBhZGRpbmcpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc051bWVyaWModmFsdWUpIHx8IGlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5tYXRjaCgvXi0/XFxkLykpIHtcbiAgICAgICAgcmV0dXJuIHByb3BPZmZzZXQgKyB0b1B4KHZhbHVlLCAnaGVpZ2h0JywgZWwsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVmRWxlbWVudCA9IHZhbHVlID09PSB0cnVlID8gcGFyZW50KGVsKSA6IHF1ZXJ5KHZhbHVlLCBlbCk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgb2Zmc2V0KHJlZkVsZW1lbnQpLmJvdHRvbSAtIChcbiAgICAgICAgICBwYWRkaW5nICYmIHJlZkVsZW1lbnQgJiYgd2l0aGluKGVsLCByZWZFbGVtZW50KSA/XG4gICAgICAgICAgdG9GbG9hdChjc3MocmVmRWxlbWVudCwgJ3BhZGRpbmdCb3R0b20nKSkgOlxuICAgICAgICAgIDApKTtcblxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvZXJjZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgU3dpdGNoZXIgPSB7XG4gICAgICBtaXhpbnM6IFtMYXp5bG9hZCwgU3dpcGUsIFRvZ2dsYWJsZV0sXG5cbiAgICAgIGFyZ3M6ICdjb25uZWN0JyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY29ubmVjdDogU3RyaW5nLFxuICAgICAgICB0b2dnbGU6IFN0cmluZyxcbiAgICAgICAgaXRlbU5hdjogU3RyaW5nLFxuICAgICAgICBhY3RpdmU6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY29ubmVjdDogJ34udWstc3dpdGNoZXInLFxuICAgICAgICB0b2dnbGU6ICc+ICogPiA6Zmlyc3QtY2hpbGQnLFxuICAgICAgICBpdGVtTmF2OiBmYWxzZSxcbiAgICAgICAgYWN0aXZlOiAwLFxuICAgICAgICBjbHM6ICd1ay1hY3RpdmUnLFxuICAgICAgICBhdHRySXRlbTogJ3VrLXN3aXRjaGVyLWl0ZW0nIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29ubmVjdHM6IHtcbiAgICAgICAgICBnZXQoX3JlZiwgJGVsKSB7bGV0IHsgY29ubmVjdCB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeUFsbChjb25uZWN0LCAkZWwpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChjb25uZWN0cykge3ZhciBfdGhpcyRfb2JzZXJ2ZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5zd2lwaW5nKSB7XG4gICAgICAgICAgICAgIGNzcyhjb25uZWN0cywgJ3RvdWNoQWN0aW9uJywgJ3Bhbi15IHBpbmNoLXpvb20nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKF90aGlzJF9vYnNlcnZlciA9IHRoaXMuX29ic2VydmVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJPYnNlcnZlcihcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZU11dGF0aW9uKFxuICAgICAgICAgICAgY29ubmVjdHMsXG4gICAgICAgICAgICAocmVjb3JkcykgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHRhcmdldDogZWwgfSBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4oZWwpLmZvckVhY2goKGNoaWxkLCBpKSA9PlxuICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGNoaWxkLCB0aGlzLmNscywgaSA9PT0gaW5kZXgpKTtcblxuICAgICAgICAgICAgICAgIHRoaXMubGF6eWxvYWQodGhpcy4kZWwsIGNoaWxkcmVuKGVsKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IGNoaWxkTGlzdDogdHJ1ZSB9KSk7XG5cblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSxcblxuXG4gICAgICAgIHRvZ2dsZXM6IHtcbiAgICAgICAgICBnZXQoX3JlZjIsICRlbCkge2xldCB7IHRvZ2dsZSB9ID0gX3JlZjI7XG4gICAgICAgICAgICByZXR1cm4gJCQodG9nZ2xlLCAkZWwpLmZpbHRlcihcbiAgICAgICAgICAgIChlbCkgPT4gIW1hdGNoZXMoZWwsICcudWstZGlzYWJsZWQgKiwgLnVrLWRpc2FibGVkLCBbZGlzYWJsZWRdJykpO1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKHRvZ2dsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdyh+YWN0aXZlID8gYWN0aXZlIDogdG9nZ2xlc1t0aGlzLmFjdGl2ZV0gfHwgdG9nZ2xlc1swXSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgICAgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkcmVuKHRoaXMuJGVsKS5maWx0ZXIoKGNoaWxkKSA9PlxuICAgICAgICAgIHRoaXMudG9nZ2xlcy5zb21lKCh0b2dnbGUpID0+IHdpdGhpbih0b2dnbGUsIGNoaWxkKSkpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3dpcGVUYXJnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdHM7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBjb25uZWN0c1xuICAgICAgICByZWFkeSgoKSA9PiB0aGlzLiRlbWl0KCkpO1xuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNob3coZS5jdXJyZW50KTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0cy5jb25jYXQodGhpcy5pdGVtTmF2ID8gcXVlcnlBbGwodGhpcy5pdGVtTmF2LCB0aGlzLiRlbCkgOiBbXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiW1wiICsgdGhpcy5hdHRySXRlbSArIFwiXSxbZGF0YS1cIiArIHRoaXMuYXR0ckl0ZW0gKyBcIl1cIjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5zaG93KGRhdGEoZS5jdXJyZW50LCB0aGlzLmF0dHJJdGVtKSk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzd2lwZVJpZ2h0IHN3aXBlTGVmdCcsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN3aXBpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfcmVmMykge2xldCB7IHR5cGUgfSA9IF9yZWYzO1xuICAgICAgICAgIHRoaXMuc2hvdyhlbmRzV2l0aCh0eXBlLCAnTGVmdCcpID8gJ25leHQnIDogJ3ByZXZpb3VzJyk7XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGluZGV4KCkge1xuICAgICAgICAgIHJldHVybiBmaW5kSW5kZXgodGhpcy5jaGlsZHJlbiwgKGVsKSA9PiBoYXNDbGFzcyhlbCwgdGhpcy5jbHMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93KGl0ZW0pIHtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5pbmRleCgpO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBnZXRJbmRleChpdGVtLCB0aGlzLnRvZ2dsZXMsIHByZXYpO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IGdldEluZGV4KHRoaXMuY2hpbGRyZW5bbmV4dF0sIGNoaWxkcmVuKHRoaXMuJGVsKSk7XG4gICAgICAgICAgY2hpbGRyZW4odGhpcy4kZWwpLmZvckVhY2goKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhjaGlsZCwgdGhpcy5jbHMsIGFjdGl2ZSA9PT0gaSk7XG4gICAgICAgICAgICBhdHRyKHRoaXMudG9nZ2xlc1tpXSwgJ2FyaWEtZXhwYW5kZWQnLCBhY3RpdmUgPT09IGkpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgYW5pbWF0ZSA9IHByZXYgPj0gMCAmJiBwcmV2ICE9PSBuZXh0O1xuICAgICAgICAgIHRoaXMuY29ubmVjdHMuZm9yRWFjaChhc3luYyAoX3JlZjQpID0+IHtsZXQgeyBjaGlsZHJlbiB9ID0gX3JlZjQ7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQoXG4gICAgICAgICAgICB0b05vZGVzKGNoaWxkcmVuKS5maWx0ZXIoKGNoaWxkKSA9PiBoYXNDbGFzcyhjaGlsZCwgdGhpcy5jbHMpKSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgYW5pbWF0ZSk7XG5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlRWxlbWVudChjaGlsZHJlblthY3RpdmVdLCB0cnVlLCBhbmltYXRlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgdGFiID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3NdLFxuXG4gICAgICBleHRlbmRzOiBTd2l0Y2hlcixcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbWVkaWE6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1lZGlhOiA5NjAsXG4gICAgICAgIGF0dHJJdGVtOiAndWstdGFiLWl0ZW0nIH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBjb25zdCBjbHMgPSBoYXNDbGFzcyh0aGlzLiRlbCwgJ3VrLXRhYi1sZWZ0JykgP1xuICAgICAgICAndWstdGFiLWxlZnQnIDpcbiAgICAgICAgaGFzQ2xhc3ModGhpcy4kZWwsICd1ay10YWItcmlnaHQnKSA/XG4gICAgICAgICd1ay10YWItcmlnaHQnIDpcbiAgICAgICAgZmFsc2U7XG5cbiAgICAgICAgaWYgKGNscykge1xuICAgICAgICAgIHRoaXMuJGNyZWF0ZSgndG9nZ2xlJywgdGhpcy4kZWwsIHsgY2xzLCBtb2RlOiAnbWVkaWEnLCBtZWRpYTogdGhpcy5tZWRpYSB9KTtcbiAgICAgICAgfVxuICAgICAgfSB9O1xuXG4gICAgY29uc3QgS0VZX1NQQUNFID0gMzI7XG5cbiAgICB2YXIgdG9nZ2xlID0ge1xuICAgICAgbWl4aW5zOiBbTGF6eWxvYWQsIE1lZGlhLCBUb2dnbGFibGVdLFxuXG4gICAgICBhcmdzOiAndGFyZ2V0JyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaHJlZjogU3RyaW5nLFxuICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIG1vZGU6ICdsaXN0JyxcbiAgICAgICAgcXVldWVkOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBocmVmOiBmYWxzZSxcbiAgICAgICAgdGFyZ2V0OiBmYWxzZSxcbiAgICAgICAgbW9kZTogJ2NsaWNrJyxcbiAgICAgICAgcXVldWVkOiB0cnVlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgZ2V0KF9yZWYsICRlbCkge2xldCB7IGhyZWYsIHRhcmdldCB9ID0gX3JlZjtcbiAgICAgICAgICAgIHRhcmdldCA9IHF1ZXJ5QWxsKHRhcmdldCB8fCBocmVmLCAkZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5sZW5ndGggJiYgdGFyZ2V0IHx8IFskZWxdO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaCgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXJpYSgpO1xuICAgICAgICAgICAgdGhpcy5sYXp5bG9hZCh0aGlzLiRlbCwgdGhpcy50YXJnZXQpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSB9LFxuXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBpZiAoIWluY2x1ZGVzKHRoaXMubW9kZSwgJ21lZGlhJykgJiYgIWlzRm9jdXNhYmxlKHRoaXMuJGVsKSkge1xuICAgICAgICAgIGF0dHIodGhpcy4kZWwsICd0YWJpbmRleCcsICcwJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgdGFyZ2V0XG4gICAgICAgIHJlYWR5KCgpID0+IHRoaXMuJGVtaXQoKSk7XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogcG9pbnRlckRvd24kMSxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKHRoaXMubW9kZSwgJ2hvdmVyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgdGhpcy5fcHJldmVudENsaWNrID0gbnVsbDtcblxuICAgICAgICAgIGlmICghaXNUb3VjaChlKSB8fCB0aGlzLl9zaG93U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDbGlja2luZyBhIGJ1dHRvbiBkb2VzIG5vdCBnaXZlIGl0IGZvY3VzIG9uIGFsbCBicm93c2VycyBhbmQgcGxhdGZvcm1zXG4gICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2J1dHRvbiNjbGlja2luZ19hbmRfZm9jdXNcbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnZm9jdXMnKTtcbiAgICAgICAgICBvbmNlKFxuICAgICAgICAgIGRvY3VtZW50LFxuICAgICAgICAgIHBvaW50ZXJEb3duJDEsXG4gICAgICAgICAgKCkgPT4gdHJpZ2dlcih0aGlzLiRlbCwgJ2JsdXInKSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIChlKSA9PiAhd2l0aGluKGUudGFyZ2V0LCB0aGlzLiRlbCkpO1xuXG5cbiAgICAgICAgICAvLyBQcmV2ZW50IGluaXRpYWwgY2xpY2sgdG8gcHJldmVudCBkb3VibGUgdG9nZ2xlIHRocm91Z2ggZm9jdXMgKyBjbGlja1xuICAgICAgICAgIGlmIChpbmNsdWRlcyh0aGlzLm1vZGUsICdjbGljaycpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2ZW50Q2xpY2sgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogcG9pbnRlckVudGVyICsgXCIgXCIgKyBwb2ludGVyTGVhdmUgKyBcIiBmb2N1cyBibHVyXCIsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdob3ZlcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmIChpc1RvdWNoKGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgc2hvdyA9IGluY2x1ZGVzKFtwb2ludGVyRW50ZXIsICdmb2N1cyddLCBlLnR5cGUpO1xuICAgICAgICAgIGNvbnN0IGV4cGFuZGVkID0gYXR0cih0aGlzLiRlbCwgJ2FyaWEtZXhwYW5kZWQnKTtcblxuICAgICAgICAgIC8vIFNraXAgaGlkZSBpZiBzdGlsbCBob3ZlcmVkIG9yIGZvY3VzZWRcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIXNob3cgJiYgKFxuICAgICAgICAgIGUudHlwZSA9PT0gcG9pbnRlckxlYXZlICYmIG1hdGNoZXModGhpcy4kZWwsICc6Zm9jdXMnKSB8fFxuICAgICAgICAgIGUudHlwZSA9PT0gJ2JsdXInICYmIG1hdGNoZXModGhpcy4kZWwsICc6aG92ZXInKSkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNraXAgaWYgc3RhdGUgZG9lcyBub3QgY2hhbmdlIGUuZy4gaG92ZXIgKyBmb2N1cyByZWNlaXZlZFxuICAgICAgICAgIGlmICh0aGlzLl9zaG93U3RhdGUgJiYgc2hvdyAmJiBleHBhbmRlZCAhPT0gdGhpcy5fc2hvd1N0YXRlKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgcmVzZXQgaWYgc3RhdGUgaGFzIGNoYW5nZWQgdGhyb3VnaCBjbGlja1xuICAgICAgICAgICAgaWYgKCFzaG93KSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Nob3dTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fc2hvd1N0YXRlID0gc2hvdyA/IGV4cGFuZGVkIDogbnVsbDtcblxuICAgICAgICAgIHRoaXMudG9nZ2xlKFwidG9nZ2xlXCIgKyAoc2hvdyA/ICdzaG93JyA6ICdoaWRlJykpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAna2V5ZG93bicsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdjbGljaycpICYmICFpc1RhZyh0aGlzLiRlbCwgJ2lucHV0Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS0VZX1NQQUNFKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLiRlbC5jbGljaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIFsnY2xpY2snLCAnaG92ZXInXS5zb21lKChtb2RlKSA9PiBpbmNsdWRlcyh0aGlzLm1vZGUsIG1vZGUpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBsZXQgbGluaztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5fcHJldmVudENsaWNrIHx8XG4gICAgICAgICAgY2xvc2VzdChlLnRhcmdldCwgJ2FbaHJlZj1cIiNcIl0sIGFbaHJlZj1cIlwiXScpIHx8XG4gICAgICAgICAgKGxpbmsgPSBjbG9zZXN0KGUudGFyZ2V0LCAnYVtocmVmXScpKSAmJiAoXG4gICAgICAgICAgYXR0cih0aGlzLiRlbCwgJ2FyaWEtZXhwYW5kZWQnKSAhPT0gJ3RydWUnIHx8XG4gICAgICAgICAgbGluay5oYXNoICYmIG1hdGNoZXModGhpcy50YXJnZXQsIGxpbmsuaGFzaCkpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX3ByZXZlbnRDbGljayAmJiBpbmNsdWRlcyh0aGlzLm1vZGUsICdjbGljaycpKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGUgc2hvdycsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfcmVmMikge2xldCB7IHRhcmdldCwgdHlwZSB9ID0gX3JlZjI7XG4gICAgICAgICAgdGhpcy51cGRhdGVBcmlhKHRhcmdldCA9PT0gdGhpcy50YXJnZXRbMF0gJiYgdHlwZSA9PT0gJ3Nob3cnKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ21lZGlhY2hhbmdlJyxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKHRoaXMubW9kZSwgJ21lZGlhJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSwgbWVkaWFPYmopIHtcbiAgICAgICAgICBpZiAobWVkaWFPYmoubWF0Y2hlcyBeIHRoaXMuaXNUb2dnbGVkKHRoaXMudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIHRvZ2dsZSh0eXBlKSB7XG4gICAgICAgICAgaWYgKCF0cmlnZ2VyKHRoaXMudGFyZ2V0LCB0eXBlIHx8ICd0b2dnbGUnLCBbdGhpc10pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLnF1ZXVlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLnRhcmdldCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbGVhdmluZyA9IHRoaXMudGFyZ2V0LmZpbHRlcigoZWwpID0+IGhhc0NsYXNzKGVsLCB0aGlzLmNsc0xlYXZlKSk7XG5cbiAgICAgICAgICBpZiAobGVhdmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgY29uc3QgaXNMZWF2aW5nID0gaW5jbHVkZXMobGVhdmluZywgZWwpO1xuICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUVsZW1lbnQoZWwsIGlzTGVhdmluZywgaXNMZWF2aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0b2dnbGVkID0gdGhpcy50YXJnZXQuZmlsdGVyKHRoaXMuaXNUb2dnbGVkKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQodG9nZ2xlZCwgZmFsc2UpO1xuICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlRWxlbWVudChcbiAgICAgICAgICB0aGlzLnRhcmdldC5maWx0ZXIoKGVsKSA9PiAhaW5jbHVkZXModG9nZ2xlZCwgZWwpKSxcbiAgICAgICAgICB0cnVlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUFyaWEodG9nZ2xlZCkge1xuICAgICAgICAgIGlmIChpbmNsdWRlcyh0aGlzLm1vZGUsICdtZWRpYScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXR0cihcbiAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICAnYXJpYS1leHBhbmRlZCcsXG4gICAgICAgICAgaXNCb29sZWFuKHRvZ2dsZWQpID8gdG9nZ2xlZCA6IHRoaXMuaXNUb2dnbGVkKHRoaXMudGFyZ2V0KSk7XG5cbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgY29tcG9uZW50cyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIEFjY29yZGlvbjogQWNjb3JkaW9uLFxuICAgICAgICBBbGVydDogYWxlcnQsXG4gICAgICAgIENvdmVyOiBjb3ZlcixcbiAgICAgICAgRHJvcDogZHJvcCxcbiAgICAgICAgRHJvcGRvd246IGRyb3AsXG4gICAgICAgIEZvcm1DdXN0b206IGZvcm1DdXN0b20sXG4gICAgICAgIEdyaWQ6IGdyaWQsXG4gICAgICAgIEhlaWdodE1hdGNoOiBoZWlnaHRNYXRjaCxcbiAgICAgICAgSGVpZ2h0Vmlld3BvcnQ6IGhlaWdodFZpZXdwb3J0LFxuICAgICAgICBJY29uOiBJY29uLFxuICAgICAgICBJbWc6IGltZyxcbiAgICAgICAgTGVhZGVyOiBsZWFkZXIsXG4gICAgICAgIE1hcmdpbjogTWFyZ2luLFxuICAgICAgICBNb2RhbDogbW9kYWwsXG4gICAgICAgIE5hdjogbmF2LFxuICAgICAgICBOYXZiYXI6IG5hdmJhcixcbiAgICAgICAgT2ZmY2FudmFzOiBvZmZjYW52YXMsXG4gICAgICAgIE92ZXJmbG93QXV0bzogb3ZlcmZsb3dBdXRvLFxuICAgICAgICBSZXNwb25zaXZlOiByZXNwb25zaXZlLFxuICAgICAgICBTY3JvbGw6IHNjcm9sbCxcbiAgICAgICAgU2Nyb2xsc3B5OiBzY3JvbGxzcHksXG4gICAgICAgIFNjcm9sbHNweU5hdjogc2Nyb2xsc3B5TmF2LFxuICAgICAgICBTdGlja3k6IHN0aWNreSxcbiAgICAgICAgU3ZnOiBTVkcsXG4gICAgICAgIFN3aXRjaGVyOiBTd2l0Y2hlcixcbiAgICAgICAgVGFiOiB0YWIsXG4gICAgICAgIFRvZ2dsZTogdG9nZ2xlLFxuICAgICAgICBWaWRlbzogVmlkZW8sXG4gICAgICAgIENsb3NlOiBDbG9zZSxcbiAgICAgICAgU3Bpbm5lcjogU3Bpbm5lcixcbiAgICAgICAgTmF2UGFyZW50SWNvbjogTmF2UGFyZW50SWNvbixcbiAgICAgICAgU2xpZGVuYXZOZXh0OiBTbGlkZW5hdixcbiAgICAgICAgU2xpZGVuYXZQcmV2aW91czogU2xpZGVuYXYsXG4gICAgICAgIFNlYXJjaEljb246IFNlYXJjaCxcbiAgICAgICAgTWFya2VyOiBJY29uQ29tcG9uZW50LFxuICAgICAgICBOYXZiYXJQYXJlbnRJY29uOiBJY29uQ29tcG9uZW50LFxuICAgICAgICBOYXZiYXJUb2dnbGVJY29uOiBJY29uQ29tcG9uZW50LFxuICAgICAgICBPdmVybGF5SWNvbjogSWNvbkNvbXBvbmVudCxcbiAgICAgICAgUGFnaW5hdGlvbk5leHQ6IEljb25Db21wb25lbnQsXG4gICAgICAgIFBhZ2luYXRpb25QcmV2aW91czogSWNvbkNvbXBvbmVudCxcbiAgICAgICAgVG90b3A6IEljb25Db21wb25lbnRcbiAgICB9KTtcblxuICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudHNcbiAgICBlYWNoKGNvbXBvbmVudHMkMSwgKGNvbXBvbmVudCwgbmFtZSkgPT4gVUlraXQuY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkpO1xuXG4gICAgYm9vdChVSWtpdCk7XG5cbiAgICBjb25zdCB1bml0cyA9IFsnZGF5cycsICdob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXTtcblxuICAgIHZhciBjb3VudGRvd24gPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzc10sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGRhdGU6IFN0cmluZyxcbiAgICAgICAgY2xzV3JhcHBlcjogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBkYXRlOiAnJyxcbiAgICAgICAgY2xzV3JhcHBlcjogJy51ay1jb3VudGRvd24tJXVuaXQlJyB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5kYXRlID0gRGF0ZS5wYXJzZSh0aGlzLiRwcm9wcy5kYXRlKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAndmlzaWJpbGl0eWNoYW5nZScsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMudXBkYXRlLCAxMDAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdG9wKCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlKCkge1xuICAgICAgICAgIGNvbnN0IHRpbWVzcGFuID0gZ2V0VGltZVNwYW4odGhpcy5kYXRlKTtcblxuICAgICAgICAgIGlmICghdGhpcy5kYXRlIHx8IHRpbWVzcGFuLnRvdGFsIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgICAgICB0aW1lc3Bhbi5kYXlzID0gdGltZXNwYW4uaG91cnMgPSB0aW1lc3Bhbi5taW51dGVzID0gdGltZXNwYW4uc2Vjb25kcyA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChjb25zdCB1bml0IG9mIHVuaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9ICQodGhpcy5jbHNXcmFwcGVyLnJlcGxhY2UoJyV1bml0JScsIHVuaXQpLCB0aGlzLiRlbCk7XG5cbiAgICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBkaWdpdHMgPSBTdHJpbmcoTWF0aC50cnVuYyh0aW1lc3Bhblt1bml0XSkpO1xuXG4gICAgICAgICAgICBkaWdpdHMgPSBkaWdpdHMubGVuZ3RoIDwgMiA/IFwiMFwiICsgZGlnaXRzIDogZGlnaXRzO1xuXG4gICAgICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQgIT09IGRpZ2l0cykge1xuICAgICAgICAgICAgICBkaWdpdHMgPSBkaWdpdHMuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgIGlmIChkaWdpdHMubGVuZ3RoICE9PSBlbC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBodG1sKGVsLCBkaWdpdHMubWFwKCgpID0+ICc8c3Bhbj48L3NwYW4+Jykuam9pbignJykpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGlnaXRzLmZvckVhY2goKGRpZ2l0LCBpKSA9PiBlbC5jaGlsZHJlbltpXS50ZXh0Q29udGVudCA9IGRpZ2l0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGdldFRpbWVTcGFuKGRhdGUpIHtcbiAgICAgIGNvbnN0IHRvdGFsID0gZGF0ZSAtIERhdGUubm93KCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvdGFsLFxuICAgICAgICBzZWNvbmRzOiB0b3RhbCAvIDEwMDAgJSA2MCxcbiAgICAgICAgbWludXRlczogdG90YWwgLyAxMDAwIC8gNjAgJSA2MCxcbiAgICAgICAgaG91cnM6IHRvdGFsIC8gMTAwMCAvIDYwIC8gNjAgJSAyNCxcbiAgICAgICAgZGF5czogdG90YWwgLyAxMDAwIC8gNjAgLyA2MCAvIDI0IH07XG5cbiAgICB9XG5cbiAgICBjb25zdCBjbHNMZWF2ZSA9ICd1ay10cmFuc2l0aW9uLWxlYXZlJztcbiAgICBjb25zdCBjbHNFbnRlciA9ICd1ay10cmFuc2l0aW9uLWVudGVyJztcblxuICAgIGZ1bmN0aW9uIGZhZGUoYWN0aW9uLCB0YXJnZXQsIGR1cmF0aW9uLCBzdGFnZ2VyKSB7aWYgKHN0YWdnZXIgPT09IHZvaWQgMCkge3N0YWdnZXIgPSAwO31cbiAgICAgIGNvbnN0IGluZGV4ID0gdHJhbnNpdGlvbkluZGV4KHRhcmdldCwgdHJ1ZSk7XG4gICAgICBjb25zdCBwcm9wc0luID0geyBvcGFjaXR5OiAxIH07XG4gICAgICBjb25zdCBwcm9wc091dCA9IHsgb3BhY2l0eTogMCB9O1xuXG4gICAgICBjb25zdCB3cmFwSW5kZXhGbiA9IChmbikgPT4gKCkgPT4gaW5kZXggPT09IHRyYW5zaXRpb25JbmRleCh0YXJnZXQpID8gZm4oKSA6IFByb21pc2UucmVqZWN0KCk7XG5cbiAgICAgIGNvbnN0IGxlYXZlRm4gPSB3cmFwSW5kZXhGbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGFkZENsYXNzKHRhcmdldCwgY2xzTGVhdmUpO1xuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBnZXRUcmFuc2l0aW9uTm9kZXModGFyZ2V0KS5tYXAoXG4gICAgICAgIChjaGlsZCwgaSkgPT5cbiAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+XG4gICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICgpID0+XG4gICAgICAgIFRyYW5zaXRpb24uc3RhcnQoY2hpbGQsIHByb3BzT3V0LCBkdXJhdGlvbiAvIDIsICdlYXNlJykudGhlbihcbiAgICAgICAgcmVzb2x2ZSksXG5cbiAgICAgICAgaSAqIHN0YWdnZXIpKSkpO1xuXG5cblxuXG5cbiAgICAgICAgcmVtb3ZlQ2xhc3ModGFyZ2V0LCBjbHNMZWF2ZSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZW50ZXJGbiA9IHdyYXBJbmRleEZuKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkSGVpZ2h0ID0gaGVpZ2h0KHRhcmdldCk7XG5cbiAgICAgICAgYWRkQ2xhc3ModGFyZ2V0LCBjbHNFbnRlcik7XG4gICAgICAgIGFjdGlvbigpO1xuXG4gICAgICAgIGNzcyhjaGlsZHJlbih0YXJnZXQpLCB7IG9wYWNpdHk6IDAgfSk7XG5cbiAgICAgICAgLy8gRW5zdXJlIFVJa2l0IHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkXG4gICAgICAgIGF3YWl0IGF3YWl0RnJhbWUkMSgpO1xuXG4gICAgICAgIGNvbnN0IG5vZGVzID0gY2hpbGRyZW4odGFyZ2V0KTtcbiAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gaGVpZ2h0KHRhcmdldCk7XG5cbiAgICAgICAgLy8gRW5zdXJlIEdyaWQgY2VsbHMgZG8gbm90IHN0cmV0Y2ggd2hlbiBoZWlnaHQgaXMgYXBwbGllZFxuICAgICAgICBjc3ModGFyZ2V0LCAnYWxpZ25Db250ZW50JywgJ2ZsZXgtc3RhcnQnKTtcbiAgICAgICAgaGVpZ2h0KHRhcmdldCwgb2xkSGVpZ2h0KTtcblxuICAgICAgICBjb25zdCB0cmFuc2l0aW9uTm9kZXMgPSBnZXRUcmFuc2l0aW9uTm9kZXModGFyZ2V0KTtcbiAgICAgICAgY3NzKG5vZGVzLCBwcm9wc091dCk7XG5cbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uTm9kZXMubWFwKGFzeW5jIChjaGlsZCwgaSkgPT4ge1xuICAgICAgICAgIGF3YWl0IGF3YWl0VGltZW91dChpICogc3RhZ2dlcik7XG4gICAgICAgICAgYXdhaXQgVHJhbnNpdGlvbi5zdGFydChjaGlsZCwgcHJvcHNJbiwgZHVyYXRpb24gLyAyLCAnZWFzZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob2xkSGVpZ2h0ICE9PSBuZXdIZWlnaHQpIHtcbiAgICAgICAgICB0cmFuc2l0aW9ucy5wdXNoKFxuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQoXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHsgaGVpZ2h0OiBuZXdIZWlnaHQgfSxcbiAgICAgICAgICBkdXJhdGlvbiAvIDIgKyB0cmFuc2l0aW9uTm9kZXMubGVuZ3RoICogc3RhZ2dlcixcbiAgICAgICAgICAnZWFzZScpKTtcblxuXG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0cmFuc2l0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGFyZ2V0LCBjbHNFbnRlcik7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSB0cmFuc2l0aW9uSW5kZXgodGFyZ2V0KSkge1xuICAgICAgICAgICAgY3NzKHRhcmdldCwgeyBoZWlnaHQ6ICcnLCBhbGlnbkNvbnRlbnQ6ICcnIH0pO1xuICAgICAgICAgICAgY3NzKG5vZGVzLCB7IG9wYWNpdHk6ICcnIH0pO1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldC5kYXRhc2V0LnRyYW5zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gaGFzQ2xhc3ModGFyZ2V0LCBjbHNMZWF2ZSkgP1xuICAgICAgd2FpdFRyYW5zaXRpb25lbmQodGFyZ2V0KS50aGVuKGVudGVyRm4pIDpcbiAgICAgIGhhc0NsYXNzKHRhcmdldCwgY2xzRW50ZXIpID9cbiAgICAgIHdhaXRUcmFuc2l0aW9uZW5kKHRhcmdldCkudGhlbihsZWF2ZUZuKS50aGVuKGVudGVyRm4pIDpcbiAgICAgIGxlYXZlRm4oKS50aGVuKGVudGVyRm4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb25JbmRleCh0YXJnZXQsIG5leHQpIHtcbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIHRhcmdldC5kYXRhc2V0LnRyYW5zaXRpb24gPSAxICsgdHJhbnNpdGlvbkluZGV4KHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b051bWJlcih0YXJnZXQuZGF0YXNldC50cmFuc2l0aW9uKSB8fCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhaXRUcmFuc2l0aW9uZW5kKHRhcmdldCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgY2hpbGRyZW4odGFyZ2V0KS5cbiAgICAgIGZpbHRlcihUcmFuc2l0aW9uLmluUHJvZ3Jlc3MpLlxuICAgICAgbWFwKFxuICAgICAgKGVsKSA9PlxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IG9uY2UoZWwsICd0cmFuc2l0aW9uZW5kIHRyYW5zaXRpb25jYW5jZWxlZCcsIHJlc29sdmUpKSkpO1xuXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uTm9kZXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0Um93cyhjaGlsZHJlbih0YXJnZXQpKS5yZWR1Y2UoXG4gICAgICAobm9kZXMsIHJvdykgPT5cbiAgICAgIG5vZGVzLmNvbmNhdChcbiAgICAgIHNvcnRCeSQxKFxuICAgICAgcm93LmZpbHRlcigoZWwpID0+IGlzSW5WaWV3KGVsKSksXG4gICAgICAnb2Zmc2V0TGVmdCcpKSxcblxuXG4gICAgICBbXSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhd2FpdEZyYW1lJDEoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXNvbHZlKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXdhaXRUaW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0KSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gc2xpZGUgKGFjdGlvbiwgdGFyZ2V0LCBkdXJhdGlvbikge1xuICAgICAgYXdhaXQgYXdhaXRGcmFtZSgpO1xuXG4gICAgICBsZXQgbm9kZXMgPSBjaGlsZHJlbih0YXJnZXQpO1xuXG4gICAgICAvLyBHZXQgY3VycmVudCBzdGF0ZVxuICAgICAgY29uc3QgY3VycmVudFByb3BzID0gbm9kZXMubWFwKChlbCkgPT4gZ2V0UHJvcHMoZWwsIHRydWUpKTtcbiAgICAgIGNvbnN0IHRhcmdldFByb3BzID0geyAuLi5jc3ModGFyZ2V0LCBbJ2hlaWdodCcsICdwYWRkaW5nJ10pLCBkaXNwbGF5OiAnYmxvY2snIH07XG5cbiAgICAgIC8vIENhbmNlbCBwcmV2aW91cyBhbmltYXRpb25zXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChub2Rlcy5jb25jYXQodGFyZ2V0KS5tYXAoVHJhbnNpdGlvbi5jYW5jZWwpKTtcblxuICAgICAgLy8gQWRkaW5nLCBzb3J0aW5nLCByZW1vdmluZyBub2Rlc1xuICAgICAgYWN0aW9uKCk7XG5cbiAgICAgIC8vIEZpbmQgbmV3IG5vZGVzXG4gICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZHJlbih0YXJnZXQpLmZpbHRlcigoZWwpID0+ICFpbmNsdWRlcyhub2RlcywgZWwpKSk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIHVwZGF0ZSB0byBwcm9wYWdhdGVcbiAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgICAvLyBGb3JjZSB1cGRhdGVcbiAgICAgIGZhc3Rkb20uZmx1c2goKTtcblxuICAgICAgLy8gR2V0IG5ldyBzdGF0ZVxuICAgICAgY29uc3QgdGFyZ2V0U3R5bGUgPSBhdHRyKHRhcmdldCwgJ3N0eWxlJyk7XG4gICAgICBjb25zdCB0YXJnZXRQcm9wc1RvID0gY3NzKHRhcmdldCwgWydoZWlnaHQnLCAncGFkZGluZyddKTtcbiAgICAgIGNvbnN0IFtwcm9wc1RvLCBwcm9wc0Zyb21dID0gZ2V0VHJhbnNpdGlvblByb3BzKHRhcmdldCwgbm9kZXMsIGN1cnJlbnRQcm9wcyk7XG4gICAgICBjb25zdCBhdHRyc1RvID0gbm9kZXMubWFwKChlbCkgPT4gKHtcbiAgICAgICAgY2xhc3M6IGF0dHIoZWwsICdjbGFzcycpLFxuICAgICAgICBzdHlsZTogYXR0cihlbCwgJ3N0eWxlJykgfSkpO1xuXG5cbiAgICAgIC8vIFJlc2V0IHRvIHByZXZpb3VzIHN0YXRlXG4gICAgICBub2Rlcy5mb3JFYWNoKChlbCwgaSkgPT4gcHJvcHNGcm9tW2ldICYmIGNzcyhlbCwgcHJvcHNGcm9tW2ldKSk7XG4gICAgICBjc3ModGFyZ2V0LCB0YXJnZXRQcm9wcyk7XG5cbiAgICAgIC8vIFN0YXJ0IHRyYW5zaXRpb25zIG9uIG5leHQgZnJhbWVcbiAgICAgIGF3YWl0IGF3YWl0RnJhbWUoKTtcblxuICAgICAgY29uc3QgdHJhbnNpdGlvbnMgPSBub2Rlcy5cbiAgICAgIG1hcCgoZWwsIGkpID0+IHBhcmVudChlbCkgPT09IHRhcmdldCAmJiBUcmFuc2l0aW9uLnN0YXJ0KGVsLCBwcm9wc1RvW2ldLCBkdXJhdGlvbiwgJ2Vhc2UnKSkuXG4gICAgICBjb25jYXQoVHJhbnNpdGlvbi5zdGFydCh0YXJnZXQsIHRhcmdldFByb3BzVG8sIGR1cmF0aW9uLCAnZWFzZScpKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodHJhbnNpdGlvbnMpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKChlbCwgaSkgPT4ge1xuICAgICAgICAgIGF0dHIoZWwsIGF0dHJzVG9baV0pO1xuICAgICAgICAgIGlmIChwYXJlbnQoZWwpID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIGNzcyhlbCwgJ2Rpc3BsYXknLCBwcm9wc1RvW2ldLm9wYWNpdHkgPT09IDAgPyAnbm9uZScgOiAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXR0cih0YXJnZXQsICdzdHlsZScsIHRhcmdldFN0eWxlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXR0cihub2RlcywgJ3N0eWxlJywgJycpO1xuICAgICAgICByZXNldFByb3BzKHRhcmdldCwgdGFyZ2V0UHJvcHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByb3BzKGVsLCBvcGFjaXR5KSB7XG4gICAgICBjb25zdCB6SW5kZXggPSBjc3MoZWwsICd6SW5kZXgnKTtcblxuICAgICAgcmV0dXJuIGlzVmlzaWJsZShlbCkgP1xuICAgICAge1xuICAgICAgICBkaXNwbGF5OiAnJyxcbiAgICAgICAgb3BhY2l0eTogb3BhY2l0eSA/IGNzcyhlbCwgJ29wYWNpdHknKSA6ICcwJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgekluZGV4OiB6SW5kZXggPT09ICdhdXRvJyA/IGluZGV4KGVsKSA6IHpJbmRleCxcbiAgICAgICAgLi4uZ2V0UG9zaXRpb25XaXRoTWFyZ2luKGVsKSB9IDpcblxuICAgICAgZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblByb3BzKHRhcmdldCwgbm9kZXMsIGN1cnJlbnRQcm9wcykge1xuICAgICAgY29uc3QgcHJvcHNUbyA9IG5vZGVzLm1hcCgoZWwsIGkpID0+XG4gICAgICBwYXJlbnQoZWwpICYmIGkgaW4gY3VycmVudFByb3BzID9cbiAgICAgIGN1cnJlbnRQcm9wc1tpXSA/XG4gICAgICBpc1Zpc2libGUoZWwpID9cbiAgICAgIGdldFBvc2l0aW9uV2l0aE1hcmdpbihlbCkgOlxuICAgICAgeyBvcGFjaXR5OiAwIH0gOlxuICAgICAgeyBvcGFjaXR5OiBpc1Zpc2libGUoZWwpID8gMSA6IDAgfSA6XG4gICAgICBmYWxzZSk7XG5cblxuICAgICAgY29uc3QgcHJvcHNGcm9tID0gcHJvcHNUby5tYXAoKHByb3BzLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGZyb20gPSBwYXJlbnQobm9kZXNbaV0pID09PSB0YXJnZXQgJiYgKGN1cnJlbnRQcm9wc1tpXSB8fCBnZXRQcm9wcyhub2Rlc1tpXSkpO1xuXG4gICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICBkZWxldGUgZnJvbS5vcGFjaXR5O1xuICAgICAgICB9IGVsc2UgaWYgKCEoJ29wYWNpdHknIGluIHByb3BzKSkge1xuICAgICAgICAgIGNvbnN0IHsgb3BhY2l0eSB9ID0gZnJvbTtcblxuICAgICAgICAgIGlmIChvcGFjaXR5ICUgMSkge1xuICAgICAgICAgICAgcHJvcHMub3BhY2l0eSA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmcm9tLm9wYWNpdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZyb207XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFtwcm9wc1RvLCBwcm9wc0Zyb21dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0UHJvcHMoZWwsIHByb3BzKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgY3NzKGVsLCBwcm9wLCAnJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb25XaXRoTWFyZ2luKGVsKSB7XG4gICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IG9mZnNldChlbCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIHRyYW5zZm9ybTogJycsXG4gICAgICAgIC4uLnBvc2l0aW9uKGVsKSxcbiAgICAgICAgLi4uY3NzKGVsLCBbJ21hcmdpblRvcCcsICdtYXJnaW5MZWZ0J10pIH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhd2FpdEZyYW1lKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVzb2x2ZSkpO1xuICAgIH1cblxuICAgIHZhciBBbmltYXRlID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZHVyYXRpb246IE51bWJlcixcbiAgICAgICAgYW5pbWF0aW9uOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBkdXJhdGlvbjogMTUwLFxuICAgICAgICBhbmltYXRpb246ICdzbGlkZScgfSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFuaW1hdGUoYWN0aW9uLCB0YXJnZXQpIHtpZiAodGFyZ2V0ID09PSB2b2lkIDApIHt0YXJnZXQgPSB0aGlzLiRlbDt9XG4gICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbkZuID1cbiAgICAgICAgICBuYW1lID09PSAnZmFkZScgP1xuICAgICAgICAgIGZhZGUgOlxuICAgICAgICAgIG5hbWUgPT09ICdkZWxheWVkLWZhZGUnID9cbiAgICAgICAgICBmdW5jdGlvbiAoKSB7Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7YXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTt9cmV0dXJuIGZhZGUoLi4uYXJncywgNDApO30gOlxuICAgICAgICAgIG5hbWUgP1xuICAgICAgICAgIHNsaWRlIDpcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBhY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbkZuKGFjdGlvbiwgdGFyZ2V0LCB0aGlzLmR1cmF0aW9uKS5jYXRjaChub29wKTtcbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgZmlsdGVyID0ge1xuICAgICAgbWl4aW5zOiBbQW5pbWF0ZV0sXG5cbiAgICAgIGFyZ3M6ICd0YXJnZXQnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICB0YXJnZXQ6IEJvb2xlYW4sXG4gICAgICAgIHNlbEFjdGl2ZTogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICBzZWxBY3RpdmU6IGZhbHNlLFxuICAgICAgICBhdHRySXRlbTogJ3VrLWZpbHRlci1jb250cm9sJyxcbiAgICAgICAgY2xzOiAndWstYWN0aXZlJyxcbiAgICAgICAgZHVyYXRpb246IDI1MCB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHRvZ2dsZXM6IHtcbiAgICAgICAgICBnZXQoX3JlZiwgJGVsKSB7bGV0IHsgYXR0ckl0ZW0gfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4gJCQoXCJbXCIgKyBhdHRySXRlbSArIFwiXSxbZGF0YS1cIiArIGF0dHJJdGVtICsgXCJdXCIsICRlbCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxBY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZXMgPSAkJCh0aGlzLnNlbEFjdGl2ZSwgdGhpcy4kZWwpO1xuICAgICAgICAgICAgICB0aGlzLnRvZ2dsZXMuZm9yRWFjaCgoZWwpID0+IHRvZ2dsZUNsYXNzKGVsLCB0aGlzLmNscywgaW5jbHVkZXMoYWN0aXZlcywgZWwpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgICAgY2hpbGRyZW46IHtcbiAgICAgICAgICBnZXQoX3JlZjIsICRlbCkge2xldCB7IHRhcmdldCB9ID0gX3JlZjI7XG4gICAgICAgICAgICByZXR1cm4gJCQodGFyZ2V0ICsgXCIgPiAqXCIsICRlbCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGxpc3QsIG9sZCkge1xuICAgICAgICAgICAgaWYgKG9sZCAmJiAhaXNFcXVhbExpc3QobGlzdCwgb2xkKSkge1xuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9IH0sXG5cblxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gXCJbXCIgKyB0aGlzLmF0dHJJdGVtICsgXCJdLFtkYXRhLVwiICsgdGhpcy5hdHRySXRlbSArIFwiXVwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmFwcGx5KGUuY3VycmVudCk7XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFwcGx5KGVsKSB7XG4gICAgICAgICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gbWVyZ2VTdGF0ZShlbCwgdGhpcy5hdHRySXRlbSwgdGhpcy5nZXRTdGF0ZSgpKTtcblxuICAgICAgICAgIGlmICghaXNFcXVhbFN0YXRlKHByZXZTdGF0ZSwgbmV3U3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U3RhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlcy5cbiAgICAgICAgICBmaWx0ZXIoKGl0ZW0pID0+IGhhc0NsYXNzKGl0ZW0sIHRoaXMuY2xzKSkuXG4gICAgICAgICAgcmVkdWNlKChzdGF0ZSwgZWwpID0+IG1lcmdlU3RhdGUoZWwsIHRoaXMuYXR0ckl0ZW0sIHN0YXRlKSwge1xuICAgICAgICAgICAgZmlsdGVyOiB7ICcnOiAnJyB9LFxuICAgICAgICAgICAgc29ydDogW10gfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhc3luYyBzZXRTdGF0ZShzdGF0ZSwgYW5pbWF0ZSkge2lmIChhbmltYXRlID09PSB2b2lkIDApIHthbmltYXRlID0gdHJ1ZTt9XG4gICAgICAgICAgc3RhdGUgPSB7IGZpbHRlcjogeyAnJzogJycgfSwgc29ydDogW10sIC4uLnN0YXRlIH07XG5cbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnYmVmb3JlRmlsdGVyJywgW3RoaXMsIHN0YXRlXSk7XG5cbiAgICAgICAgICB0aGlzLnRvZ2dsZXMuZm9yRWFjaCgoZWwpID0+XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMuY2xzLCAhIW1hdGNoRmlsdGVyKGVsLCB0aGlzLmF0dHJJdGVtLCBzdGF0ZSkpKTtcblxuXG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgJCQodGhpcy50YXJnZXQsIHRoaXMuJGVsKS5tYXAoKHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGFwcGx5U3RhdGUoc3RhdGUsIHRhcmdldCwgY2hpbGRyZW4odGFyZ2V0KSk7XG4gICAgICAgICAgICAgIHRoaXMuJHVwZGF0ZSh0aGlzLiRlbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGUgPyB0aGlzLmFuaW1hdGUoZmlsdGVyRm4sIHRhcmdldCkgOiBmaWx0ZXJGbigpO1xuICAgICAgICAgIH0pKTtcblxuXG4gICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ2FmdGVyRmlsdGVyJywgW3RoaXNdKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgICBmYXN0ZG9tLndyaXRlKCgpID0+IHRoaXMuc2V0U3RhdGUodGhpcy5nZXRTdGF0ZSgpLCBmYWxzZSkpO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBnZXRGaWx0ZXIoZWwsIGF0dHIpIHtcbiAgICAgIHJldHVybiBwYXJzZU9wdGlvbnMoZGF0YShlbCwgYXR0ciksIFsnZmlsdGVyJ10pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRXF1YWxTdGF0ZShzdGF0ZUEsIHN0YXRlQikge1xuICAgICAgcmV0dXJuIFsnZmlsdGVyJywgJ3NvcnQnXS5ldmVyeSgocHJvcCkgPT4gaXNFcXVhbChzdGF0ZUFbcHJvcF0sIHN0YXRlQltwcm9wXSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5U3RhdGUoc3RhdGUsIHRhcmdldCwgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3Ioc3RhdGUpO1xuXG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKChlbCkgPT4gY3NzKGVsLCAnZGlzcGxheScsIHNlbGVjdG9yICYmICFtYXRjaGVzKGVsLCBzZWxlY3RvcikgPyAnbm9uZScgOiAnJykpO1xuXG4gICAgICBjb25zdCBbc29ydCwgb3JkZXJdID0gc3RhdGUuc29ydDtcblxuICAgICAgaWYgKHNvcnQpIHtcbiAgICAgICAgY29uc3Qgc29ydGVkID0gc29ydEl0ZW1zKGNoaWxkcmVuLCBzb3J0LCBvcmRlcik7XG4gICAgICAgIGlmICghaXNFcXVhbChzb3J0ZWQsIGNoaWxkcmVuKSkge1xuICAgICAgICAgIGFwcGVuZCh0YXJnZXQsIHNvcnRlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZVN0YXRlKGVsLCBhdHRyLCBzdGF0ZSkge1xuICAgICAgY29uc3QgeyBmaWx0ZXIsIGdyb3VwLCBzb3J0LCBvcmRlciA9ICdhc2MnIH0gPSBnZXRGaWx0ZXIoZWwsIGF0dHIpO1xuXG4gICAgICBpZiAoZmlsdGVyIHx8IGlzVW5kZWZpbmVkKHNvcnQpKSB7XG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5maWx0ZXJbJyddO1xuICAgICAgICAgICAgc3RhdGUuZmlsdGVyW2dyb3VwXSA9IGZpbHRlcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmZpbHRlcltncm91cF07XG5cbiAgICAgICAgICAgIGlmIChpc0VtcHR5KHN0YXRlLmZpbHRlcikgfHwgJycgaW4gc3RhdGUuZmlsdGVyKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmZpbHRlciA9IHsgJyc6IGZpbHRlciB8fCAnJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5maWx0ZXIgPSB7ICcnOiBmaWx0ZXIgfHwgJycgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKHNvcnQpKSB7XG4gICAgICAgIHN0YXRlLnNvcnQgPSBbc29ydCwgb3JkZXJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hGaWx0ZXIoXG4gICAgZWwsXG4gICAgYXR0ciwgX3JlZjMpXG5cbiAgICB7bGV0IHsgZmlsdGVyOiBzdGF0ZUZpbHRlciA9IHsgJyc6ICcnIH0sIHNvcnQ6IFtzdGF0ZVNvcnQsIHN0YXRlT3JkZXJdIH0gPSBfcmVmMztcbiAgICAgIGNvbnN0IHsgZmlsdGVyID0gJycsIGdyb3VwID0gJycsIHNvcnQsIG9yZGVyID0gJ2FzYycgfSA9IGdldEZpbHRlcihlbCwgYXR0cik7XG5cbiAgICAgIHJldHVybiBpc1VuZGVmaW5lZChzb3J0KSA/XG4gICAgICBncm91cCBpbiBzdGF0ZUZpbHRlciAmJiBmaWx0ZXIgPT09IHN0YXRlRmlsdGVyW2dyb3VwXSB8fFxuICAgICAgIWZpbHRlciAmJiBncm91cCAmJiAhKGdyb3VwIGluIHN0YXRlRmlsdGVyKSAmJiAhc3RhdGVGaWx0ZXJbJyddIDpcbiAgICAgIHN0YXRlU29ydCA9PT0gc29ydCAmJiBzdGF0ZU9yZGVyID09PSBvcmRlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0VxdWFsTGlzdChsaXN0QSwgbGlzdEIpIHtcbiAgICAgIHJldHVybiBsaXN0QS5sZW5ndGggPT09IGxpc3RCLmxlbmd0aCAmJiBsaXN0QS5ldmVyeSgoZWwpID0+IGxpc3RCLmluY2x1ZGVzKGVsKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2VsZWN0b3IoX3JlZjQpIHtsZXQgeyBmaWx0ZXIgfSA9IF9yZWY0O1xuICAgICAgbGV0IHNlbGVjdG9yID0gJyc7XG4gICAgICBlYWNoKGZpbHRlciwgKHZhbHVlKSA9PiBzZWxlY3RvciArPSB2YWx1ZSB8fCAnJyk7XG4gICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydEl0ZW1zKG5vZGVzLCBzb3J0LCBvcmRlcikge1xuICAgICAgcmV0dXJuIFsuLi5ub2Rlc10uc29ydChcbiAgICAgIChhLCBiKSA9PlxuICAgICAgZGF0YShhLCBzb3J0KS5sb2NhbGVDb21wYXJlKGRhdGEoYiwgc29ydCksIHVuZGVmaW5lZCwgeyBudW1lcmljOiB0cnVlIH0pICogKFxuICAgICAgb3JkZXIgPT09ICdhc2MnIHx8IC0xKSk7XG5cbiAgICB9XG5cbiAgICB2YXIgQW5pbWF0aW9ucyQyID0ge1xuICAgICAgc2xpZGU6IHtcbiAgICAgICAgc2hvdyhkaXIpIHtcbiAgICAgICAgICByZXR1cm4gW3sgdHJhbnNmb3JtOiB0cmFuc2xhdGUoZGlyICogLTEwMCkgfSwgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgpIH1dO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoY3VycmVudCkge1xuICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVkKGN1cnJlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50LCBkaXIpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoZGlyICogLTEwMCAqIHBlcmNlbnQpIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZShkaXIgKiAxMDAgKiAoMSAtIHBlcmNlbnQpKSB9XTtcblxuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVkKGVsKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoY3NzKGVsLCAndHJhbnNmb3JtJykuc3BsaXQoJywnKVs0XSAvIGVsLm9mZnNldFdpZHRoKSB8fCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZSh2YWx1ZSwgdW5pdCkge2lmICh2YWx1ZSA9PT0gdm9pZCAwKSB7dmFsdWUgPSAwO31pZiAodW5pdCA9PT0gdm9pZCAwKSB7dW5pdCA9ICclJzt9XG4gICAgICB2YWx1ZSArPSB2YWx1ZSA/IHVuaXQgOiAnJztcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZTNkKFwiICsgdmFsdWUgKyBcIiwgMCwgMClcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZTNkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJzY2FsZTNkKFwiICsgdmFsdWUgKyBcIiwgXCIgKyB2YWx1ZSArIFwiLCAxKVwiO1xuICAgIH1cblxuICAgIHZhciBBbmltYXRpb25zJDEgPSB7XG4gICAgICAuLi5BbmltYXRpb25zJDIsXG4gICAgICBmYWRlOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH1dO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoY3VycmVudCkge1xuICAgICAgICAgIHJldHVybiAxIC0gY3NzKGN1cnJlbnQsICdvcGFjaXR5Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQpIHtcbiAgICAgICAgICByZXR1cm4gW3sgb3BhY2l0eTogMSAtIHBlcmNlbnQgfSwgeyBvcGFjaXR5OiBwZXJjZW50IH1dO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgc2NhbGU6IHtcbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHsgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiBzY2FsZTNkKDEgLSAwLjIpIH0sXG4gICAgICAgICAgeyBvcGFjaXR5OiAxLCB0cmFuc2Zvcm06IHNjYWxlM2QoMSkgfV07XG5cbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gMSAtIGNzcyhjdXJyZW50LCAnb3BhY2l0eScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7IG9wYWNpdHk6IDEgLSBwZXJjZW50LCB0cmFuc2Zvcm06IHNjYWxlM2QoMSAtIDAuMiAqIHBlcmNlbnQpIH0sXG4gICAgICAgICAgeyBvcGFjaXR5OiBwZXJjZW50LCB0cmFuc2Zvcm06IHNjYWxlM2QoMSAtIDAuMiArIDAuMiAqIHBlcmNlbnQpIH1dO1xuXG4gICAgICAgIH0gfSB9O1xuXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbmVyJDEocHJldiwgbmV4dCwgZGlyLCBfcmVmKSB7bGV0IHsgYW5pbWF0aW9uLCBlYXNpbmcgfSA9IF9yZWY7XG4gICAgICBjb25zdCB7IHBlcmNlbnQsIHRyYW5zbGF0ZSwgc2hvdyA9IG5vb3AgfSA9IGFuaW1hdGlvbjtcbiAgICAgIGNvbnN0IHByb3BzID0gc2hvdyhkaXIpO1xuICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlyLFxuXG4gICAgICAgIHNob3coZHVyYXRpb24sIHBlcmNlbnQsIGxpbmVhcikge2lmIChwZXJjZW50ID09PSB2b2lkIDApIHtwZXJjZW50ID0gMDt9XG4gICAgICAgICAgY29uc3QgdGltaW5nID0gbGluZWFyID8gJ2xpbmVhcicgOiBlYXNpbmc7XG4gICAgICAgICAgZHVyYXRpb24gLT0gTWF0aC5yb3VuZChkdXJhdGlvbiAqIGNsYW1wKHBlcmNlbnQsIC0xLCAxKSk7XG5cbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZShwZXJjZW50KTtcblxuICAgICAgICAgIHRyaWdnZXJVcGRhdGUkMShuZXh0LCAnaXRlbWluJywgeyBwZXJjZW50LCBkdXJhdGlvbiwgdGltaW5nLCBkaXIgfSk7XG4gICAgICAgICAgdHJpZ2dlclVwZGF0ZSQxKHByZXYsICdpdGVtb3V0JywgeyBwZXJjZW50OiAxIC0gcGVyY2VudCwgZHVyYXRpb24sIHRpbWluZywgZGlyIH0pO1xuXG4gICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQobmV4dCwgcHJvcHNbMV0sIGR1cmF0aW9uLCB0aW1pbmcpLFxuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQocHJldiwgcHJvcHNbMF0sIGR1cmF0aW9uLCB0aW1pbmcpXSkuXG4gICAgICAgICAgdGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgfSwgbm9vcCk7XG5cbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwoW25leHQsIHByZXZdKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHNbMF0pIHtcbiAgICAgICAgICAgIGNzcyhbbmV4dCwgcHJldl0sIHByb3AsICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9yd2FyZChkdXJhdGlvbiwgcGVyY2VudCkge2lmIChwZXJjZW50ID09PSB2b2lkIDApIHtwZXJjZW50ID0gdGhpcy5wZXJjZW50KCk7fVxuICAgICAgICAgIFRyYW5zaXRpb24uY2FuY2VsKFtuZXh0LCBwcmV2XSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2hvdyhkdXJhdGlvbiwgcGVyY2VudCwgdHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgICBjb25zdCBwcm9wcyA9IHRyYW5zbGF0ZShwZXJjZW50LCBkaXIpO1xuICAgICAgICAgIGNzcyhuZXh0LCBwcm9wc1sxXSk7XG4gICAgICAgICAgY3NzKHByZXYsIHByb3BzWzBdKTtcbiAgICAgICAgICB0cmlnZ2VyVXBkYXRlJDEobmV4dCwgJ2l0ZW10cmFuc2xhdGVpbicsIHsgcGVyY2VudCwgZGlyIH0pO1xuICAgICAgICAgIHRyaWdnZXJVcGRhdGUkMShwcmV2LCAnaXRlbXRyYW5zbGF0ZW91dCcsIHsgcGVyY2VudDogMSAtIHBlcmNlbnQsIGRpciB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KCkge1xuICAgICAgICAgIHJldHVybiBwZXJjZW50KHByZXYgfHwgbmV4dCwgbmV4dCwgZGlyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXREaXN0YW5jZSgpIHtcbiAgICAgICAgICByZXR1cm4gcHJldiA9PSBudWxsID8gdm9pZCAwIDogcHJldi5vZmZzZXRXaWR0aDtcbiAgICAgICAgfSB9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlclVwZGF0ZSQxKGVsLCB0eXBlLCBkYXRhKSB7XG4gICAgICB0cmlnZ2VyKGVsLCBjcmVhdGVFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UsIGRhdGEpKTtcbiAgICB9XG5cbiAgICB2YXIgU2xpZGVyQXV0b3BsYXkgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBhdXRvcGxheTogQm9vbGVhbixcbiAgICAgICAgYXV0b3BsYXlJbnRlcnZhbDogTnVtYmVyLFxuICAgICAgICBwYXVzZU9uSG92ZXI6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgICAgYXV0b3BsYXlJbnRlcnZhbDogNzAwMCxcbiAgICAgICAgcGF1c2VPbkhvdmVyOiB0cnVlIH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmF1dG9wbGF5ICYmIHRoaXMuc3RhcnRBdXRvcGxheSgpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnN0b3BBdXRvcGxheSgpO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlKCkge1xuICAgICAgICBhdHRyKHRoaXMuc2xpZGVzLCAndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAndmlzaWJpbGl0eWNoYW5nZScsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdXRvcGxheTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcEF1dG9wbGF5KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRBdXRvcGxheSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgc3RhcnRBdXRvcGxheSgpIHtcbiAgICAgICAgICB0aGlzLnN0b3BBdXRvcGxheSgpO1xuXG4gICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgICAgICgpID0+XG4gICAgICAgICAgKCF0aGlzLmRyYWdnYWJsZSB8fCAhJCgnOmZvY3VzJywgdGhpcy4kZWwpKSAmJiAoXG4gICAgICAgICAgIXRoaXMucGF1c2VPbkhvdmVyIHx8ICFtYXRjaGVzKHRoaXMuJGVsLCAnOmhvdmVyJykpICYmXG4gICAgICAgICAgIXRoaXMuc3RhY2subGVuZ3RoICYmXG4gICAgICAgICAgdGhpcy5zaG93KCduZXh0JyksXG4gICAgICAgICAgdGhpcy5hdXRvcGxheUludGVydmFsKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHN0b3BBdXRvcGxheSgpIHtcbiAgICAgICAgICB0aGlzLmludGVydmFsICYmIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgIH0gfSB9O1xuXG4gICAgY29uc3QgcG9pbnRlck9wdGlvbnMgPSB7IHBhc3NpdmU6IGZhbHNlLCBjYXB0dXJlOiB0cnVlIH07XG4gICAgY29uc3QgcG9pbnRlclVwT3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9O1xuICAgIGNvbnN0IHBvaW50ZXJEb3duID0gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJztcbiAgICBjb25zdCBwb2ludGVyTW92ZSA9ICd0b3VjaG1vdmUgbW91c2Vtb3ZlJztcbiAgICBjb25zdCBwb2ludGVyVXAgPSAndG91Y2hlbmQgdG91Y2hjYW5jZWwgbW91c2V1cCBjbGljayBpbnB1dCBzY3JvbGwnO1xuXG4gICAgdmFyIFNsaWRlckRyYWcgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBkcmFnZ2FibGU6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgdGhyZXNob2xkOiAxMCB9LFxuXG5cbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsnc3RhcnQnLCAnbW92ZScsICdlbmQnXSkge1xuICAgICAgICAgIGNvbnN0IGZuID0gdGhpc1trZXldO1xuICAgICAgICAgIHRoaXNba2V5XSA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBnZXRFdmVudFBvcyhlKS54ICogKGlzUnRsID8gLTEgOiAxKTtcblxuICAgICAgICAgICAgdGhpcy5wcmV2UG9zID0gcG9zID09PSB0aGlzLnBvcyA/IHRoaXMucHJldlBvcyA6IHRoaXMucG9zO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG5cbiAgICAgICAgICAgIGZuKGUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBwb2ludGVyRG93bixcblxuICAgICAgICBwYXNzaXZlOiB0cnVlLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlbFNsaWRlcztcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIXRoaXMuZHJhZ2dhYmxlIHx8XG4gICAgICAgICAgIWlzVG91Y2goZSkgJiYgaGFzU2VsZWN0YWJsZVRleHQoZS50YXJnZXQpIHx8XG4gICAgICAgICAgY2xvc2VzdChlLnRhcmdldCwgc2VsSW5wdXQpIHx8XG4gICAgICAgICAgZS5idXR0b24gPiAwIHx8XG4gICAgICAgICAgdGhpcy5sZW5ndGggPCAyKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0YXJ0KGUpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnZHJhZ3N0YXJ0JyxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIC8vIGlPUyB3b3JrYXJvdW5kIGZvciBzbGlkZXIgc3RvcHBpbmcgaWYgc3dpcGluZyBmYXN0XG4gICAgICAgIG5hbWU6IHBvaW50ZXJNb3ZlLFxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5saXN0O1xuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVyOiBub29wLFxuICAgICAgICAuLi5wb2ludGVyT3B0aW9ucyB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgc3RhcnQoKSB7XG4gICAgICAgICAgdGhpcy5kcmFnID0gdGhpcy5wb3M7XG5cbiAgICAgICAgICBpZiAodGhpcy5fdHJhbnNpdGlvbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmNlbnQgPSB0aGlzLl90cmFuc2l0aW9uZXIucGVyY2VudCgpO1xuICAgICAgICAgICAgdGhpcy5kcmFnICs9IHRoaXMuX3RyYW5zaXRpb25lci5nZXREaXN0YW5jZSgpICogdGhpcy5wZXJjZW50ICogdGhpcy5kaXI7XG5cbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25lci5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25lci50cmFuc2xhdGUodGhpcy5wZXJjZW50KTtcblxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcmV2SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9uKGRvY3VtZW50LCBwb2ludGVyTW92ZSwgdGhpcy5tb3ZlLCBwb2ludGVyT3B0aW9ucyk7XG5cbiAgICAgICAgICAvLyAnaW5wdXQnIGV2ZW50IGlzIHRyaWdnZXJlZCBieSB2aWRlbyBjb250cm9sc1xuICAgICAgICAgIG9uKGRvY3VtZW50LCBwb2ludGVyVXAsIHRoaXMuZW5kLCBwb2ludGVyVXBPcHRpb25zKTtcblxuICAgICAgICAgIGNzcyh0aGlzLmxpc3QsICd1c2VyU2VsZWN0JywgJ25vbmUnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlKGUpIHtcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMucG9zIC0gdGhpcy5kcmFnO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIGRpc3RhbmNlID09PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmV2UG9zID09PSB0aGlzLnBvcyB8fFxuICAgICAgICAgICF0aGlzLmRyYWdnaW5nICYmIE1hdGguYWJzKGRpc3RhbmNlKSA8IHRoaXMudGhyZXNob2xkKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwcmV2ZW50IGNsaWNrIGV2ZW50XG4gICAgICAgICAgY3NzKHRoaXMubGlzdCwgJ3BvaW50ZXJFdmVudHMnLCAnbm9uZScpO1xuXG4gICAgICAgICAgZS5jYW5jZWxhYmxlICYmIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZGlyID0gZGlzdGFuY2UgPCAwID8gMSA6IC0xO1xuXG4gICAgICAgICAgY29uc3QgeyBzbGlkZXMgfSA9IHRoaXM7XG4gICAgICAgICAgbGV0IHsgcHJldkluZGV4IH0gPSB0aGlzO1xuICAgICAgICAgIGxldCBkaXMgPSBNYXRoLmFicyhkaXN0YW5jZSk7XG4gICAgICAgICAgbGV0IG5leHRJbmRleCA9IHRoaXMuZ2V0SW5kZXgocHJldkluZGV4ICsgdGhpcy5kaXIsIHByZXZJbmRleCk7XG4gICAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5fZ2V0RGlzdGFuY2UocHJldkluZGV4LCBuZXh0SW5kZXgpIHx8IHNsaWRlc1twcmV2SW5kZXhdLm9mZnNldFdpZHRoO1xuXG4gICAgICAgICAgd2hpbGUgKG5leHRJbmRleCAhPT0gcHJldkluZGV4ICYmIGRpcyA+IHdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWcgLT0gd2lkdGggKiB0aGlzLmRpcjtcblxuICAgICAgICAgICAgcHJldkluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICAgICAgZGlzIC09IHdpZHRoO1xuICAgICAgICAgICAgbmV4dEluZGV4ID0gdGhpcy5nZXRJbmRleChwcmV2SW5kZXggKyB0aGlzLmRpciwgcHJldkluZGV4KTtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5fZ2V0RGlzdGFuY2UocHJldkluZGV4LCBuZXh0SW5kZXgpIHx8IHNsaWRlc1twcmV2SW5kZXhdLm9mZnNldFdpZHRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucGVyY2VudCA9IGRpcyAvIHdpZHRoO1xuXG4gICAgICAgICAgY29uc3QgcHJldiA9IHNsaWRlc1twcmV2SW5kZXhdO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBzbGlkZXNbbmV4dEluZGV4XTtcbiAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5pbmRleCAhPT0gbmV4dEluZGV4O1xuICAgICAgICAgIGNvbnN0IGVkZ2UgPSBwcmV2SW5kZXggPT09IG5leHRJbmRleDtcblxuICAgICAgICAgIGxldCBpdGVtU2hvd247XG5cbiAgICAgICAgICBbdGhpcy5pbmRleCwgdGhpcy5wcmV2SW5kZXhdLlxuICAgICAgICAgIGZpbHRlcigoaSkgPT4gIWluY2x1ZGVzKFtuZXh0SW5kZXgsIHByZXZJbmRleF0sIGkpKS5cbiAgICAgICAgICBmb3JFYWNoKChpKSA9PiB7XG4gICAgICAgICAgICB0cmlnZ2VyKHNsaWRlc1tpXSwgJ2l0ZW1oaWRkZW4nLCBbdGhpc10pO1xuXG4gICAgICAgICAgICBpZiAoZWRnZSkge1xuICAgICAgICAgICAgICBpdGVtU2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLnByZXZJbmRleCA9IHByZXZJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0aGlzLmluZGV4ID09PSBwcmV2SW5kZXggJiYgdGhpcy5wcmV2SW5kZXggIT09IHByZXZJbmRleCB8fCBpdGVtU2hvd24pIHtcbiAgICAgICAgICAgIHRyaWdnZXIoc2xpZGVzW3RoaXMuaW5kZXhdLCAnaXRlbXNob3duJywgW3RoaXNdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gbmV4dEluZGV4O1xuXG4gICAgICAgICAgICAhZWRnZSAmJiB0cmlnZ2VyKHByZXYsICdiZWZvcmVpdGVtaGlkZScsIFt0aGlzXSk7XG4gICAgICAgICAgICB0cmlnZ2VyKG5leHQsICdiZWZvcmVpdGVtc2hvdycsIFt0aGlzXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmVyID0gdGhpcy5fdHJhbnNsYXRlKE1hdGguYWJzKHRoaXMucGVyY2VudCksIHByZXYsICFlZGdlICYmIG5leHQpO1xuXG4gICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICFlZGdlICYmIHRyaWdnZXIocHJldiwgJ2l0ZW1oaWRlJywgW3RoaXNdKTtcbiAgICAgICAgICAgIHRyaWdnZXIobmV4dCwgJ2l0ZW1zaG93JywgW3RoaXNdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgcG9pbnRlck1vdmUsIHRoaXMubW92ZSwgcG9pbnRlck9wdGlvbnMpO1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgcG9pbnRlclVwLCB0aGlzLmVuZCwgcG9pbnRlclVwT3B0aW9ucyk7XG5cbiAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID09PSB0aGlzLnByZXZJbmRleCkge1xuICAgICAgICAgICAgICB0aGlzLnBlcmNlbnQgPSAxIC0gdGhpcy5wZXJjZW50O1xuICAgICAgICAgICAgICB0aGlzLmRpciAqPSAtMTtcbiAgICAgICAgICAgICAgdGhpcy5fc2hvdyhmYWxzZSwgdGhpcy5pbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25lciA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBkaXJDaGFuZ2UgPVxuICAgICAgICAgICAgICAoaXNSdGwgPyB0aGlzLmRpciAqIChpc1J0bCA/IDEgOiAtMSkgOiB0aGlzLmRpcikgPCAwID09PVxuICAgICAgICAgICAgICB0aGlzLnByZXZQb3MgPiB0aGlzLnBvcztcbiAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGRpckNoYW5nZSA/IHRoaXMuaW5kZXggOiB0aGlzLnByZXZJbmRleDtcblxuICAgICAgICAgICAgICBpZiAoZGlyQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJjZW50ID0gMSAtIHRoaXMucGVyY2VudDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc2hvdyhcbiAgICAgICAgICAgICAgdGhpcy5kaXIgPiAwICYmICFkaXJDaGFuZ2UgfHwgdGhpcy5kaXIgPCAwICYmIGRpckNoYW5nZSA/XG4gICAgICAgICAgICAgICduZXh0JyA6XG4gICAgICAgICAgICAgICdwcmV2aW91cycsXG4gICAgICAgICAgICAgIHRydWUpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3NzKHRoaXMubGlzdCwgeyB1c2VyU2VsZWN0OiAnJywgcG9pbnRlckV2ZW50czogJycgfSk7XG5cbiAgICAgICAgICB0aGlzLmRyYWcgPSB0aGlzLnBlcmNlbnQgPSBudWxsO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBoYXNTZWxlY3RhYmxlVGV4dChlbCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY3NzKGVsLCAndXNlclNlbGVjdCcpICE9PSAnbm9uZScgJiZcbiAgICAgICAgdG9Ob2RlcyhlbC5jaGlsZE5vZGVzKS5zb21lKChlbCkgPT4gZWwubm9kZVR5cGUgPT09IDMgJiYgZWwudGV4dENvbnRlbnQudHJpbSgpKSk7XG5cbiAgICB9XG5cbiAgICB2YXIgU2xpZGVyTmF2ID0ge1xuICAgICAgZGF0YToge1xuICAgICAgICBzZWxOYXY6IGZhbHNlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgbmF2KF9yZWYsICRlbCkge2xldCB7IHNlbE5hdiB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gJChzZWxOYXYsICRlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VsTmF2SXRlbShfcmVmMikge2xldCB7IGF0dHJJdGVtIH0gPSBfcmVmMjtcbiAgICAgICAgICByZXR1cm4gXCJbXCIgKyBhdHRySXRlbSArIFwiXSxbZGF0YS1cIiArIGF0dHJJdGVtICsgXCJdXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmF2SXRlbXMoXywgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuICQkKHRoaXMuc2VsTmF2SXRlbSwgJGVsKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICB3cml0ZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5uYXYgJiYgdGhpcy5sZW5ndGggIT09IHRoaXMubmF2LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgaHRtbChcbiAgICAgICAgICAgIHRoaXMubmF2LFxuICAgICAgICAgICAgdGhpcy5zbGlkZXMuXG4gICAgICAgICAgICBtYXAoKF8sIGkpID0+IFwiPGxpIFwiICsgdGhpcy5hdHRySXRlbSArIFwiPVxcXCJcIiArIGkgKyBcIlxcXCI+PGEgaHJlZj48L2E+PC9saT5cIikuXG4gICAgICAgICAgICBqb2luKCcnKSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm5hdkl0ZW1zLmNvbmNhdCh0aGlzLm5hdikuZm9yRWFjaCgoZWwpID0+IGVsICYmIChlbC5oaWRkZW4gPSAhdGhpcy5tYXhJbmRleCkpO1xuXG4gICAgICAgICAgdGhpcy51cGRhdGVOYXYoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSxcblxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWxOYXZJdGVtO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNob3coZGF0YShlLmN1cnJlbnQsIHRoaXMuYXR0ckl0ZW0pKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2l0ZW1zaG93JyxcbiAgICAgICAgaGFuZGxlcjogJ3VwZGF0ZU5hdicgfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHVwZGF0ZU5hdigpIHtcbiAgICAgICAgICBjb25zdCBpID0gdGhpcy5nZXRWYWxpZEluZGV4KCk7XG4gICAgICAgICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLm5hdkl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBjbWQgPSBkYXRhKGVsLCB0aGlzLmF0dHJJdGVtKTtcblxuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMuY2xzQWN0aXZlLCB0b051bWJlcihjbWQpID09PSBpKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAndWstaW52aXNpYmxlJyxcbiAgICAgICAgICAgIHRoaXMuZmluaXRlICYmIChcbiAgICAgICAgICAgIGNtZCA9PT0gJ3ByZXZpb3VzJyAmJiBpID09PSAwIHx8IGNtZCA9PT0gJ25leHQnICYmIGkgPj0gdGhpcy5tYXhJbmRleCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICB9IH0gfTtcblxuICAgIHZhciBTbGlkZXIgPSB7XG4gICAgICBtaXhpbnM6IFtTbGlkZXJBdXRvcGxheSwgU2xpZGVyRHJhZywgU2xpZGVyTmF2LCBSZXNpemVdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBjbHNBY3RpdmF0ZWQ6IEJvb2xlYW4sXG4gICAgICAgIGVhc2luZzogU3RyaW5nLFxuICAgICAgICBpbmRleDogTnVtYmVyLFxuICAgICAgICBmaW5pdGU6IEJvb2xlYW4sXG4gICAgICAgIHZlbG9jaXR5OiBOdW1iZXIsXG4gICAgICAgIHNlbFNsaWRlczogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YTogKCkgPT4gKHtcbiAgICAgICAgZWFzaW5nOiAnZWFzZScsXG4gICAgICAgIGZpbml0ZTogZmFsc2UsXG4gICAgICAgIHZlbG9jaXR5OiAxLFxuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgcHJldkluZGV4OiAtMSxcbiAgICAgICAgc3RhY2s6IFtdLFxuICAgICAgICBwZXJjZW50OiAwLFxuICAgICAgICBjbHNBY3RpdmU6ICd1ay1hY3RpdmUnLFxuICAgICAgICBjbHNBY3RpdmF0ZWQ6IGZhbHNlLFxuICAgICAgICBUcmFuc2l0aW9uZXI6IGZhbHNlLFxuICAgICAgICB0cmFuc2l0aW9uT3B0aW9uczoge30gfSksXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnByZXZJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5nZXRWYWxpZEluZGV4KHRoaXMuJHByb3BzLmluZGV4KTtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICByZW1vdmVDbGFzcyh0aGlzLnNsaWRlcywgdGhpcy5jbHNBY3RpdmUpO1xuICAgICAgfSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgZHVyYXRpb24oX3JlZiwgJGVsKSB7bGV0IHsgdmVsb2NpdHkgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIHNwZWVkVXAoJGVsLm9mZnNldFdpZHRoIC8gdmVsb2NpdHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGxpc3QoX3JlZjIsICRlbCkge2xldCB7IHNlbExpc3QgfSA9IF9yZWYyO1xuICAgICAgICAgIHJldHVybiAkKHNlbExpc3QsICRlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4SW5kZXgoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZWxTbGlkZXMoX3JlZjMpIHtsZXQgeyBzZWxMaXN0LCBzZWxTbGlkZXMgfSA9IF9yZWYzO1xuICAgICAgICAgIHJldHVybiBzZWxMaXN0ICsgXCIgXCIgKyAoc2VsU2xpZGVzIHx8ICc+IConKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzbGlkZXM6IHtcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQodGhpcy5zZWxTbGlkZXMsIHRoaXMuJGVsKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdyZXNpemUnKTtcbiAgICAgICAgICB9IH0sXG5cblxuICAgICAgICBsZW5ndGgoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2xpZGVzLmxlbmd0aDtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgc2hvdyhpbmRleCwgZm9yY2UpIHtpZiAoZm9yY2UgPT09IHZvaWQgMCkge2ZvcmNlID0gZmFsc2U7fVxuICAgICAgICAgIGlmICh0aGlzLmRyYWdnaW5nIHx8ICF0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHsgc3RhY2sgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgcXVldWVJbmRleCA9IGZvcmNlID8gMCA6IHN0YWNrLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgICAgIHN0YWNrLnNwbGljZShxdWV1ZUluZGV4LCAxKTtcblxuICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aGlzLnNob3coc3RhY2suc2hpZnQoKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHN0YWNrW2ZvcmNlID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXShpbmRleCk7XG5cbiAgICAgICAgICBpZiAoIWZvcmNlICYmIHN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmVyLmZvcndhcmQoTWF0aC5taW4odGhpcy5kdXJhdGlvbiwgMjAwKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwcmV2SW5kZXggPSB0aGlzLmdldEluZGV4KHRoaXMuaW5kZXgpO1xuICAgICAgICAgIGNvbnN0IHByZXYgPSBoYXNDbGFzcyh0aGlzLnNsaWRlcywgdGhpcy5jbHNBY3RpdmUpICYmIHRoaXMuc2xpZGVzW3ByZXZJbmRleF07XG4gICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdGhpcy5nZXRJbmRleChpbmRleCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuc2xpZGVzW25leHRJbmRleF07XG5cbiAgICAgICAgICBpZiAocHJldiA9PT0gbmV4dCkge1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmRpciA9IGdldERpcmVjdGlvbihpbmRleCwgcHJldkluZGV4KTtcbiAgICAgICAgICB0aGlzLnByZXZJbmRleCA9IHByZXZJbmRleDtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gbmV4dEluZGV4O1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIHByZXYgJiYgIXRyaWdnZXIocHJldiwgJ2JlZm9yZWl0ZW1oaWRlJywgW3RoaXNdKSB8fFxuICAgICAgICAgICF0cmlnZ2VyKG5leHQsICdiZWZvcmVpdGVtc2hvdycsIFt0aGlzLCBwcmV2XSkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMucHJldkluZGV4O1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5fc2hvdyhwcmV2LCBuZXh0LCBmb3JjZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBwcmV2ICYmIHRyaWdnZXIocHJldiwgJ2l0ZW1oaWRkZW4nLCBbdGhpc10pO1xuICAgICAgICAgICAgdHJpZ2dlcihuZXh0LCAnaXRlbXNob3duJywgW3RoaXNdKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnNob3coc3RhY2suc2hpZnQoKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHByZXYgJiYgdHJpZ2dlcihwcmV2LCAnaXRlbWhpZGUnLCBbdGhpc10pO1xuICAgICAgICAgIHRyaWdnZXIobmV4dCwgJ2l0ZW1zaG93JywgW3RoaXNdKTtcblxuICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEluZGV4KGluZGV4LCBwcmV2KSB7aWYgKGluZGV4ID09PSB2b2lkIDApIHtpbmRleCA9IHRoaXMuaW5kZXg7fWlmIChwcmV2ID09PSB2b2lkIDApIHtwcmV2ID0gdGhpcy5pbmRleDt9XG4gICAgICAgICAgcmV0dXJuIGNsYW1wKGdldEluZGV4KGluZGV4LCB0aGlzLnNsaWRlcywgcHJldiwgdGhpcy5maW5pdGUpLCAwLCB0aGlzLm1heEluZGV4KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRWYWxpZEluZGV4KGluZGV4LCBwcmV2SW5kZXgpIHtpZiAoaW5kZXggPT09IHZvaWQgMCkge2luZGV4ID0gdGhpcy5pbmRleDt9aWYgKHByZXZJbmRleCA9PT0gdm9pZCAwKSB7cHJldkluZGV4ID0gdGhpcy5wcmV2SW5kZXg7fVxuICAgICAgICAgIHJldHVybiB0aGlzLmdldEluZGV4KGluZGV4LCBwcmV2SW5kZXgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zaG93KHByZXYsIG5leHQsIGZvcmNlKSB7XG4gICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmVyID0gdGhpcy5fZ2V0VHJhbnNpdGlvbmVyKHByZXYsIG5leHQsIHRoaXMuZGlyLCB7XG4gICAgICAgICAgICBlYXNpbmc6IGZvcmNlID9cbiAgICAgICAgICAgIG5leHQub2Zmc2V0V2lkdGggPCA2MDAgP1xuICAgICAgICAgICAgJ2N1YmljLWJlemllcigwLjI1LCAwLjQ2LCAwLjQ1LCAwLjk0KScgLyogZWFzZU91dFF1YWQgKi8gOlxuICAgICAgICAgICAgJ2N1YmljLWJlemllcigwLjE2NSwgMC44NCwgMC40NCwgMSknIC8qIGVhc2VPdXRRdWFydCAqLyA6XG4gICAgICAgICAgICB0aGlzLmVhc2luZyxcbiAgICAgICAgICAgIC4uLnRoaXMudHJhbnNpdGlvbk9wdGlvbnMgfSk7XG5cblxuICAgICAgICAgIGlmICghZm9yY2UgJiYgIXByZXYpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZSgxKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gdGhpcy5zdGFjaztcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbmVyW2xlbmd0aCA+IDEgPyAnZm9yd2FyZCcgOiAnc2hvdyddKFxuICAgICAgICAgIGxlbmd0aCA+IDEgPyBNYXRoLm1pbih0aGlzLmR1cmF0aW9uLCA3NSArIDc1IC8gKGxlbmd0aCAtIDEpKSA6IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGhpcy5wZXJjZW50KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXREaXN0YW5jZShwcmV2LCBuZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zaXRpb25lcihwcmV2LCBwcmV2ICE9PSBuZXh0ICYmIG5leHQpLmdldERpc3RhbmNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3RyYW5zbGF0ZShwZXJjZW50LCBwcmV2LCBuZXh0KSB7aWYgKHByZXYgPT09IHZvaWQgMCkge3ByZXYgPSB0aGlzLnByZXZJbmRleDt9aWYgKG5leHQgPT09IHZvaWQgMCkge25leHQgPSB0aGlzLmluZGV4O31cbiAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uZXIgPSB0aGlzLl9nZXRUcmFuc2l0aW9uZXIocHJldiAhPT0gbmV4dCA/IHByZXYgOiBmYWxzZSwgbmV4dCk7XG4gICAgICAgICAgdHJhbnNpdGlvbmVyLnRyYW5zbGF0ZShwZXJjZW50KTtcbiAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRUcmFuc2l0aW9uZXIoXG4gICAgICAgIHByZXYsXG4gICAgICAgIG5leHQsXG4gICAgICAgIGRpcixcbiAgICAgICAgb3B0aW9ucylcbiAgICAgICAge2lmIChwcmV2ID09PSB2b2lkIDApIHtwcmV2ID0gdGhpcy5wcmV2SW5kZXg7fWlmIChuZXh0ID09PSB2b2lkIDApIHtuZXh0ID0gdGhpcy5pbmRleDt9aWYgKGRpciA9PT0gdm9pZCAwKSB7ZGlyID0gdGhpcy5kaXIgfHwgMTt9aWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge29wdGlvbnMgPSB0aGlzLnRyYW5zaXRpb25PcHRpb25zO31cbiAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuVHJhbnNpdGlvbmVyKFxuICAgICAgICAgIGlzTnVtYmVyKHByZXYpID8gdGhpcy5zbGlkZXNbcHJldl0gOiBwcmV2LFxuICAgICAgICAgIGlzTnVtYmVyKG5leHQpID8gdGhpcy5zbGlkZXNbbmV4dF0gOiBuZXh0LFxuICAgICAgICAgIGRpciAqIChpc1J0bCA/IC0xIDogMSksXG4gICAgICAgICAgb3B0aW9ucyk7XG5cbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKGluZGV4LCBwcmV2SW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleCA9PT0gJ25leHQnID8gMSA6IGluZGV4ID09PSAncHJldmlvdXMnID8gLTEgOiBpbmRleCA8IHByZXZJbmRleCA/IC0xIDogMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGVlZFVwKHgpIHtcbiAgICAgIHJldHVybiAwLjUgKiB4ICsgMzAwOyAvLyBwYXJhYm9sYSB0aHJvdWdoICg0MDAsNTAwOyA2MDAsNjAwOyAxODAwLDEyMDApXG4gICAgfVxuXG4gICAgdmFyIFNsaWRlc2hvdyA9IHtcbiAgICAgIG1peGluczogW1NsaWRlcl0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGFuaW1hdGlvbjogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBhbmltYXRpb246ICdzbGlkZScsXG4gICAgICAgIGNsc0FjdGl2YXRlZDogJ3VrLXRyYW5zaXRpb24tYWN0aXZlJyxcbiAgICAgICAgQW5pbWF0aW9uczogQW5pbWF0aW9ucyQyLFxuICAgICAgICBUcmFuc2l0aW9uZXI6IFRyYW5zaXRpb25lciQxIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgYW5pbWF0aW9uKF9yZWYpIHtsZXQgeyBhbmltYXRpb24sIEFuaW1hdGlvbnMgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIHsgLi4uKEFuaW1hdGlvbnNbYW5pbWF0aW9uXSB8fCBBbmltYXRpb25zLnNsaWRlKSwgbmFtZTogYW5pbWF0aW9uIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNpdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgYW5pbWF0aW9uOiB0aGlzLmFuaW1hdGlvbiB9O1xuICAgICAgICB9IH0sXG5cblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGJlZm9yZWl0ZW1zaG93KF9yZWYyKSB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmMjtcbiAgICAgICAgICBhZGRDbGFzcyh0YXJnZXQsIHRoaXMuY2xzQWN0aXZlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpdGVtc2hvd24oX3JlZjMpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWYzO1xuICAgICAgICAgIGFkZENsYXNzKHRhcmdldCwgdGhpcy5jbHNBY3RpdmF0ZWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGl0ZW1oaWRkZW4oX3JlZjQpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWY0O1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRhcmdldCwgdGhpcy5jbHNBY3RpdmUsIHRoaXMuY2xzQWN0aXZhdGVkKTtcbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgTGlnaHRib3hQYW5lbCA9IHtcbiAgICAgIG1peGluczogW0NvbnRhaW5lciwgTW9kYWwsIFRvZ2dsYWJsZSwgU2xpZGVzaG93XSxcblxuICAgICAgZnVuY3Rpb25hbDogdHJ1ZSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZGVsYXlDb250cm9sczogTnVtYmVyLFxuICAgICAgICBwcmVsb2FkOiBOdW1iZXIsXG4gICAgICAgIHZpZGVvQXV0b3BsYXk6IEJvb2xlYW4sXG4gICAgICAgIHRlbXBsYXRlOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiAoKSA9PiAoe1xuICAgICAgICBwcmVsb2FkOiAxLFxuICAgICAgICB2aWRlb0F1dG9wbGF5OiBmYWxzZSxcbiAgICAgICAgZGVsYXlDb250cm9sczogMzAwMCxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBjbHM6ICd1ay1vcGVuJyxcbiAgICAgICAgY2xzUGFnZTogJ3VrLWxpZ2h0Ym94LXBhZ2UnLFxuICAgICAgICBzZWxMaXN0OiAnLnVrLWxpZ2h0Ym94LWl0ZW1zJyxcbiAgICAgICAgYXR0ckl0ZW06ICd1ay1saWdodGJveC1pdGVtJyxcbiAgICAgICAgc2VsQ2xvc2U6ICcudWstY2xvc2UtbGFyZ2UnLFxuICAgICAgICBzZWxDYXB0aW9uOiAnLnVrLWxpZ2h0Ym94LWNhcHRpb24nLFxuICAgICAgICBwYXVzZU9uSG92ZXI6IGZhbHNlLFxuICAgICAgICB2ZWxvY2l0eTogMixcbiAgICAgICAgQW5pbWF0aW9uczogQW5pbWF0aW9ucyQxLFxuICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJ1ay1saWdodGJveCB1ay1vdmVyZmxvdy1oaWRkZW5cXFwiPiA8dWwgY2xhc3M9XFxcInVrLWxpZ2h0Ym94LWl0ZW1zXFxcIj48L3VsPiA8ZGl2IGNsYXNzPVxcXCJ1ay1saWdodGJveC10b29sYmFyIHVrLXBvc2l0aW9uLXRvcCB1ay10ZXh0LXJpZ2h0IHVrLXRyYW5zaXRpb24tc2xpZGUtdG9wIHVrLXRyYW5zaXRpb24tb3BhcXVlXFxcIj4gPGJ1dHRvbiBjbGFzcz1cXFwidWstbGlnaHRib3gtdG9vbGJhci1pY29uIHVrLWNsb3NlLWxhcmdlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIHVrLWNsb3NlPjwvYnV0dG9uPiA8L2Rpdj4gPGEgY2xhc3M9XFxcInVrLWxpZ2h0Ym94LWJ1dHRvbiB1ay1wb3NpdGlvbi1jZW50ZXItbGVmdCB1ay1wb3NpdGlvbi1tZWRpdW0gdWstdHJhbnNpdGlvbi1mYWRlXFxcIiBocmVmIHVrLXNsaWRlbmF2LXByZXZpb3VzIHVrLWxpZ2h0Ym94LWl0ZW09XFxcInByZXZpb3VzXFxcIj48L2E+IDxhIGNsYXNzPVxcXCJ1ay1saWdodGJveC1idXR0b24gdWstcG9zaXRpb24tY2VudGVyLXJpZ2h0IHVrLXBvc2l0aW9uLW1lZGl1bSB1ay10cmFuc2l0aW9uLWZhZGVcXFwiIGhyZWYgdWstc2xpZGVuYXYtbmV4dCB1ay1saWdodGJveC1pdGVtPVxcXCJuZXh0XFxcIj48L2E+IDxkaXYgY2xhc3M9XFxcInVrLWxpZ2h0Ym94LXRvb2xiYXIgdWstbGlnaHRib3gtY2FwdGlvbiB1ay1wb3NpdGlvbi1ib3R0b20gdWstdGV4dC1jZW50ZXIgdWstdHJhbnNpdGlvbi1zbGlkZS1ib3R0b20gdWstdHJhbnNpdGlvbi1vcGFxdWVcXFwiPjwvZGl2PiA8L2Rpdj5cIiB9KSxcblxuXG5cblxuXG5cblxuXG5cblxuICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgY29uc3QgJGVsID0gJCh0aGlzLnRlbXBsYXRlKTtcbiAgICAgICAgY29uc3QgbGlzdCA9ICQodGhpcy5zZWxMaXN0LCAkZWwpO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKCkgPT4gYXBwZW5kKGxpc3QsICc8bGk+JykpO1xuXG4gICAgICAgIHRoaXMuJG1vdW50KGFwcGVuZCh0aGlzLmNvbnRhaW5lciwgJGVsKSk7XG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBjYXB0aW9uKF9yZWYsICRlbCkge2xldCB7IHNlbENhcHRpb24gfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuICQoc2VsQ2FwdGlvbiwgJGVsKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBwb2ludGVyTW92ZSQxICsgXCIgXCIgKyBwb2ludGVyRG93biQxICsgXCIga2V5ZG93blwiLFxuXG4gICAgICAgIGhhbmRsZXI6ICdzaG93Q29udHJvbHMnIH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsU2xpZGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Nob3duJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy5zaG93Q29udHJvbHMoKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGUnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICB0aGlzLmhpZGVDb250cm9scygpO1xuXG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5zbGlkZXMsIHRoaXMuY2xzQWN0aXZlKTtcbiAgICAgICAgICBUcmFuc2l0aW9uLnN0b3AodGhpcy5zbGlkZXMpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZGVuJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy4kZGVzdHJveSh0cnVlKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2tleXVwJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzVG9nZ2xlZCh0aGlzLiRlbCkgfHwgIXRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAgIHRoaXMuc2hvdygncHJldmlvdXMnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICB0aGlzLnNob3coJ25leHQnKTtcbiAgICAgICAgICAgICAgYnJlYWs7fVxuXG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdiZWZvcmVpdGVtc2hvdycsXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNUb2dnbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgdGhpcy50b2dnbGVFbGVtZW50KHRoaXMuJGVsLCB0cnVlLCBmYWxzZSk7XG5cbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IEFuaW1hdGlvbnMkMVsnc2NhbGUnXTtcbiAgICAgICAgICByZW1vdmVDbGFzcyhlLnRhcmdldCwgdGhpcy5jbHNBY3RpdmUpO1xuICAgICAgICAgIHRoaXMuc3RhY2suc3BsaWNlKDEsIDAsIHRoaXMuaW5kZXgpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaXRlbXNob3cnLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaHRtbCh0aGlzLmNhcHRpb24sIHRoaXMuZ2V0SXRlbSgpLmNhcHRpb24gfHwgJycpO1xuXG4gICAgICAgICAgZm9yIChsZXQgaiA9IC10aGlzLnByZWxvYWQ7IGogPD0gdGhpcy5wcmVsb2FkOyBqKyspIHtcbiAgICAgICAgICAgIHRoaXMubG9hZEl0ZW0odGhpcy5pbmRleCArIGopO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2l0ZW1zaG93bicsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IHRoaXMuJHByb3BzLmRyYWdnYWJsZTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2l0ZW1sb2FkJyxcblxuICAgICAgICBhc3luYyBoYW5kbGVyKF8sIGl0ZW0pIHtcbiAgICAgICAgICBjb25zdCB7IHNvdXJjZTogc3JjLCB0eXBlLCBhbHQgPSAnJywgcG9zdGVyLCBhdHRycyA9IHt9IH0gPSBpdGVtO1xuXG4gICAgICAgICAgdGhpcy5zZXRJdGVtKGl0ZW0sICc8c3BhbiB1ay1zcGlubmVyPjwvc3Bhbj4nKTtcblxuICAgICAgICAgIGlmICghc3JjKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IG1hdGNoZXM7XG4gICAgICAgICAgY29uc3QgaWZyYW1lQXR0cnMgPSB7XG4gICAgICAgICAgICBhbGxvd2Z1bGxzY3JlZW46ICcnLFxuICAgICAgICAgICAgc3R5bGU6ICdtYXgtd2lkdGg6IDEwMCU7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7JyxcbiAgICAgICAgICAgICd1ay1yZXNwb25zaXZlJzogJycsXG4gICAgICAgICAgICAndWstdmlkZW8nOiBcIlwiICsgdGhpcy52aWRlb0F1dG9wbGF5IH07XG5cblxuICAgICAgICAgIC8vIEltYWdlXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGUgPT09ICdpbWFnZScgfHxcbiAgICAgICAgICBzcmMubWF0Y2goL1xcLihhdmlmfGpwZT9nfGpmaWZ8YT9wbmd8Z2lmfHN2Z3x3ZWJwKSgkfFxcPykvaSkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBhd2FpdCBnZXRJbWFnZShzcmMsIGF0dHJzLnNyY3NldCwgYXR0cnMuc2l6ZSk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0SXRlbShpdGVtLCBjcmVhdGVFbCgnaW1nJywgeyBzcmMsIHdpZHRoLCBoZWlnaHQsIGFsdCwgLi4uYXR0cnMgfSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLnNldEVycm9yKGl0ZW0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBWaWRlb1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3ZpZGVvJyB8fCBzcmMubWF0Y2goL1xcLihtcDR8d2VibXxvZ3YpKCR8XFw/KS9pKSkge1xuICAgICAgICAgICAgY29uc3QgdmlkZW8gPSBjcmVhdGVFbCgndmlkZW8nLCB7XG4gICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgcG9zdGVyLFxuICAgICAgICAgICAgICBjb250cm9sczogJycsXG4gICAgICAgICAgICAgIHBsYXlzaW5saW5lOiAnJyxcbiAgICAgICAgICAgICAgJ3VrLXZpZGVvJzogXCJcIiArIHRoaXMudmlkZW9BdXRvcGxheSxcbiAgICAgICAgICAgICAgLi4uYXR0cnMgfSk7XG5cblxuICAgICAgICAgICAgb24odmlkZW8sICdsb2FkZWRtZXRhZGF0YScsICgpID0+IHtcbiAgICAgICAgICAgICAgYXR0cih2aWRlbywgeyB3aWR0aDogdmlkZW8udmlkZW9XaWR0aCwgaGVpZ2h0OiB2aWRlby52aWRlb0hlaWdodCB9KTtcbiAgICAgICAgICAgICAgdGhpcy5zZXRJdGVtKGl0ZW0sIHZpZGVvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb24odmlkZW8sICdlcnJvcicsICgpID0+IHRoaXMuc2V0RXJyb3IoaXRlbSkpO1xuXG4gICAgICAgICAgICAvLyBJZnJhbWVcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpZnJhbWUnIHx8IHNyYy5tYXRjaCgvXFwuKGh0bWx8cGhwKSgkfFxcPykvaSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SXRlbShcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBjcmVhdGVFbCgnaWZyYW1lJywge1xuICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgIGFsbG93ZnVsbHNjcmVlbjogJycsXG4gICAgICAgICAgICAgIGNsYXNzOiAndWstbGlnaHRib3gtaWZyYW1lJyxcbiAgICAgICAgICAgICAgLi4uYXR0cnMgfSkpO1xuXG5cblxuICAgICAgICAgICAgLy8gWW91VHViZVxuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgbWF0Y2hlcyA9IHNyYy5tYXRjaChcbiAgICAgICAgICAvXFwvXFwvKD86Lio/eW91dHViZSgtbm9jb29raWUpP1xcLi4qP1s/Jl12PXx5b3V0dVxcLmJlXFwvKShbXFx3LV17MTF9KVsmP10/KC4qKT8vKSlcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SXRlbShcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBjcmVhdGVFbCgnaWZyYW1lJywge1xuICAgICAgICAgICAgICBzcmM6IFwiaHR0cHM6Ly93d3cueW91dHViZVwiICsgKG1hdGNoZXNbMV0gfHwgJycpICsgXCIuY29tL2VtYmVkL1wiICsgbWF0Y2hlc1syXSArIChcbiAgICAgICAgICAgICAgbWF0Y2hlc1szXSA/IFwiP1wiICsgbWF0Y2hlc1szXSA6ICcnKSxcblxuICAgICAgICAgICAgICB3aWR0aDogMTkyMCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiAxMDgwLFxuICAgICAgICAgICAgICAuLi5pZnJhbWVBdHRycyxcbiAgICAgICAgICAgICAgLi4uYXR0cnMgfSkpO1xuXG5cblxuICAgICAgICAgICAgLy8gVmltZW9cbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXMgPSBzcmMubWF0Y2goL1xcL1xcLy4qP3ZpbWVvXFwuW2Etel0rXFwvKFxcZCspWyY/XT8oLiopPy8pKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IGF3YWl0IChcbiAgICAgICAgICAgICAgYXdhaXQgZmV0Y2goXCJodHRwczovL3ZpbWVvLmNvbS9hcGkvb2VtYmVkLmpzb24/bWF4d2lkdGg9MTkyMCZ1cmw9XCIgK1xuICAgICAgICAgICAgICBlbmNvZGVVUkkoXG4gICAgICAgICAgICAgIHNyYyksXG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnb21pdCcgfSkpLlxuXG5cbiAgICAgICAgICAgICAganNvbigpO1xuXG4gICAgICAgICAgICAgIHRoaXMuc2V0SXRlbShcbiAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgY3JlYXRlRWwoJ2lmcmFtZScsIHtcbiAgICAgICAgICAgICAgICBzcmM6IFwiaHR0cHM6Ly9wbGF5ZXIudmltZW8uY29tL3ZpZGVvL1wiICsgbWF0Y2hlc1sxXSArIChcbiAgICAgICAgICAgICAgICBtYXRjaGVzWzJdID8gXCI/XCIgKyBtYXRjaGVzWzJdIDogJycpLFxuXG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIC4uLmlmcmFtZUF0dHJzLFxuICAgICAgICAgICAgICAgIC4uLmF0dHJzIH0pKTtcblxuXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0RXJyb3IoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBsb2FkSXRlbShpbmRleCkge2lmIChpbmRleCA9PT0gdm9pZCAwKSB7aW5kZXggPSB0aGlzLmluZGV4O31cbiAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5nZXRJdGVtKGluZGV4KTtcblxuICAgICAgICAgIGlmICghdGhpcy5nZXRTbGlkZShpdGVtKS5jaGlsZEVsZW1lbnRDb3VudCkge1xuICAgICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ2l0ZW1sb2FkJywgW2l0ZW1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SXRlbShpbmRleCkge2lmIChpbmRleCA9PT0gdm9pZCAwKSB7aW5kZXggPSB0aGlzLmluZGV4O31cbiAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1tnZXRJbmRleChpbmRleCwgdGhpcy5zbGlkZXMpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRJdGVtKGl0ZW0sIGNvbnRlbnQpIHtcbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnaXRlbWxvYWRlZCcsIFt0aGlzLCBodG1sKHRoaXMuZ2V0U2xpZGUoaXRlbSksIGNvbnRlbnQpXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2xpZGUoaXRlbSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNsaWRlc1t0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSldO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEVycm9yKGl0ZW0pIHtcbiAgICAgICAgICB0aGlzLnNldEl0ZW0oaXRlbSwgJzxzcGFuIHVrLWljb249XCJpY29uOiBib2x0OyByYXRpbzogMlwiPjwvc3Bhbj4nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93Q29udHJvbHMoKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29udHJvbHNUaW1lcik7XG4gICAgICAgICAgdGhpcy5jb250cm9sc1RpbWVyID0gc2V0VGltZW91dCh0aGlzLmhpZGVDb250cm9scywgdGhpcy5kZWxheUNvbnRyb2xzKTtcblxuICAgICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCAndWstYWN0aXZlJywgJ3VrLXRyYW5zaXRpb24tYWN0aXZlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZUNvbnRyb2xzKCkge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuJGVsLCAndWstYWN0aXZlJywgJ3VrLXRyYW5zaXRpb24tYWN0aXZlJyk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsKHRhZywgYXR0cnMpIHtcbiAgICAgIGNvbnN0IGVsID0gZnJhZ21lbnQoXCI8XCIgKyB0YWcgKyBcIj5cIik7XG4gICAgICBhdHRyKGVsLCBhdHRycyk7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuXG4gICAgdmFyIGxpZ2h0Ym94ID0ge1xuICAgICAgaW5zdGFsbDogaW5zdGFsbCQxLFxuXG4gICAgICBwcm9wczogeyB0b2dnbGU6IFN0cmluZyB9LFxuXG4gICAgICBkYXRhOiB7IHRvZ2dsZTogJ2EnIH0sXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHRvZ2dsZXM6IHtcbiAgICAgICAgICBnZXQoX3JlZiwgJGVsKSB7bGV0IHsgdG9nZ2xlIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuICQkKHRvZ2dsZSwgJGVsKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB9IH0gfSxcblxuXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2dnbGUgKyBcIjpub3QoLnVrLWRpc2FibGVkKVwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNob3coZS5jdXJyZW50KTtcbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgc2hvdyhpbmRleCkge1xuICAgICAgICAgIGNvbnN0IGl0ZW1zID0gdW5pcXVlQnkodGhpcy50b2dnbGVzLm1hcCh0b0l0ZW0pLCAnc291cmNlJyk7XG5cbiAgICAgICAgICBpZiAoaXNFbGVtZW50KGluZGV4KSkge1xuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2UgfSA9IHRvSXRlbShpbmRleCk7XG4gICAgICAgICAgICBpbmRleCA9IGZpbmRJbmRleChpdGVtcywgKF9yZWYyKSA9PiB7bGV0IHsgc291cmNlOiBzcmMgfSA9IF9yZWYyO3JldHVybiBzb3VyY2UgPT09IHNyYzt9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBhbmVsID0gdGhpcy5wYW5lbCB8fCB0aGlzLiRjcmVhdGUoJ2xpZ2h0Ym94UGFuZWwnLCB7IC4uLnRoaXMuJHByb3BzLCBpdGVtcyB9KTtcblxuICAgICAgICAgIG9uKHRoaXMucGFuZWwuJGVsLCAnaGlkZGVuJywgKCkgPT4gdGhpcy5wYW5lbCA9IGZhbHNlKTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLnBhbmVsLnNob3coaW5kZXgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGUoKSB7dmFyIF90aGlzJHBhbmVsO1xuICAgICAgICAgIHJldHVybiAoX3RoaXMkcGFuZWwgPSB0aGlzLnBhbmVsKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcGFuZWwuaGlkZSgpO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsJDEoVUlraXQsIExpZ2h0Ym94KSB7XG4gICAgICBpZiAoIVVJa2l0LmxpZ2h0Ym94UGFuZWwpIHtcbiAgICAgICAgVUlraXQuY29tcG9uZW50KCdsaWdodGJveFBhbmVsJywgTGlnaHRib3hQYW5lbCk7XG4gICAgICB9XG5cbiAgICAgIGFzc2lnbihMaWdodGJveC5wcm9wcywgVUlraXQuY29tcG9uZW50KCdsaWdodGJveFBhbmVsJykub3B0aW9ucy5wcm9wcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JdGVtKGVsKSB7XG4gICAgICBjb25zdCBpdGVtID0ge307XG5cbiAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBbJ2hyZWYnLCAnY2FwdGlvbicsICd0eXBlJywgJ3Bvc3RlcicsICdhbHQnLCAnYXR0cnMnXSkge1xuICAgICAgICBpdGVtW2F0dHIgPT09ICdocmVmJyA/ICdzb3VyY2UnIDogYXR0cl0gPSBkYXRhKGVsLCBhdHRyKTtcbiAgICAgIH1cblxuICAgICAgaXRlbS5hdHRycyA9IHBhcnNlT3B0aW9ucyhpdGVtLmF0dHJzKTtcblxuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgdmFyIG5vdGlmaWNhdGlvbiA9IHtcbiAgICAgIG1peGluczogW0NvbnRhaW5lcl0sXG5cbiAgICAgIGZ1bmN0aW9uYWw6IHRydWUsXG5cbiAgICAgIGFyZ3M6IFsnbWVzc2FnZScsICdzdGF0dXMnXSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBtZXNzYWdlOiAnJyxcbiAgICAgICAgc3RhdHVzOiAnJyxcbiAgICAgICAgdGltZW91dDogNTAwMCxcbiAgICAgICAgZ3JvdXA6IG51bGwsXG4gICAgICAgIHBvczogJ3RvcC1jZW50ZXInLFxuICAgICAgICBjbHNDb250YWluZXI6ICd1ay1ub3RpZmljYXRpb24nLFxuICAgICAgICBjbHNDbG9zZTogJ3VrLW5vdGlmaWNhdGlvbi1jbG9zZScsXG4gICAgICAgIGNsc01zZzogJ3VrLW5vdGlmaWNhdGlvbi1tZXNzYWdlJyB9LFxuXG5cbiAgICAgIGluc3RhbGwsXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIG1hcmdpblByb3AoX3JlZikge2xldCB7IHBvcyB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gXCJtYXJnaW5cIiArIChzdGFydHNXaXRoKHBvcywgJ3RvcCcpID8gJ1RvcCcgOiAnQm90dG9tJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnRQcm9wcygpIHtcbiAgICAgICAgICByZXR1cm4geyBvcGFjaXR5OiAwLCBbdGhpcy5tYXJnaW5Qcm9wXTogLXRoaXMuJGVsLm9mZnNldEhlaWdodCB9O1xuICAgICAgICB9IH0sXG5cblxuICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID1cbiAgICAgICAgJChcIi5cIiArIHRoaXMuY2xzQ29udGFpbmVyICsgXCItXCIgKyB0aGlzLnBvcywgdGhpcy5jb250YWluZXIpIHx8XG4gICAgICAgIGFwcGVuZChcbiAgICAgICAgdGhpcy5jb250YWluZXIsIFwiPGRpdiBjbGFzcz1cXFwiXCIgK1xuICAgICAgICB0aGlzLmNsc0NvbnRhaW5lciArIFwiIFwiICsgdGhpcy5jbHNDb250YWluZXIgKyBcIi1cIiArIHRoaXMucG9zICsgXCJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBibG9ja1xcXCI+PC9kaXY+XCIpO1xuXG5cbiAgICAgICAgdGhpcy4kbW91bnQoXG4gICAgICAgIGFwcGVuZChcbiAgICAgICAgY29udGFpbmVyLCBcIjxkaXYgY2xhc3M9XFxcIlwiICtcbiAgICAgICAgdGhpcy5jbHNNc2cgKyAoXG4gICAgICAgIHRoaXMuc3RhdHVzID8gXCIgXCIgKyB0aGlzLmNsc01zZyArIFwiLVwiICsgdGhpcy5zdGF0dXMgOiAnJykgKyBcIlxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiPiA8YSBocmVmIGNsYXNzPVxcXCJcIiArXG5cbiAgICAgICAgdGhpcy5jbHNDbG9zZSArIFwiXFxcIiBkYXRhLXVrLWNsb3NlPjwvYT4gPGRpdj5cIiArXG4gICAgICAgIHRoaXMubWVzc2FnZSArIFwiPC9kaXY+IDwvZGl2PlwiKSk7XG5cblxuXG4gICAgICB9LFxuXG4gICAgICBhc3luYyBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IHRvRmxvYXQoY3NzKHRoaXMuJGVsLCB0aGlzLm1hcmdpblByb3ApKTtcbiAgICAgICAgYXdhaXQgVHJhbnNpdGlvbi5zdGFydChjc3ModGhpcy4kZWwsIHRoaXMuc3RhcnRQcm9wcyksIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIFt0aGlzLm1hcmdpblByb3BdOiBtYXJnaW4gfSk7XG5cblxuICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5jbG9zZSwgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGNsaWNrKGUpIHtcbiAgICAgICAgICBpZiAoY2xvc2VzdChlLnRhcmdldCwgJ2FbaHJlZj1cIiNcIl0sYVtocmVmPVwiXCJdJykpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFtwb2ludGVyRW50ZXJdKCkge1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFtwb2ludGVyTGVhdmVdKCkge1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuY2xvc2UsIHRoaXMudGltZW91dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBjbG9zZShpbW1lZGlhdGUpIHtcbiAgICAgICAgICBjb25zdCByZW1vdmVGbiA9IChlbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50KGVsKTtcblxuICAgICAgICAgICAgdHJpZ2dlcihlbCwgJ2Nsb3NlJywgW3RoaXNdKTtcbiAgICAgICAgICAgIHJlbW92ZSQxKGVsKTtcblxuICAgICAgICAgICAgaWYgKCEoY29udGFpbmVyICE9IG51bGwgJiYgY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlJDEoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgICAgYXdhaXQgVHJhbnNpdGlvbi5zdGFydCh0aGlzLiRlbCwgdGhpcy5zdGFydFByb3BzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW1vdmVGbih0aGlzLiRlbCk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGluc3RhbGwoVUlraXQpIHtcbiAgICAgIFVJa2l0Lm5vdGlmaWNhdGlvbi5jbG9zZUFsbCA9IGZ1bmN0aW9uIChncm91cCwgaW1tZWRpYXRlKSB7XG4gICAgICAgIGFwcGx5KGRvY3VtZW50LmJvZHksIChlbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IFVJa2l0LmdldENvbXBvbmVudChlbCwgJ25vdGlmaWNhdGlvbicpO1xuICAgICAgICAgIGlmIChub3RpZmljYXRpb24gJiYgKCFncm91cCB8fCBncm91cCA9PT0gbm90aWZpY2F0aW9uLmdyb3VwKSkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uLmNsb3NlKGltbWVkaWF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICB4OiB0cmFuc2Zvcm1GbixcbiAgICAgIHk6IHRyYW5zZm9ybUZuLFxuICAgICAgcm90YXRlOiB0cmFuc2Zvcm1GbixcbiAgICAgIHNjYWxlOiB0cmFuc2Zvcm1GbixcbiAgICAgIGNvbG9yOiBjb2xvckZuLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvckZuLFxuICAgICAgYm9yZGVyQ29sb3I6IGNvbG9yRm4sXG4gICAgICBibHVyOiBmaWx0ZXJGbixcbiAgICAgIGh1ZTogZmlsdGVyRm4sXG4gICAgICBmb3BhY2l0eTogZmlsdGVyRm4sXG4gICAgICBncmF5c2NhbGU6IGZpbHRlckZuLFxuICAgICAgaW52ZXJ0OiBmaWx0ZXJGbixcbiAgICAgIHNhdHVyYXRlOiBmaWx0ZXJGbixcbiAgICAgIHNlcGlhOiBmaWx0ZXJGbixcbiAgICAgIG9wYWNpdHk6IGNzc1Byb3BGbixcbiAgICAgIHN0cm9rZTogc3Ryb2tlRm4sXG4gICAgICBiZ3g6IGJhY2tncm91bmRGbixcbiAgICAgIGJneTogYmFja2dyb3VuZEZuIH07XG5cblxuICAgIGNvbnN0IHsga2V5cyB9ID0gT2JqZWN0O1xuXG4gICAgdmFyIFBhcmFsbGF4ID0ge1xuICAgICAgbWl4aW5zOiBbTWVkaWFdLFxuXG4gICAgICBwcm9wczogZmlsbE9iamVjdChrZXlzKHByb3BzKSwgJ2xpc3QnKSxcblxuICAgICAgZGF0YTogZmlsbE9iamVjdChrZXlzKHByb3BzKSwgdW5kZWZpbmVkKSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgcHJvcHMocHJvcGVydGllcywgJGVsKSB7XG4gICAgICAgICAgY29uc3Qgc3RvcHMgPSB7fTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gcHJvcHMgJiYgIWlzVW5kZWZpbmVkKHByb3BlcnRpZXNbcHJvcF0pKSB7XG4gICAgICAgICAgICAgIHN0b3BzW3Byb3BdID0gcHJvcGVydGllc1twcm9wXS5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gc3RvcHMpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHByb3BzW3Byb3BdKHByb3AsICRlbCwgc3RvcHNbcHJvcF0sIHN0b3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGV2ZW50czoge1xuICAgICAgICBsb2FkKCkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHRoaXMuZ2V0Q3NzKDApKSB7XG4gICAgICAgICAgICBjc3ModGhpcy4kZWwsIHByb3AsICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q3NzKHBlcmNlbnQpIHtcbiAgICAgICAgICBjb25zdCBjc3MgPSB7IHRyYW5zZm9ybTogJycsIGZpbHRlcjogJycgfTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gdGhpcy5wcm9wcykge1xuICAgICAgICAgICAgdGhpcy5wcm9wc1twcm9wXShjc3MsIHBlcmNlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3NzO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1Gbihwcm9wLCBlbCwgc3RvcHMpIHtcbiAgICAgIGxldCB1bml0ID0gZ2V0VW5pdChzdG9wcykgfHwgeyB4OiAncHgnLCB5OiAncHgnLCByb3RhdGU6ICdkZWcnIH1bcHJvcF0gfHwgJyc7XG4gICAgICBsZXQgdHJhbnNmb3JtRm47XG5cbiAgICAgIGlmIChwcm9wID09PSAneCcgfHwgcHJvcCA9PT0gJ3knKSB7XG4gICAgICAgIHByb3AgPSBcInRyYW5zbGF0ZVwiICsgdWNmaXJzdChwcm9wKTtcbiAgICAgICAgdHJhbnNmb3JtRm4gPSAoc3RvcCkgPT4gdG9GbG9hdCh0b0Zsb2F0KHN0b3ApLnRvRml4ZWQodW5pdCA9PT0gJ3B4JyA/IDAgOiA2KSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdzY2FsZScpIHtcbiAgICAgICAgdW5pdCA9ICcnO1xuICAgICAgICB0cmFuc2Zvcm1GbiA9IChzdG9wKSA9PlxuICAgICAgICBnZXRVbml0KFtzdG9wXSkgPyB0b1B4KHN0b3AsICd3aWR0aCcsIGVsLCB0cnVlKSAvIGVsLm9mZnNldFdpZHRoIDogc3RvcDtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0b3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdG9wcy51bnNoaWZ0KHByb3AgPT09ICdzY2FsZScgPyAxIDogMCk7XG4gICAgICB9XG5cbiAgICAgIHN0b3BzID0gcGFyc2VTdG9wcyhzdG9wcywgdHJhbnNmb3JtRm4pO1xuXG4gICAgICByZXR1cm4gKGNzcywgcGVyY2VudCkgPT4ge1xuICAgICAgICBjc3MudHJhbnNmb3JtICs9IFwiIFwiICsgcHJvcCArIFwiKFwiICsgZ2V0VmFsdWUoc3RvcHMsIHBlcmNlbnQpICsgdW5pdCArIFwiKVwiO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xvckZuKHByb3AsIGVsLCBzdG9wcykge1xuICAgICAgaWYgKHN0b3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdG9wcy51bnNoaWZ0KGdldENzc1ZhbHVlKGVsLCBwcm9wLCAnJykpO1xuICAgICAgfVxuXG4gICAgICBzdG9wcyA9IHBhcnNlU3RvcHMoc3RvcHMsIChzdG9wKSA9PiBwYXJzZUNvbG9yKGVsLCBzdG9wKSk7XG5cbiAgICAgIHJldHVybiAoY3NzLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IFtzdGFydCwgZW5kLCBwXSA9IGdldFN0b3Aoc3RvcHMsIHBlcmNlbnQpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0YXJ0LlxuICAgICAgICBtYXAoKHZhbHVlLCBpKSA9PiB7XG4gICAgICAgICAgdmFsdWUgKz0gcCAqIChlbmRbaV0gLSB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGkgPT09IDMgPyB0b0Zsb2F0KHZhbHVlKSA6IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgIH0pLlxuICAgICAgICBqb2luKCcsJyk7XG4gICAgICAgIGNzc1twcm9wXSA9IFwicmdiYShcIiArIHZhbHVlICsgXCIpXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29sb3IoZWwsIGNvbG9yKSB7XG4gICAgICByZXR1cm4gZ2V0Q3NzVmFsdWUoZWwsICdjb2xvcicsIGNvbG9yKS5cbiAgICAgIHNwbGl0KC9bKCksXS9nKS5cbiAgICAgIHNsaWNlKDEsIC0xKS5cbiAgICAgIGNvbmNhdCgxKS5cbiAgICAgIHNsaWNlKDAsIDQpLlxuICAgICAgbWFwKHRvRmxvYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlckZuKHByb3AsIGVsLCBzdG9wcykge1xuICAgICAgaWYgKHN0b3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdG9wcy51bnNoaWZ0KDApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1bml0ID0gZ2V0VW5pdChzdG9wcykgfHwgeyBibHVyOiAncHgnLCBodWU6ICdkZWcnIH1bcHJvcF0gfHwgJyUnO1xuICAgICAgcHJvcCA9IHsgZm9wYWNpdHk6ICdvcGFjaXR5JywgaHVlOiAnaHVlLXJvdGF0ZScgfVtwcm9wXSB8fCBwcm9wO1xuICAgICAgc3RvcHMgPSBwYXJzZVN0b3BzKHN0b3BzKTtcblxuICAgICAgcmV0dXJuIChjc3MsIHBlcmNlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZShzdG9wcywgcGVyY2VudCk7XG4gICAgICAgIGNzcy5maWx0ZXIgKz0gXCIgXCIgKyBwcm9wICsgXCIoXCIgKyAodmFsdWUgKyB1bml0KSArIFwiKVwiO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjc3NQcm9wRm4ocHJvcCwgZWwsIHN0b3BzKSB7XG4gICAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3BzLnVuc2hpZnQoZ2V0Q3NzVmFsdWUoZWwsIHByb3AsICcnKSk7XG4gICAgICB9XG5cbiAgICAgIHN0b3BzID0gcGFyc2VTdG9wcyhzdG9wcyk7XG5cbiAgICAgIHJldHVybiAoY3NzLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGNzc1twcm9wXSA9IGdldFZhbHVlKHN0b3BzLCBwZXJjZW50KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3Ryb2tlRm4ocHJvcCwgZWwsIHN0b3BzKSB7XG4gICAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3BzLnVuc2hpZnQoMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVuaXQgPSBnZXRVbml0KHN0b3BzKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGdldE1heFBhdGhMZW5ndGgoZWwpO1xuICAgICAgc3RvcHMgPSBwYXJzZVN0b3BzKHN0b3BzLnJldmVyc2UoKSwgKHN0b3ApID0+IHtcbiAgICAgICAgc3RvcCA9IHRvRmxvYXQoc3RvcCk7XG4gICAgICAgIHJldHVybiB1bml0ID09PSAnJScgPyBzdG9wICogbGVuZ3RoIC8gMTAwIDogc3RvcDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXN0b3BzLnNvbWUoKF9yZWYpID0+IHtsZXQgW3ZhbHVlXSA9IF9yZWY7cmV0dXJuIHZhbHVlO30pKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgICAgfVxuXG4gICAgICBjc3MoZWwsICdzdHJva2VEYXNoYXJyYXknLCBsZW5ndGgpO1xuXG4gICAgICByZXR1cm4gKGNzcywgcGVyY2VudCkgPT4ge1xuICAgICAgICBjc3Muc3Ryb2tlRGFzaG9mZnNldCA9IGdldFZhbHVlKHN0b3BzLCBwZXJjZW50KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmFja2dyb3VuZEZuKHByb3AsIGVsLCBzdG9wcywgcHJvcHMpIHtcbiAgICAgIGlmIChzdG9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RvcHMudW5zaGlmdCgwKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXR0ciA9IHByb3AgPT09ICdiZ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgcHJvcHNbcHJvcF0gPSBwYXJzZVN0b3BzKHN0b3BzLCAoc3RvcCkgPT4gdG9QeChzdG9wLCBhdHRyLCBlbCkpO1xuXG4gICAgICBjb25zdCBiZ1Byb3BzID0gWydiZ3gnLCAnYmd5J10uZmlsdGVyKChwcm9wKSA9PiBwcm9wIGluIHByb3BzKTtcbiAgICAgIGlmIChiZ1Byb3BzLmxlbmd0aCA9PT0gMiAmJiBwcm9wID09PSAnYmd4Jykge1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldENzc1ZhbHVlKGVsLCAnYmFja2dyb3VuZFNpemUnLCAnJykgPT09ICdjb3ZlcicpIHtcbiAgICAgICAgcmV0dXJuIGJhY2tncm91bmRDb3ZlckZuKHByb3AsIGVsLCBzdG9wcywgcHJvcHMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBiZ1Byb3BzKSB7XG4gICAgICAgIHBvc2l0aW9uc1twcm9wXSA9IGdldEJhY2tncm91bmRQb3MoZWwsIHByb3ApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0QmFja2dyb3VuZFBvc0ZuKGJnUHJvcHMsIHBvc2l0aW9ucywgcHJvcHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJhY2tncm91bmRDb3ZlckZuKHByb3AsIGVsLCBzdG9wcywgcHJvcHMpIHtcbiAgICAgIGNvbnN0IGRpbUltYWdlID0gZ2V0QmFja2dyb3VuZEltYWdlRGltZW5zaW9ucyhlbCk7XG5cbiAgICAgIGlmICghZGltSW1hZ2Uud2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpbUVsID0ge1xuICAgICAgICB3aWR0aDogZWwub2Zmc2V0V2lkdGgsXG4gICAgICAgIGhlaWdodDogZWwub2Zmc2V0SGVpZ2h0IH07XG5cblxuICAgICAgY29uc3QgYmdQcm9wcyA9IFsnYmd4JywgJ2JneSddLmZpbHRlcigocHJvcCkgPT4gcHJvcCBpbiBwcm9wcyk7XG5cbiAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBwcm9wIG9mIGJnUHJvcHMpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gcHJvcHNbcHJvcF0ubWFwKChfcmVmMikgPT4ge2xldCBbdmFsdWVdID0gX3JlZjI7cmV0dXJuIHZhbHVlO30pO1xuICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi52YWx1ZXMpO1xuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heCguLi52YWx1ZXMpO1xuICAgICAgICBjb25zdCBkb3duID0gdmFsdWVzLmluZGV4T2YobWluKSA8IHZhbHVlcy5pbmRleE9mKG1heCk7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBtYXggLSBtaW47XG5cbiAgICAgICAgcG9zaXRpb25zW3Byb3BdID0gKGRvd24gPyAtZGlmZiA6IDApIC0gKGRvd24gPyBtaW4gOiBtYXgpICsgXCJweFwiO1xuICAgICAgICBkaW1FbFtwcm9wID09PSAnYmd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJ10gKz0gZGlmZjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGltID0gRGltZW5zaW9ucy5jb3ZlcihkaW1JbWFnZSwgZGltRWwpO1xuXG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2YgYmdQcm9wcykge1xuICAgICAgICBjb25zdCBhdHRyID0gcHJvcCA9PT0gJ2JneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gZGltW2F0dHJdIC0gZGltRWxbYXR0cl07XG4gICAgICAgIHBvc2l0aW9uc1twcm9wXSA9IFwibWF4KFwiICsgZ2V0QmFja2dyb3VuZFBvcyhlbCwgcHJvcCkgKyBcIiwtXCIgKyBvdmVyZmxvdyArIFwicHgpICsgXCIgKyBwb3NpdGlvbnNbcHJvcF07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZuID0gc2V0QmFja2dyb3VuZFBvc0ZuKGJnUHJvcHMsIHBvc2l0aW9ucywgcHJvcHMpO1xuICAgICAgcmV0dXJuIChjc3MsIHBlcmNlbnQpID0+IHtcbiAgICAgICAgZm4oY3NzLCBwZXJjZW50KTtcbiAgICAgICAgY3NzLmJhY2tncm91bmRTaXplID0gZGltLndpZHRoICsgXCJweCBcIiArIGRpbS5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIGNzcy5iYWNrZ3JvdW5kUmVwZWF0ID0gJ25vLXJlcGVhdCc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJhY2tncm91bmRQb3MoZWwsIHByb3ApIHtcbiAgICAgIHJldHVybiBnZXRDc3NWYWx1ZShlbCwgXCJiYWNrZ3JvdW5kLXBvc2l0aW9uLVwiICsgcHJvcC5zdWJzdHIoLTEpLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0QmFja2dyb3VuZFBvc0ZuKGJnUHJvcHMsIHBvc2l0aW9ucywgcHJvcHMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoY3NzLCBwZXJjZW50KSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBiZ1Byb3BzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZShwcm9wc1twcm9wXSwgcGVyY2VudCk7XG4gICAgICAgICAgY3NzW1wiYmFja2dyb3VuZC1wb3NpdGlvbi1cIiArIHByb3Auc3Vic3RyKC0xKV0gPSBcImNhbGMoXCIgKyBwb3NpdGlvbnNbcHJvcF0gKyBcIiArIFwiICsgdmFsdWUgKyBcInB4KVwiO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB7fTtcbiAgICBmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kSW1hZ2VEaW1lbnNpb25zKGVsKSB7XG4gICAgICBjb25zdCBzcmMgPSBjc3MoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnKS5yZXBsYWNlKC9ebm9uZXx1cmxcXChbXCInXT8oLis/KVtcIiddP1xcKSQvLCAnJDEnKTtcblxuICAgICAgaWYgKGRpbWVuc2lvbnNbc3JjXSkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uc1tzcmNdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgaWYgKHNyYykge1xuICAgICAgICBpbWFnZS5zcmMgPSBzcmM7XG5cbiAgICAgICAgaWYgKCFpbWFnZS5uYXR1cmFsV2lkdGgpIHtcbiAgICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBkaW1lbnNpb25zW3NyY10gPSB0b0RpbWVuc2lvbnMoaW1hZ2UpO1xuICAgICAgICAgICAgdHJpZ2dlcihlbCwgY3JlYXRlRXZlbnQoJ2xvYWQnLCBmYWxzZSkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRvRGltZW5zaW9ucyhpbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbWVuc2lvbnNbc3JjXSA9IHRvRGltZW5zaW9ucyhpbWFnZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EaW1lbnNpb25zKGltYWdlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogaW1hZ2UubmF0dXJhbFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGltYWdlLm5hdHVyYWxIZWlnaHQgfTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RvcHMoc3RvcHMsIGZuKSB7aWYgKGZuID09PSB2b2lkIDApIHtmbiA9IHRvRmxvYXQ7fVxuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gc3RvcHM7XG4gICAgICBsZXQgbnVsbEluZGV4ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IFt2YWx1ZSwgcGVyY2VudF0gPSBpc1N0cmluZyhzdG9wc1tpXSkgPyBzdG9wc1tpXS50cmltKCkuc3BsaXQoJyAnKSA6IFtzdG9wc1tpXV07XG4gICAgICAgIHZhbHVlID0gZm4odmFsdWUpO1xuICAgICAgICBwZXJjZW50ID0gcGVyY2VudCA/IHRvRmxvYXQocGVyY2VudCkgLyAxMDAgOiBudWxsO1xuXG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgaWYgKHBlcmNlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGVyY2VudCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3ZhbHVlLCAwXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBpZiAocGVyY2VudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50ICE9PSAxKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbdmFsdWUsIHBlcmNlbnRdKTtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKFt2YWx1ZSwgcGVyY2VudF0pO1xuXG4gICAgICAgIGlmIChwZXJjZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgbnVsbEluZGV4Kys7XG4gICAgICAgIH0gZWxzZSBpZiAobnVsbEluZGV4KSB7XG4gICAgICAgICAgY29uc3QgbGVmdFBlcmNlbnQgPSByZXN1bHRbaSAtIG51bGxJbmRleCAtIDFdWzFdO1xuICAgICAgICAgIGNvbnN0IHAgPSAocGVyY2VudCAtIGxlZnRQZXJjZW50KSAvIChudWxsSW5kZXggKyAxKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gbnVsbEluZGV4OyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICByZXN1bHRbaSAtIGpdWzFdID0gbGVmdFBlcmNlbnQgKyBwICogKG51bGxJbmRleCAtIGogKyAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBudWxsSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3RvcChzdG9wcywgcGVyY2VudCkge1xuICAgICAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXgoc3RvcHMuc2xpY2UoMSksIChfcmVmMykgPT4ge2xldCBbLCB0YXJnZXRQZXJjZW50XSA9IF9yZWYzO3JldHVybiBwZXJjZW50IDw9IHRhcmdldFBlcmNlbnQ7fSkgKyAxO1xuICAgICAgcmV0dXJuIFtcbiAgICAgIHN0b3BzW2luZGV4IC0gMV1bMF0sXG4gICAgICBzdG9wc1tpbmRleF1bMF0sXG4gICAgICAocGVyY2VudCAtIHN0b3BzW2luZGV4IC0gMV1bMV0pIC8gKHN0b3BzW2luZGV4XVsxXSAtIHN0b3BzW2luZGV4IC0gMV1bMV0pXTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZhbHVlKHN0b3BzLCBwZXJjZW50KSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZCwgcF0gPSBnZXRTdG9wKHN0b3BzLCBwZXJjZW50KTtcbiAgICAgIHJldHVybiBpc051bWJlcihzdGFydCkgPyBzdGFydCArIE1hdGguYWJzKHN0YXJ0IC0gZW5kKSAqIHAgKiAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogK2VuZDtcbiAgICB9XG5cbiAgICBjb25zdCB1bml0UmUgPSAvXi0/XFxkKyhcXFMrKS87XG4gICAgZnVuY3Rpb24gZ2V0VW5pdChzdG9wcywgZGVmYXVsdFVuaXQpIHtcbiAgICAgIGZvciAoY29uc3Qgc3RvcCBvZiBzdG9wcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHN0b3AubWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3AubWF0Y2godW5pdFJlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmYXVsdFVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q3NzVmFsdWUoZWwsIHByb3AsIHZhbHVlKSB7XG4gICAgICBjb25zdCBwcmV2ID0gZWwuc3R5bGVbcHJvcF07XG4gICAgICBjb25zdCB2YWwgPSBjc3MoY3NzKGVsLCBwcm9wLCB2YWx1ZSksIHByb3ApO1xuICAgICAgZWwuc3R5bGVbcHJvcF0gPSBwcmV2O1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWxsT2JqZWN0KGtleXMsIHZhbHVlKSB7XG4gICAgICByZXR1cm4ga2V5cy5yZWR1Y2UoKGRhdGEsIHByb3ApID0+IHtcbiAgICAgICAgZGF0YVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0sIHt9KTtcbiAgICB9XG5cbiAgICB2YXIgcGFyYWxsYXggPSB7XG4gICAgICBtaXhpbnM6IFtQYXJhbGxheCwgUmVzaXplLCBTY3JvbGxdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICAgICAgdmlld3BvcnQ6IE51bWJlciwgLy8gRGVwcmVjYXRlZFxuICAgICAgICBlYXNpbmc6IE51bWJlcixcbiAgICAgICAgc3RhcnQ6IFN0cmluZyxcbiAgICAgICAgZW5kOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRhcmdldDogZmFsc2UsXG4gICAgICAgIHZpZXdwb3J0OiAxLFxuICAgICAgICBlYXNpbmc6IDEsXG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IDAgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICB0YXJnZXQoX3JlZiwgJGVsKSB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiBnZXRPZmZzZXRFbGVtZW50KHRhcmdldCAmJiBxdWVyeSh0YXJnZXQsICRlbCkgfHwgJGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGFydChfcmVmMikge2xldCB7IHN0YXJ0IH0gPSBfcmVmMjtcbiAgICAgICAgICByZXR1cm4gdG9QeChzdGFydCwgJ2hlaWdodCcsIHRoaXMudGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmQoX3JlZjMpIHtsZXQgeyBlbmQsIHZpZXdwb3J0IH0gPSBfcmVmMztcbiAgICAgICAgICByZXR1cm4gdG9QeChcbiAgICAgICAgICBlbmQgfHwgKHZpZXdwb3J0ID0gKDEgLSB2aWV3cG9ydCkgKiAxMDApICYmIHZpZXdwb3J0ICsgXCJ2aCtcIiArIHZpZXdwb3J0ICsgXCIlXCIsXG4gICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgdGhpcy50YXJnZXQsXG4gICAgICAgICAgdHJ1ZSk7XG5cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKF9yZWY0LCB0eXBlcykge2xldCB7IHBlcmNlbnQgfSA9IF9yZWY0O1xuICAgICAgICAgIGlmICghdHlwZXMuaGFzKCdzY3JvbGwnKSkge1xuICAgICAgICAgICAgcGVyY2VudCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5tYXRjaE1lZGlhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHJldiA9IHBlcmNlbnQ7XG4gICAgICAgICAgcGVyY2VudCA9IGVhc2Uoc2Nyb2xsZWRPdmVyKHRoaXMudGFyZ2V0LCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCksIHRoaXMuZWFzaW5nKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwZXJjZW50LFxuICAgICAgICAgICAgc3R5bGU6IHByZXYgPT09IHBlcmNlbnQgPyBmYWxzZSA6IHRoaXMuZ2V0Q3NzKHBlcmNlbnQpIH07XG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmNSkge2xldCB7IHN0eWxlIH0gPSBfcmVmNTtcbiAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hNZWRpYSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0eWxlICYmIGNzcyh0aGlzLiRlbCwgc3R5bGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydzY3JvbGwnLCAncmVzaXplJ10gfSB9O1xuXG5cblxuICAgIC8qXG4gICAgICogSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3JlLzE2NTAyOTQ/cGVybWFsaW5rX2NvbW1lbnRfaWQ9MzQ3NzQyNSNnaXN0Y29tbWVudC0zNDc3NDI1XG4gICAgICpcbiAgICAgKiBsaW5lYXI6IDBcbiAgICAgKiBlYXNlSW5TaW5lOiAwLjVcbiAgICAgKiBlYXNlT3V0U2luZTogLTAuNVxuICAgICAqIGVhc2VJblF1YWQ6IDFcbiAgICAgKiBlYXNlT3V0UXVhZDogLTFcbiAgICAgKiBlYXNlSW5DdWJpYzogMlxuICAgICAqIGVhc2VPdXRDdWJpYzogLTJcbiAgICAgKiBlYXNlSW5RdWFydDogM1xuICAgICAqIGVhc2VPdXRRdWFydDogLTNcbiAgICAgKiBlYXNlSW5RdWludDogNFxuICAgICAqIGVhc2VPdXRRdWludDogLTRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYXNlKHBlcmNlbnQsIGVhc2luZykge1xuICAgICAgcmV0dXJuIGVhc2luZyA+PSAwID8gTWF0aC5wb3cocGVyY2VudCwgZWFzaW5nICsgMSkgOiAxIC0gTWF0aC5wb3coMSAtIHBlcmNlbnQsIDEgLSBlYXNpbmcpO1xuICAgIH1cblxuICAgIC8vIFNWRyBlbGVtZW50cyBkbyBub3QgaW5oZXJpdCBmcm9tIEhUTUxFbGVtZW50XG4gICAgZnVuY3Rpb24gZ2V0T2Zmc2V0RWxlbWVudChlbCkge1xuICAgICAgcmV0dXJuIGVsID8gJ29mZnNldFRvcCcgaW4gZWwgPyBlbCA6IGdldE9mZnNldEVsZW1lbnQocGFyZW50KGVsKSkgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIFNsaWRlclJlYWN0aXZlID0ge1xuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHdyaXRlKCkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCB8fCB0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldFZhbGlkSW5kZXgodGhpcy5pbmRleCk7XG5cbiAgICAgICAgICBpZiAoIX50aGlzLnByZXZJbmRleCB8fCB0aGlzLmluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5zaG93KGluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRlKDEsIHRoaXMucHJldkluZGV4LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0gfTtcblxuICAgIHZhciBTbGlkZXJQcmVsb2FkID0ge1xuICAgICAgbWl4aW5zOiBbTGF6eWxvYWRdLFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMubGF6eWxvYWQodGhpcy5zbGlkZXMsIHRoaXMuZ2V0QWRqYWNlbnRTbGlkZXMpO1xuICAgICAgfSB9O1xuXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbmVyIChwcmV2LCBuZXh0LCBkaXIsIF9yZWYpIHtsZXQgeyBjZW50ZXIsIGVhc2luZywgbGlzdCB9ID0gX3JlZjtcbiAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG5cbiAgICAgIGNvbnN0IGZyb20gPSBwcmV2ID9cbiAgICAgIGdldExlZnQocHJldiwgbGlzdCwgY2VudGVyKSA6XG4gICAgICBnZXRMZWZ0KG5leHQsIGxpc3QsIGNlbnRlcikgKyBkaW1lbnNpb25zJDEobmV4dCkud2lkdGggKiBkaXI7XG4gICAgICBjb25zdCB0byA9IG5leHQgP1xuICAgICAgZ2V0TGVmdChuZXh0LCBsaXN0LCBjZW50ZXIpIDpcbiAgICAgIGZyb20gKyBkaW1lbnNpb25zJDEocHJldikud2lkdGggKiBkaXIgKiAoaXNSdGwgPyAtMSA6IDEpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXIsXG5cbiAgICAgICAgc2hvdyhkdXJhdGlvbiwgcGVyY2VudCwgbGluZWFyKSB7aWYgKHBlcmNlbnQgPT09IHZvaWQgMCkge3BlcmNlbnQgPSAwO31cbiAgICAgICAgICBjb25zdCB0aW1pbmcgPSBsaW5lYXIgPyAnbGluZWFyJyA6IGVhc2luZztcbiAgICAgICAgICBkdXJhdGlvbiAtPSBNYXRoLnJvdW5kKGR1cmF0aW9uICogY2xhbXAocGVyY2VudCwgLTEsIDEpKTtcblxuICAgICAgICAgIHRoaXMudHJhbnNsYXRlKHBlcmNlbnQpO1xuXG4gICAgICAgICAgcGVyY2VudCA9IHByZXYgPyBwZXJjZW50IDogY2xhbXAocGVyY2VudCwgMCwgMSk7XG4gICAgICAgICAgdHJpZ2dlclVwZGF0ZSh0aGlzLmdldEl0ZW1JbigpLCAnaXRlbWluJywgeyBwZXJjZW50LCBkdXJhdGlvbiwgdGltaW5nLCBkaXIgfSk7XG4gICAgICAgICAgcHJldiAmJlxuICAgICAgICAgIHRyaWdnZXJVcGRhdGUodGhpcy5nZXRJdGVtSW4odHJ1ZSksICdpdGVtb3V0Jywge1xuICAgICAgICAgICAgcGVyY2VudDogMSAtIHBlcmNlbnQsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZyxcbiAgICAgICAgICAgIGRpciB9KTtcblxuXG4gICAgICAgICAgVHJhbnNpdGlvbi5zdGFydChcbiAgICAgICAgICBsaXN0LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLXRvICogKGlzUnRsID8gLTEgOiAxKSwgJ3B4JykgfSxcbiAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmcpLlxuICAgICAgICAgIHRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgbm9vcCk7XG5cbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwobGlzdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgY3NzKGxpc3QsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9yd2FyZChkdXJhdGlvbiwgcGVyY2VudCkge2lmIChwZXJjZW50ID09PSB2b2lkIDApIHtwZXJjZW50ID0gdGhpcy5wZXJjZW50KCk7fVxuICAgICAgICAgIFRyYW5zaXRpb24uY2FuY2VsKGxpc3QpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnNob3coZHVyYXRpb24sIHBlcmNlbnQsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50KSB7XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLmdldERpc3RhbmNlKCkgKiBkaXIgKiAoaXNSdGwgPyAtMSA6IDEpO1xuXG4gICAgICAgICAgY3NzKFxuICAgICAgICAgIGxpc3QsXG4gICAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICAgdHJhbnNsYXRlKFxuICAgICAgICAgIGNsYW1wKFxuICAgICAgICAgIC10byArIChkaXN0YW5jZSAtIGRpc3RhbmNlICogcGVyY2VudCksXG4gICAgICAgICAgLWdldFdpZHRoKGxpc3QpLFxuICAgICAgICAgIGRpbWVuc2lvbnMkMShsaXN0KS53aWR0aCkgKiAoXG4gICAgICAgICAgaXNSdGwgPyAtMSA6IDEpLFxuICAgICAgICAgICdweCcpKTtcblxuXG5cbiAgICAgICAgICBjb25zdCBhY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVzKCk7XG4gICAgICAgICAgY29uc3QgaXRlbUluID0gdGhpcy5nZXRJdGVtSW4oKTtcbiAgICAgICAgICBjb25zdCBpdGVtT3V0ID0gdGhpcy5nZXRJdGVtSW4odHJ1ZSk7XG5cbiAgICAgICAgICBwZXJjZW50ID0gcHJldiA/IGNsYW1wKHBlcmNlbnQsIC0xLCAxKSA6IDA7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHNsaWRlIG9mIGNoaWxkcmVuKGxpc3QpKSB7XG4gICAgICAgICAgICBjb25zdCBpc0FjdGl2ZSA9IGluY2x1ZGVzKGFjdGl2ZXMsIHNsaWRlKTtcbiAgICAgICAgICAgIGNvbnN0IGlzSW4gPSBzbGlkZSA9PT0gaXRlbUluO1xuICAgICAgICAgICAgY29uc3QgaXNPdXQgPSBzbGlkZSA9PT0gaXRlbU91dDtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZUluID1cbiAgICAgICAgICAgIGlzSW4gfHxcbiAgICAgICAgICAgICFpc091dCAmJiAoXG4gICAgICAgICAgICBpc0FjdGl2ZSB8fFxuICAgICAgICAgICAgZGlyICogKGlzUnRsID8gLTEgOiAxKSA9PT0gLTEgXlxuICAgICAgICAgICAgZ2V0RWxMZWZ0KHNsaWRlLCBsaXN0KSA+IGdldEVsTGVmdChwcmV2IHx8IG5leHQpKTtcblxuICAgICAgICAgICAgdHJpZ2dlclVwZGF0ZShzbGlkZSwgXCJpdGVtdHJhbnNsYXRlXCIgKyAodHJhbnNsYXRlSW4gPyAnaW4nIDogJ291dCcpLCB7XG4gICAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgICAgcGVyY2VudDogaXNPdXQgPyAxIC0gcGVyY2VudCA6IGlzSW4gPyBwZXJjZW50IDogaXNBY3RpdmUgPyAxIDogMCB9KTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyhcbiAgICAgICAgICAoY3NzKGxpc3QsICd0cmFuc2Zvcm0nKS5zcGxpdCgnLCcpWzRdICogKGlzUnRsID8gLTEgOiAxKSArIGZyb20pIC8gKHRvIC0gZnJvbSkpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGlzdGFuY2UoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRvIC0gZnJvbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SXRlbUluKG91dCkge2lmIChvdXQgPT09IHZvaWQgMCkge291dCA9IGZhbHNlO31cbiAgICAgICAgICBsZXQgYWN0aXZlcyA9IHRoaXMuZ2V0QWN0aXZlcygpO1xuICAgICAgICAgIGxldCBuZXh0QWN0aXZlcyA9IGluVmlldyhsaXN0LCBnZXRMZWZ0KG5leHQgfHwgcHJldiwgbGlzdCwgY2VudGVyKSk7XG5cbiAgICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gYWN0aXZlcztcbiAgICAgICAgICAgIGFjdGl2ZXMgPSBuZXh0QWN0aXZlcztcbiAgICAgICAgICAgIG5leHRBY3RpdmVzID0gdGVtcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV4dEFjdGl2ZXNbZmluZEluZGV4KG5leHRBY3RpdmVzLCAoZWwpID0+ICFpbmNsdWRlcyhhY3RpdmVzLCBlbCkpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBY3RpdmVzKCkge1xuICAgICAgICAgIHJldHVybiBpblZpZXcobGlzdCwgZ2V0TGVmdChwcmV2IHx8IG5leHQsIGxpc3QsIGNlbnRlcikpO1xuICAgICAgICB9IH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRMZWZ0KGVsLCBsaXN0LCBjZW50ZXIpIHtcbiAgICAgIGNvbnN0IGxlZnQgPSBnZXRFbExlZnQoZWwsIGxpc3QpO1xuXG4gICAgICByZXR1cm4gY2VudGVyID8gbGVmdCAtIGNlbnRlckVsKGVsLCBsaXN0KSA6IE1hdGgubWluKGxlZnQsIGdldE1heChsaXN0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TWF4KGxpc3QpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBnZXRXaWR0aChsaXN0KSAtIGRpbWVuc2lvbnMkMShsaXN0KS53aWR0aCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2lkdGgobGlzdCkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuKGxpc3QpLnJlZHVjZSgocmlnaHQsIGVsKSA9PiBkaW1lbnNpb25zJDEoZWwpLndpZHRoICsgcmlnaHQsIDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNlbnRlckVsKGVsLCBsaXN0KSB7XG4gICAgICByZXR1cm4gZGltZW5zaW9ucyQxKGxpc3QpLndpZHRoIC8gMiAtIGRpbWVuc2lvbnMkMShlbCkud2lkdGggLyAyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVsTGVmdChlbCwgbGlzdCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgZWwgJiZcbiAgICAgICAgKHBvc2l0aW9uKGVsKS5sZWZ0ICsgKGlzUnRsID8gZGltZW5zaW9ucyQxKGVsKS53aWR0aCAtIGRpbWVuc2lvbnMkMShsaXN0KS53aWR0aCA6IDApKSAqIChcbiAgICAgICAgaXNSdGwgPyAtMSA6IDEpIHx8XG4gICAgICAgIDApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5WaWV3KGxpc3QsIGxpc3RMZWZ0KSB7XG4gICAgICBsaXN0TGVmdCAtPSAxO1xuICAgICAgY29uc3QgbGlzdFdpZHRoID0gZGltZW5zaW9ucyQxKGxpc3QpLndpZHRoO1xuICAgICAgY29uc3QgbGlzdFJpZ2h0ID0gbGlzdExlZnQgKyBsaXN0V2lkdGggKyAyO1xuXG4gICAgICByZXR1cm4gY2hpbGRyZW4obGlzdCkuZmlsdGVyKChzbGlkZSkgPT4ge1xuICAgICAgICBjb25zdCBzbGlkZUxlZnQgPSBnZXRFbExlZnQoc2xpZGUsIGxpc3QpO1xuICAgICAgICBjb25zdCBzbGlkZVJpZ2h0ID0gc2xpZGVMZWZ0ICsgTWF0aC5taW4oZGltZW5zaW9ucyQxKHNsaWRlKS53aWR0aCwgbGlzdFdpZHRoKTtcblxuICAgICAgICByZXR1cm4gc2xpZGVMZWZ0ID49IGxpc3RMZWZ0ICYmIHNsaWRlUmlnaHQgPD0gbGlzdFJpZ2h0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlclVwZGF0ZShlbCwgdHlwZSwgZGF0YSkge1xuICAgICAgdHJpZ2dlcihlbCwgY3JlYXRlRXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgdmFyIHNsaWRlciA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBTbGlkZXIsIFNsaWRlclJlYWN0aXZlLCBTbGlkZXJQcmVsb2FkXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2VudGVyOiBCb29sZWFuLFxuICAgICAgICBzZXRzOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBjZW50ZXI6IGZhbHNlLFxuICAgICAgICBzZXRzOiBmYWxzZSxcbiAgICAgICAgYXR0ckl0ZW06ICd1ay1zbGlkZXItaXRlbScsXG4gICAgICAgIHNlbExpc3Q6ICcudWstc2xpZGVyLWl0ZW1zJyxcbiAgICAgICAgc2VsTmF2OiAnLnVrLXNsaWRlci1uYXYnLFxuICAgICAgICBjbHNDb250YWluZXI6ICd1ay1zbGlkZXItY29udGFpbmVyJyxcbiAgICAgICAgVHJhbnNpdGlvbmVyIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgYXZnV2lkdGgoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFdpZHRoKHRoaXMubGlzdCkgLyB0aGlzLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pdGUoX3JlZikge2xldCB7IGZpbml0ZSB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZmluaXRlIHx8XG4gICAgICAgICAgICBNYXRoLmNlaWwoZ2V0V2lkdGgodGhpcy5saXN0KSkgPFxuICAgICAgICAgICAgTWF0aC50cnVuYyhkaW1lbnNpb25zJDEodGhpcy5saXN0KS53aWR0aCArIGdldE1heEVsV2lkdGgodGhpcy5saXN0KSArIHRoaXMuY2VudGVyKSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBtYXhJbmRleCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZmluaXRlIHx8IHRoaXMuY2VudGVyICYmICF0aGlzLnNldHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuY2VudGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdCh0aGlzLnNldHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBsZnQgPSAwO1xuICAgICAgICAgIGNvbnN0IG1heCA9IGdldE1heCh0aGlzLmxpc3QpO1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gZmluZEluZGV4KHRoaXMuc2xpZGVzLCAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChsZnQgPj0gbWF4KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZnQgKz0gZGltZW5zaW9ucyQxKGVsKS53aWR0aDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiB+aW5kZXggPyBpbmRleCA6IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRzKF9yZWYyKSB7bGV0IHsgc2V0czogZW5hYmxlZCB9ID0gX3JlZjI7XG4gICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgICAgIGNvbnN0IHNldHMgPSBbXTtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IGRpbWVuc2lvbnMkMSh0aGlzLmxpc3QpLndpZHRoO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zbGlkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlV2lkdGggPSBkaW1lbnNpb25zJDEodGhpcy5zbGlkZXNbaV0pLndpZHRoO1xuXG4gICAgICAgICAgICBpZiAobGVmdCArIHNsaWRlV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2VudGVyKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbGVmdCA8IHdpZHRoIC8gMiAmJlxuICAgICAgICAgICAgICBsZWZ0ICsgc2xpZGVXaWR0aCArIGRpbWVuc2lvbnMkMSh0aGlzLnNsaWRlc1sraSArIDFdKS53aWR0aCAvIDIgPiB3aWR0aCAvIDIpXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZXRzLnB1c2goK2kpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSB3aWR0aCAvIDIgLSBzbGlkZVdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICAgIHNldHMucHVzaChNYXRoLm1pbigraSwgdGhpcy5tYXhJbmRleCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZWZ0ICs9IHNsaWRlV2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0cztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNpdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNlbnRlcjogdGhpcy5jZW50ZXIsXG4gICAgICAgICAgICBsaXN0OiB0aGlzLmxpc3QgfTtcblxuICAgICAgICB9IH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNDb250YWluZXIsICEkKFwiLlwiICsgdGhpcy5jbHNDb250YWluZXIsIHRoaXMuJGVsKSk7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgd3JpdGUoKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLm5hdkl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRvTnVtYmVyKGRhdGEoZWwsIHRoaXMuYXR0ckl0ZW0pKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgZWwuaGlkZGVuID1cbiAgICAgICAgICAgICAgIXRoaXMubWF4SW5kZXggfHxcbiAgICAgICAgICAgICAgaW5kZXggPiB0aGlzLm1heEluZGV4IHx8XG4gICAgICAgICAgICAgIHRoaXMuc2V0cyAmJiAhaW5jbHVkZXModGhpcy5zZXRzLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMubGVuZ3RoICYmICF0aGlzLmRyYWdnaW5nICYmICF0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5yZW9yZGVyKCk7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2xhdGUoMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVDbGFzc2VzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0sXG5cblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGJlZm9yZWl0ZW1zaG93KGUpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIXRoaXMuZHJhZ2dpbmcgJiZcbiAgICAgICAgICB0aGlzLnNldHMgJiZcbiAgICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA8IDIgJiZcbiAgICAgICAgICAhaW5jbHVkZXModGhpcy5zZXRzLCB0aGlzLmluZGV4KSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5nZXRWYWxpZEluZGV4KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKFxuICAgICAgICAgIHRoaXMuaW5kZXggLVxuICAgICAgICAgIHRoaXMucHJldkluZGV4ICsgKFxuICAgICAgICAgIHRoaXMuZGlyID4gMCAmJiB0aGlzLmluZGV4IDwgdGhpcy5wcmV2SW5kZXggfHxcbiAgICAgICAgICB0aGlzLmRpciA8IDAgJiYgdGhpcy5pbmRleCA+IHRoaXMucHJldkluZGV4ID9cbiAgICAgICAgICAodGhpcy5tYXhJbmRleCArIDEpICogdGhpcy5kaXIgOlxuICAgICAgICAgIDApKTtcblxuXG4gICAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nICYmIGRpZmYgPiAxKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmY7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnNwbGljZSgxLCAwLCB0aGlzLmRpciA+IDAgPyAnbmV4dCcgOiAncHJldmlvdXMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGluZGV4ID1cbiAgICAgICAgICB0aGlzLmRpciA8IDAgfHwgIXRoaXMuc2xpZGVzW3RoaXMucHJldkluZGV4XSA/IHRoaXMuaW5kZXggOiB0aGlzLnByZXZJbmRleDtcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uID1cbiAgICAgICAgICBzcGVlZFVwKHRoaXMuYXZnV2lkdGggLyB0aGlzLnZlbG9jaXR5KSAqIChcbiAgICAgICAgICBkaW1lbnNpb25zJDEodGhpcy5zbGlkZXNbaW5kZXhdKS53aWR0aCAvIHRoaXMuYXZnV2lkdGgpO1xuXG4gICAgICAgICAgdGhpcy5yZW9yZGVyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXRlbXNob3coKSB7XG4gICAgICAgICAgaWYgKH50aGlzLnByZXZJbmRleCkge1xuICAgICAgICAgICAgYWRkQ2xhc3ModGhpcy5fZ2V0VHJhbnNpdGlvbmVyKCkuZ2V0SXRlbUluKCksIHRoaXMuY2xzQWN0aXZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXRlbXNob3duKCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlQWN0aXZlQ2xhc3NlcygpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICByZW9yZGVyKCkge1xuICAgICAgICAgIGlmICh0aGlzLmZpbml0ZSkge1xuICAgICAgICAgICAgY3NzKHRoaXMuc2xpZGVzLCAnb3JkZXInLCAnJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRpciA+IDAgJiYgdGhpcy5zbGlkZXNbdGhpcy5wcmV2SW5kZXhdID8gdGhpcy5wcmV2SW5kZXggOiB0aGlzLmluZGV4O1xuXG4gICAgICAgICAgdGhpcy5zbGlkZXMuZm9yRWFjaCgoc2xpZGUsIGkpID0+XG4gICAgICAgICAgY3NzKFxuICAgICAgICAgIHNsaWRlLFxuICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgdGhpcy5kaXIgPiAwICYmIGkgPCBpbmRleCA/IDEgOiB0aGlzLmRpciA8IDAgJiYgaSA+PSB0aGlzLmluZGV4ID8gLTEgOiAnJykpO1xuXG5cblxuICAgICAgICAgIGlmICghdGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5zbGlkZXNbaW5kZXhdO1xuICAgICAgICAgIGxldCB3aWR0aCA9IGRpbWVuc2lvbnMkMSh0aGlzLmxpc3QpLndpZHRoIC8gMiAtIGRpbWVuc2lvbnMkMShuZXh0KS53aWR0aCAvIDI7XG4gICAgICAgICAgbGV0IGogPSAwO1xuXG4gICAgICAgICAgd2hpbGUgKHdpZHRoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc2xpZGVJbmRleCA9IHRoaXMuZ2V0SW5kZXgoLS1qICsgaW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlID0gdGhpcy5zbGlkZXNbc2xpZGVJbmRleF07XG5cbiAgICAgICAgICAgIGNzcyhzbGlkZSwgJ29yZGVyJywgc2xpZGVJbmRleCA+IGluZGV4ID8gLTIgOiAtMSk7XG4gICAgICAgICAgICB3aWR0aCAtPSBkaW1lbnNpb25zJDEoc2xpZGUpLndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVBY3RpdmVDbGFzc2VzKCkge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZXMgPSB0aGlzLl9nZXRUcmFuc2l0aW9uZXIodGhpcy5pbmRleCkuZ2V0QWN0aXZlcygpO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZUNsYXNzZXMgPSBbXG4gICAgICAgICAgdGhpcy5jbHNBY3RpdmUsXG4gICAgICAgICAgKCF0aGlzLnNldHMgfHwgaW5jbHVkZXModGhpcy5zZXRzLCB0b0Zsb2F0KHRoaXMuaW5kZXgpKSkgJiYgdGhpcy5jbHNBY3RpdmF0ZWQgfHxcbiAgICAgICAgICAnJ107XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHNsaWRlIG9mIHRoaXMuc2xpZGVzKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzbGlkZSwgYWN0aXZlQ2xhc3NlcywgaW5jbHVkZXMoYWN0aXZlcywgc2xpZGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VmFsaWRJbmRleChpbmRleCwgcHJldkluZGV4KSB7aWYgKGluZGV4ID09PSB2b2lkIDApIHtpbmRleCA9IHRoaXMuaW5kZXg7fWlmIChwcmV2SW5kZXggPT09IHZvaWQgMCkge3ByZXZJbmRleCA9IHRoaXMucHJldkluZGV4O31cbiAgICAgICAgICBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoaW5kZXgsIHByZXZJbmRleCk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuc2V0cykge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBwcmV2O1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVzKHRoaXMuc2V0cywgaW5kZXgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldiA9IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmdldEluZGV4KGluZGV4ICsgdGhpcy5kaXIsIHByZXZJbmRleCk7XG4gICAgICAgICAgfSB3aGlsZSAoaW5kZXggIT09IHByZXYpO1xuXG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEFkamFjZW50U2xpZGVzKCkge1xuICAgICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IGRpbWVuc2lvbnMkMSh0aGlzLmxpc3QpO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSAtd2lkdGg7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSB3aWR0aCAqIDI7XG4gICAgICAgICAgY29uc3Qgc2xpZGVXaWR0aCA9IGRpbWVuc2lvbnMkMSh0aGlzLnNsaWRlc1t0aGlzLmluZGV4XSkud2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2xpZGVMZWZ0ID0gdGhpcy5jZW50ZXIgPyB3aWR0aCAvIDIgLSBzbGlkZVdpZHRoIC8gMiA6IDA7XG4gICAgICAgICAgY29uc3Qgc2xpZGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBbLTEsIDFdKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudExlZnQgPSBzbGlkZUxlZnQgKyAoaSA+IDAgPyBzbGlkZVdpZHRoIDogMCk7XG4gICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGNvbnN0IHNsaWRlID0gdGhpcy5zbGlkZXNbdGhpcy5nZXRJbmRleCh0aGlzLmluZGV4ICsgaSArIGorKyAqIGkpXTtcbiAgICAgICAgICAgICAgY3VycmVudExlZnQgKz0gZGltZW5zaW9ucyQxKHNsaWRlKS53aWR0aCAqIGk7XG4gICAgICAgICAgICAgIHNsaWRlcy5hZGQoc2xpZGUpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5zbGlkZXMubGVuZ3RoID4gaiAmJiBjdXJyZW50TGVmdCA+IGxlZnQgJiYgY3VycmVudExlZnQgPCByaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHNsaWRlcyk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGdldE1heEVsV2lkdGgobGlzdCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIC4uLmNoaWxkcmVuKGxpc3QpLm1hcCgoZWwpID0+IGRpbWVuc2lvbnMkMShlbCkud2lkdGgpKTtcbiAgICB9XG5cbiAgICB2YXIgc2xpZGVyUGFyYWxsYXggPSB7XG4gICAgICBtaXhpbnM6IFtQYXJhbGxheF0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc2VsSXRlbTogJyFsaScgfSxcblxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLml0ZW0gPSBxdWVyeSh0aGlzLnNlbEl0ZW0sIHRoaXMuJGVsKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5pdGVtID0gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnaXRlbWluIGl0ZW1vdXQnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKF9yZWYpIHtsZXQgeyB0eXBlLCBkZXRhaWw6IHsgcGVyY2VudCwgZHVyYXRpb24sIHRpbWluZywgZGlyIH0gfSA9IF9yZWY7XG4gICAgICAgICAgZmFzdGRvbS5yZWFkKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzRnJvbSA9IHRoaXMuZ2V0Q3NzKGdldEN1cnJlbnRQZXJjZW50KHR5cGUsIGRpciwgcGVyY2VudCkpO1xuICAgICAgICAgICAgY29uc3QgcHJvcHNUbyA9IHRoaXMuZ2V0Q3NzKGlzSW4odHlwZSkgPyAwLjUgOiBkaXIgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgZmFzdGRvbS53cml0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgcHJvcHNGcm9tKTtcbiAgICAgICAgICAgICAgVHJhbnNpdGlvbi5zdGFydCh0aGlzLiRlbCwgcHJvcHNUbywgZHVyYXRpb24sIHRpbWluZykuY2F0Y2gobm9vcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RyYW5zaXRpb25jYW5jZWxlZCB0cmFuc2l0aW9uZW5kJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLml0ZW07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBUcmFuc2l0aW9uLmNhbmNlbCh0aGlzLiRlbCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdpdGVtdHJhbnNsYXRlaW4gaXRlbXRyYW5zbGF0ZW91dCcsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoX3JlZjIpIHtsZXQgeyB0eXBlLCBkZXRhaWw6IHsgcGVyY2VudCwgZGlyIH0gfSA9IF9yZWYyO1xuICAgICAgICAgIGZhc3Rkb20ucmVhZCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuZ2V0Q3NzKGdldEN1cnJlbnRQZXJjZW50KHR5cGUsIGRpciwgcGVyY2VudCkpO1xuICAgICAgICAgICAgZmFzdGRvbS53cml0ZSgoKSA9PiBjc3ModGhpcy4kZWwsIHByb3BzKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gfV0gfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIGlzSW4odHlwZSkge1xuICAgICAgcmV0dXJuIGVuZHNXaXRoKHR5cGUsICdpbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRQZXJjZW50KHR5cGUsIGRpciwgcGVyY2VudCkge1xuICAgICAgcGVyY2VudCAvPSAyO1xuXG4gICAgICByZXR1cm4gaXNJbih0eXBlKSBeIGRpciA8IDAgPyBwZXJjZW50IDogMSAtIHBlcmNlbnQ7XG4gICAgfVxuXG4gICAgdmFyIEFuaW1hdGlvbnMgPSB7XG4gICAgICAuLi5BbmltYXRpb25zJDIsXG4gICAgICBmYWRlOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDAsIHpJbmRleDogMCB9LCB7IHpJbmRleDogLTEgfV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyY2VudChjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIDEgLSBjc3MoY3VycmVudCwgJ29wYWNpdHknKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCkge1xuICAgICAgICAgIHJldHVybiBbeyBvcGFjaXR5OiAxIC0gcGVyY2VudCwgekluZGV4OiAwIH0sIHsgekluZGV4OiAtMSB9XTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogc2NhbGUzZCgxICsgMC41KSwgekluZGV4OiAwIH0sIHsgekluZGV4OiAtMSB9XTtcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gMSAtIGNzcyhjdXJyZW50LCAnb3BhY2l0eScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7IG9wYWNpdHk6IDEgLSBwZXJjZW50LCB0cmFuc2Zvcm06IHNjYWxlM2QoMSArIDAuNSAqIHBlcmNlbnQpLCB6SW5kZXg6IDAgfSxcbiAgICAgICAgICB7IHpJbmRleDogLTEgfV07XG5cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHB1bGw6IHtcbiAgICAgICAgc2hvdyhkaXIpIHtcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/XG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMzApLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgpLCB6SW5kZXg6IDAgfV0gOlxuXG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTEwMCksIHpJbmRleDogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoKSwgekluZGV4OiAtMSB9XTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoY3VycmVudCwgbmV4dCwgZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIGRpciA8IDAgPyAxIC0gdHJhbnNsYXRlZChuZXh0KSA6IHRyYW5zbGF0ZWQoY3VycmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQsIGRpcikge1xuICAgICAgICAgIHJldHVybiBkaXIgPCAwID9cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgzMCAqIHBlcmNlbnQpLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMTAwICogKDEgLSBwZXJjZW50KSksIHpJbmRleDogMCB9XSA6XG5cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtcGVyY2VudCAqIDEwMCksIHpJbmRleDogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMzAgKiAoMSAtIHBlcmNlbnQpKSwgekluZGV4OiAtMSB9XTtcblxuICAgICAgICB9IH0sXG5cblxuICAgICAgcHVzaDoge1xuICAgICAgICBzaG93KGRpcikge1xuICAgICAgICAgIHJldHVybiBkaXIgPCAwID9cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgxMDApLCB6SW5kZXg6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKCksIHpJbmRleDogLTEgfV0gOlxuXG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTMwKSwgekluZGV4OiAtMSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoKSwgekluZGV4OiAwIH1dO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyY2VudChjdXJyZW50LCBuZXh0LCBkaXIpIHtcbiAgICAgICAgICByZXR1cm4gZGlyID4gMCA/IDEgLSB0cmFuc2xhdGVkKG5leHQpIDogdHJhbnNsYXRlZChjdXJyZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCwgZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIGRpciA8IDAgP1xuICAgICAgICAgIFtcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKHBlcmNlbnQgKiAxMDApLCB6SW5kZXg6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC0zMCAqICgxIC0gcGVyY2VudCkpLCB6SW5kZXg6IC0xIH1dIDpcblxuICAgICAgICAgIFtcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC0zMCAqIHBlcmNlbnQpLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgxMDAgKiAoMSAtIHBlcmNlbnQpKSwgekluZGV4OiAwIH1dO1xuXG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIHNsaWRlc2hvdyA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBTbGlkZXNob3csIFNsaWRlclJlYWN0aXZlLCBTbGlkZXJQcmVsb2FkXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgcmF0aW86IFN0cmluZyxcbiAgICAgICAgbWluSGVpZ2h0OiBOdW1iZXIsXG4gICAgICAgIG1heEhlaWdodDogTnVtYmVyIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICByYXRpbzogJzE2OjknLFxuICAgICAgICBtaW5IZWlnaHQ6IGZhbHNlLFxuICAgICAgICBtYXhIZWlnaHQ6IGZhbHNlLFxuICAgICAgICBzZWxMaXN0OiAnLnVrLXNsaWRlc2hvdy1pdGVtcycsXG4gICAgICAgIGF0dHJJdGVtOiAndWstc2xpZGVzaG93LWl0ZW0nLFxuICAgICAgICBzZWxOYXY6ICcudWstc2xpZGVzaG93LW5hdicsXG4gICAgICAgIEFuaW1hdGlvbnMgfSxcblxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMubGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnJhdGlvLnNwbGl0KCc6JykubWFwKE51bWJlcik7XG5cbiAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKiB0aGlzLmxpc3Qub2Zmc2V0V2lkdGggLyB3aWR0aCB8fCAwO1xuXG4gICAgICAgICAgaWYgKHRoaXMubWluSGVpZ2h0KSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCh0aGlzLm1pbkhlaWdodCwgaGVpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5tYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IGhlaWdodDogaGVpZ2h0IC0gYm94TW9kZWxBZGp1c3QodGhpcy5saXN0LCAnaGVpZ2h0JywgJ2NvbnRlbnQtYm94JykgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmKSB7bGV0IHsgaGVpZ2h0IH0gPSBfcmVmO1xuICAgICAgICAgIGhlaWdodCA+IDAgJiYgY3NzKHRoaXMubGlzdCwgJ21pbkhlaWdodCcsIGhlaWdodCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBnZXRBZGphY2VudFNsaWRlcygpIHtcbiAgICAgICAgICByZXR1cm4gWzEsIC0xXS5tYXAoKGkpID0+IHRoaXMuc2xpZGVzW3RoaXMuZ2V0SW5kZXgodGhpcy5pbmRleCArIGkpXSk7XG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIHNvcnRhYmxlID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIEFuaW1hdGVdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBncm91cDogU3RyaW5nLFxuICAgICAgICB0aHJlc2hvbGQ6IE51bWJlcixcbiAgICAgICAgY2xzSXRlbTogU3RyaW5nLFxuICAgICAgICBjbHNQbGFjZWhvbGRlcjogU3RyaW5nLFxuICAgICAgICBjbHNEcmFnOiBTdHJpbmcsXG4gICAgICAgIGNsc0RyYWdTdGF0ZTogU3RyaW5nLFxuICAgICAgICBjbHNCYXNlOiBTdHJpbmcsXG4gICAgICAgIGNsc05vRHJhZzogU3RyaW5nLFxuICAgICAgICBjbHNFbXB0eTogU3RyaW5nLFxuICAgICAgICBjbHNDdXN0b206IFN0cmluZyxcbiAgICAgICAgaGFuZGxlOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGdyb3VwOiBmYWxzZSxcbiAgICAgICAgdGhyZXNob2xkOiA1LFxuICAgICAgICBjbHNJdGVtOiAndWstc29ydGFibGUtaXRlbScsXG4gICAgICAgIGNsc1BsYWNlaG9sZGVyOiAndWstc29ydGFibGUtcGxhY2Vob2xkZXInLFxuICAgICAgICBjbHNEcmFnOiAndWstc29ydGFibGUtZHJhZycsXG4gICAgICAgIGNsc0RyYWdTdGF0ZTogJ3VrLWRyYWcnLFxuICAgICAgICBjbHNCYXNlOiAndWstc29ydGFibGUnLFxuICAgICAgICBjbHNOb0RyYWc6ICd1ay1zb3J0YWJsZS1ub2RyYWcnLFxuICAgICAgICBjbHNFbXB0eTogJ3VrLXNvcnRhYmxlLWVtcHR5JyxcbiAgICAgICAgY2xzQ3VzdG9tOiAnJyxcbiAgICAgICAgaGFuZGxlOiBmYWxzZSxcbiAgICAgICAgcG9zOiB7fSB9LFxuXG5cbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsnaW5pdCcsICdzdGFydCcsICdtb3ZlJywgJ2VuZCddKSB7XG4gICAgICAgICAgY29uc3QgZm4gPSB0aGlzW2tleV07XG4gICAgICAgICAgdGhpc1trZXldID0gKGUpID0+IHtcbiAgICAgICAgICAgIGFzc2lnbih0aGlzLnBvcywgZ2V0RXZlbnRQb3MoZSkpO1xuICAgICAgICAgICAgZm4oZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIG5hbWU6IHBvaW50ZXJEb3duJDEsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBoYW5kbGVyOiAnaW5pdCcgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICB0YXJnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLiRlbC50Qm9kaWVzIHx8IFt0aGlzLiRlbF0pWzBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGl0ZW1zKCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbih0aGlzLnRhcmdldCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNFbXB0eToge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0VtcHR5KHRoaXMuaXRlbXMpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChlbXB0eSkge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3ModGhpcy50YXJnZXQsIHRoaXMuY2xzRW1wdHksIGVtcHR5KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0sXG5cblxuICAgICAgICBoYW5kbGVzOiB7XG4gICAgICAgICAgZ2V0KF9yZWYsIGVsKSB7bGV0IHsgaGFuZGxlIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZSA/ICQkKGhhbmRsZSwgZWwpIDogdGhpcy5pdGVtcztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goaGFuZGxlcywgcHJldikge1xuICAgICAgICAgICAgY3NzKHByZXYsIHsgdG91Y2hBY3Rpb246ICcnLCB1c2VyU2VsZWN0OiAnJyB9KTtcbiAgICAgICAgICAgIGNzcyhoYW5kbGVzLCB7IHRvdWNoQWN0aW9uOiBoYXNUb3VjaCA/ICdub25lJyA6ICcnLCB1c2VyU2VsZWN0OiAnbm9uZScgfSk7IC8vIHRvdWNoQWN0aW9uIHNldCB0byAnbm9uZScgY2F1c2VzIGEgcGVyZm9ybWFuY2UgZHJvcCBpbiBDaHJvbWUgODBcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0gfSxcblxuXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICB3cml0ZShkYXRhKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmRyYWcgfHwgIXBhcmVudCh0aGlzLnBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHBvczogeyB4LCB5IH0sXG4gICAgICAgICAgICBvcmlnaW46IHsgb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0IH0sXG4gICAgICAgICAgICBwbGFjZWhvbGRlciB9ID1cbiAgICAgICAgICB0aGlzO1xuXG4gICAgICAgICAgY3NzKHRoaXMuZHJhZywge1xuICAgICAgICAgICAgdG9wOiB5IC0gb2Zmc2V0VG9wLFxuICAgICAgICAgICAgbGVmdDogeCAtIG9mZnNldExlZnQgfSk7XG5cblxuICAgICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5nZXRTb3J0YWJsZShkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpKTtcblxuICAgICAgICAgIGlmICghc29ydGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7IGl0ZW1zIH0gPSBzb3J0YWJsZTtcblxuICAgICAgICAgIGlmIChpdGVtcy5zb21lKFRyYW5zaXRpb24uaW5Qcm9ncmVzcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBmaW5kVGFyZ2V0KGl0ZW1zLCB7IHgsIHkgfSk7XG5cbiAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoICYmICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gcGxhY2Vob2xkZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLmdldFNvcnRhYmxlKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICBjb25zdCBpbnNlcnRUYXJnZXQgPSBmaW5kSW5zZXJ0VGFyZ2V0KFxuICAgICAgICAgIHNvcnRhYmxlLnRhcmdldCxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgICAgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHNvcnRhYmxlID09PSBwcmV2aW91cyAmJiBkYXRhLm1vdmVkICE9PSB0YXJnZXQpO1xuXG5cbiAgICAgICAgICBpZiAoaW5zZXJ0VGFyZ2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnNlcnRUYXJnZXQgJiYgcGxhY2Vob2xkZXIgPT09IGluc2VydFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzb3J0YWJsZSAhPT0gcHJldmlvdXMpIHtcbiAgICAgICAgICAgIHByZXZpb3VzLnJlbW92ZShwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICBkYXRhLm1vdmVkID0gdGFyZ2V0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgZGF0YS5tb3ZlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzb3J0YWJsZS5pbnNlcnQocGxhY2Vob2xkZXIsIGluc2VydFRhcmdldCk7XG5cbiAgICAgICAgICB0aGlzLnRvdWNoZWQuYWRkKHNvcnRhYmxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsnbW92ZSddIH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBpbml0KGUpIHtcbiAgICAgICAgICBjb25zdCB7IHRhcmdldCwgYnV0dG9uLCBkZWZhdWx0UHJldmVudGVkIH0gPSBlO1xuICAgICAgICAgIGNvbnN0IFtwbGFjZWhvbGRlcl0gPSB0aGlzLml0ZW1zLmZpbHRlcigoZWwpID0+IHdpdGhpbih0YXJnZXQsIGVsKSk7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIXBsYWNlaG9sZGVyIHx8XG4gICAgICAgICAgZGVmYXVsdFByZXZlbnRlZCB8fFxuICAgICAgICAgIGJ1dHRvbiA+IDAgfHxcbiAgICAgICAgICBpc0lucHV0KHRhcmdldCkgfHxcbiAgICAgICAgICB3aXRoaW4odGFyZ2V0LCBcIi5cIiArIHRoaXMuY2xzTm9EcmFnKSB8fFxuICAgICAgICAgIHRoaXMuaGFuZGxlICYmICF3aXRoaW4odGFyZ2V0LCB0aGlzLmhhbmRsZSkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIHRoaXMudG91Y2hlZCA9IG5ldyBTZXQoW3RoaXNdKTtcbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgdGhpcy5vcmlnaW4gPSB7IHRhcmdldCwgaW5kZXg6IGluZGV4KHBsYWNlaG9sZGVyKSwgLi4udGhpcy5wb3MgfTtcblxuICAgICAgICAgIG9uKGRvY3VtZW50LCBwb2ludGVyTW92ZSQxLCB0aGlzLm1vdmUpO1xuICAgICAgICAgIG9uKGRvY3VtZW50LCBwb2ludGVyVXAkMSwgdGhpcy5lbmQpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnQoZSkge1xuICAgICAgICAgIHRoaXMuZHJhZyA9IGFwcGVuZERyYWcodGhpcy4kY29udGFpbmVyLCB0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgICBjb25zdCB7IGxlZnQsIHRvcCB9ID0gdGhpcy5wbGFjZWhvbGRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBhc3NpZ24odGhpcy5vcmlnaW4sIHsgb2Zmc2V0TGVmdDogdGhpcy5wb3MueCAtIGxlZnQsIG9mZnNldFRvcDogdGhpcy5wb3MueSAtIHRvcCB9KTtcblxuICAgICAgICAgIGFkZENsYXNzKHRoaXMuZHJhZywgdGhpcy5jbHNEcmFnLCB0aGlzLmNsc0N1c3RvbSk7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy5wbGFjZWhvbGRlciwgdGhpcy5jbHNQbGFjZWhvbGRlcik7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy5pdGVtcywgdGhpcy5jbHNJdGVtKTtcbiAgICAgICAgICBhZGRDbGFzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuY2xzRHJhZ1N0YXRlKTtcblxuICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdzdGFydCcsIFt0aGlzLCB0aGlzLnBsYWNlaG9sZGVyXSk7XG5cbiAgICAgICAgICB0cmFja1Njcm9sbCh0aGlzLnBvcyk7XG5cbiAgICAgICAgICB0aGlzLm1vdmUoZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW92ZShlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZHJhZykge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnbW92ZScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgTWF0aC5hYnModGhpcy5wb3MueCAtIHRoaXMub3JpZ2luLngpID4gdGhpcy50aHJlc2hvbGQgfHxcbiAgICAgICAgICBNYXRoLmFicyh0aGlzLnBvcy55IC0gdGhpcy5vcmlnaW4ueSkgPiB0aGlzLnRocmVzaG9sZClcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgb2ZmKGRvY3VtZW50LCBwb2ludGVyTW92ZSQxLCB0aGlzLm1vdmUpO1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgcG9pbnRlclVwJDEsIHRoaXMuZW5kKTtcblxuICAgICAgICAgIGlmICghdGhpcy5kcmFnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdW50cmFja1Njcm9sbCgpO1xuXG4gICAgICAgICAgY29uc3Qgc29ydGFibGUgPSB0aGlzLmdldFNvcnRhYmxlKHRoaXMucGxhY2Vob2xkZXIpO1xuXG4gICAgICAgICAgaWYgKHRoaXMgPT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcmlnaW4uaW5kZXggIT09IGluZGV4KHRoaXMucGxhY2Vob2xkZXIpKSB7XG4gICAgICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdtb3ZlZCcsIFt0aGlzLCB0aGlzLnBsYWNlaG9sZGVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyaWdnZXIoc29ydGFibGUuJGVsLCAnYWRkZWQnLCBbc29ydGFibGUsIHRoaXMucGxhY2Vob2xkZXJdKTtcbiAgICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdyZW1vdmVkJywgW3RoaXMsIHRoaXMucGxhY2Vob2xkZXJdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnc3RvcCcsIFt0aGlzLCB0aGlzLnBsYWNlaG9sZGVyXSk7XG5cbiAgICAgICAgICByZW1vdmUkMSh0aGlzLmRyYWcpO1xuICAgICAgICAgIHRoaXMuZHJhZyA9IG51bGw7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHsgY2xzUGxhY2Vob2xkZXIsIGNsc0l0ZW0gfSBvZiB0aGlzLnRvdWNoZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc29ydGFibGUgb2YgdGhpcy50b3VjaGVkKSB7XG4gICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNvcnRhYmxlLml0ZW1zLCBjbHNQbGFjZWhvbGRlciwgY2xzSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudG91Y2hlZCA9IG51bGw7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLmNsc0RyYWdTdGF0ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5zZXJ0KGVsZW1lbnQsIHRhcmdldCkge1xuICAgICAgICAgIGFkZENsYXNzKHRoaXMuaXRlbXMsIHRoaXMuY2xzSXRlbSk7XG5cbiAgICAgICAgICBjb25zdCBpbnNlcnQgPSAoKSA9PiB0YXJnZXQgPyBiZWZvcmUodGFyZ2V0LCBlbGVtZW50KSA6IGFwcGVuZCh0aGlzLnRhcmdldCwgZWxlbWVudCk7XG5cbiAgICAgICAgICB0aGlzLmFuaW1hdGUoaW5zZXJ0KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmUoZWxlbWVudCkge1xuICAgICAgICAgIGlmICghd2l0aGluKGVsZW1lbnQsIHRoaXMudGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYW5pbWF0ZSgoKSA9PiByZW1vdmUkMShlbGVtZW50KSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U29ydGFibGUoZWxlbWVudCkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy4kZ2V0Q29tcG9uZW50KGVsZW1lbnQsICdzb3J0YWJsZScpO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBzb3J0YWJsZSAmJiAoXG4gICAgICAgICAgICBzb3J0YWJsZSA9PT0gdGhpcyB8fCB0aGlzLmdyb3VwICE9PSBmYWxzZSAmJiBzb3J0YWJsZS5ncm91cCA9PT0gdGhpcy5ncm91cCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybiBzb3J0YWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChlbGVtZW50ID0gcGFyZW50KGVsZW1lbnQpKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgbGV0IHRyYWNrVGltZXI7XG4gICAgZnVuY3Rpb24gdHJhY2tTY3JvbGwocG9zKSB7XG4gICAgICBsZXQgbGFzdCA9IERhdGUubm93KCk7XG4gICAgICB0cmFja1RpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBsZXQgeyB4LCB5IH0gPSBwb3M7XG4gICAgICAgIHkgKz0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3A7XG5cbiAgICAgICAgY29uc3QgZGlzdCA9IChEYXRlLm5vdygpIC0gbGFzdCkgKiAwLjM7XG4gICAgICAgIGxhc3QgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHNjcm9sbFBhcmVudHMoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCBwb3MueSksIC9hdXRvfHNjcm9sbC8pLlxuICAgICAgICByZXZlcnNlKCkuXG4gICAgICAgIHNvbWUoKHNjcm9sbEVsKSA9PiB7XG4gICAgICAgICAgbGV0IHsgc2Nyb2xsVG9wOiBzY3JvbGwsIHNjcm9sbEhlaWdodCB9ID0gc2Nyb2xsRWw7XG5cbiAgICAgICAgICBjb25zdCB7IHRvcCwgYm90dG9tLCBoZWlnaHQgfSA9IG9mZnNldFZpZXdwb3J0KHNjcm9sbEVsKTtcblxuICAgICAgICAgIGlmICh0b3AgPCB5ICYmIHRvcCArIDM1ID4geSkge1xuICAgICAgICAgICAgc2Nyb2xsIC09IGRpc3Q7XG4gICAgICAgICAgfSBlbHNlIGlmIChib3R0b20gPiB5ICYmIGJvdHRvbSAtIDM1IDwgeSkge1xuICAgICAgICAgICAgc2Nyb2xsICs9IGRpc3Q7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsID4gMCAmJiBzY3JvbGwgPCBzY3JvbGxIZWlnaHQgLSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHNjcm9sbEVsLnNjcm9sbFRvcCA9IHNjcm9sbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCAxNSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW50cmFja1Njcm9sbCgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodHJhY2tUaW1lcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwZW5kRHJhZyhjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICAgIGxldCBjbG9uZTtcbiAgICAgIGlmIChbJ2xpJywgJ3RyJ10uc29tZSgodGFnKSA9PiBpc1RhZyhlbGVtZW50LCB0YWcpKSkge1xuICAgICAgICBjbG9uZSA9ICQoJzxkaXY+Jyk7XG4gICAgICAgIGFwcGVuZChjbG9uZSwgZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSkuY2hpbGRyZW4pO1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBlbGVtZW50LmdldEF0dHJpYnV0ZU5hbWVzKCkpIHtcbiAgICAgICAgICBhdHRyKGNsb25lLCBhdHRyaWJ1dGUsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9uZSA9IGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBhcHBlbmQoY29udGFpbmVyLCBjbG9uZSk7XG5cbiAgICAgIGNzcyhjbG9uZSwgJ21hcmdpbicsICcwJywgJ2ltcG9ydGFudCcpO1xuICAgICAgY3NzKGNsb25lLCB7XG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCxcbiAgICAgICAgcGFkZGluZzogY3NzKGVsZW1lbnQsICdwYWRkaW5nJykgfSk7XG5cblxuICAgICAgaGVpZ2h0KGNsb25lLmZpcnN0RWxlbWVudENoaWxkLCBoZWlnaHQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkpO1xuXG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZFRhcmdldChpdGVtcywgcG9pbnQpIHtcbiAgICAgIHJldHVybiBpdGVtc1tmaW5kSW5kZXgoaXRlbXMsIChpdGVtKSA9PiBwb2ludEluUmVjdChwb2ludCwgaXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kSW5zZXJ0VGFyZ2V0KGxpc3QsIHRhcmdldCwgcGxhY2Vob2xkZXIsIHgsIHksIHNhbWVMaXN0KSB7XG4gICAgICBpZiAoIWNoaWxkcmVuKGxpc3QpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoIXNhbWVMaXN0KSB7XG4gICAgICAgIGlmICghaXNIb3Jpem9udGFsKGxpc3QsIHBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgIHJldHVybiB5IDwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDIgPyB0YXJnZXQgOiB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGxhY2Vob2xkZXJSZWN0ID0gcGxhY2Vob2xkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBzYW1lUm93ID0gbGluZXNJbnRlcnNlY3QoXG4gICAgICBbcmVjdC50b3AsIHJlY3QuYm90dG9tXSxcbiAgICAgIFtwbGFjZWhvbGRlclJlY3QudG9wLCBwbGFjZWhvbGRlclJlY3QuYm90dG9tXSk7XG5cblxuICAgICAgY29uc3QgcG9pbnRlclBvcyA9IHNhbWVSb3cgPyB4IDogeTtcbiAgICAgIGNvbnN0IGxlbmd0aFByb3AgPSBzYW1lUm93ID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgY29uc3Qgc3RhcnRQcm9wID0gc2FtZVJvdyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgY29uc3QgZW5kUHJvcCA9IHNhbWVSb3cgPyAncmlnaHQnIDogJ2JvdHRvbSc7XG5cbiAgICAgIGNvbnN0IGRpZmYgPVxuICAgICAgcGxhY2Vob2xkZXJSZWN0W2xlbmd0aFByb3BdIDwgcmVjdFtsZW5ndGhQcm9wXSA/XG4gICAgICByZWN0W2xlbmd0aFByb3BdIC0gcGxhY2Vob2xkZXJSZWN0W2xlbmd0aFByb3BdIDpcbiAgICAgIDA7XG5cbiAgICAgIGlmIChwbGFjZWhvbGRlclJlY3Rbc3RhcnRQcm9wXSA8IHJlY3Rbc3RhcnRQcm9wXSkge1xuICAgICAgICBpZiAoZGlmZiAmJiBwb2ludGVyUG9zIDwgcmVjdFtzdGFydFByb3BdICsgZGlmZikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlmZiAmJiBwb2ludGVyUG9zID4gcmVjdFtlbmRQcm9wXSAtIGRpZmYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSG9yaXpvbnRhbChsaXN0LCBwbGFjZWhvbGRlcikge1xuICAgICAgY29uc3Qgc2luZ2xlID0gY2hpbGRyZW4obGlzdCkubGVuZ3RoID09PSAxO1xuXG4gICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgIGFwcGVuZChsaXN0LCBwbGFjZWhvbGRlcik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGl0ZW1zID0gY2hpbGRyZW4obGlzdCk7XG4gICAgICBjb25zdCBpc0hvcml6b250YWwgPSBpdGVtcy5zb21lKChlbCwgaSkgPT4ge1xuICAgICAgICBjb25zdCByZWN0QSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gaXRlbXMuc2xpY2UoaSArIDEpLnNvbWUoKGVsKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVjdEIgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICByZXR1cm4gIWxpbmVzSW50ZXJzZWN0KFtyZWN0QS5sZWZ0LCByZWN0QS5yaWdodF0sIFtyZWN0Qi5sZWZ0LCByZWN0Qi5yaWdodF0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgIHJlbW92ZSQxKHBsYWNlaG9sZGVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzSG9yaXpvbnRhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lc0ludGVyc2VjdChsaW5lQSwgbGluZUIpIHtcbiAgICAgIHJldHVybiBsaW5lQVsxXSA+IGxpbmVCWzBdICYmIGxpbmVCWzFdID4gbGluZUFbMF07XG4gICAgfVxuXG4gICAgdmFyIHRvb2x0aXAgPSB7XG4gICAgICBtaXhpbnM6IFtDb250YWluZXIsIFRvZ2dsYWJsZSwgUG9zaXRpb25dLFxuXG4gICAgICBhcmdzOiAndGl0bGUnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBkZWxheTogTnVtYmVyLFxuICAgICAgICB0aXRsZTogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBwb3M6ICd0b3AnLFxuICAgICAgICB0aXRsZTogJycsXG4gICAgICAgIGRlbGF5OiAwLFxuICAgICAgICBhbmltYXRpb246IFsndWstYW5pbWF0aW9uLXNjYWxlLXVwJ10sXG4gICAgICAgIGR1cmF0aW9uOiAxMDAsXG4gICAgICAgIGNsczogJ3VrLWFjdGl2ZScgfSxcblxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLmlkID0gXCJ1ay10b29sdGlwLVwiICsgdGhpcy5fdWlkO1xuICAgICAgICB0aGlzLl9oYXNUaXRsZSA9IGhhc0F0dHIodGhpcy4kZWwsICd0aXRsZScpO1xuICAgICAgICBhdHRyKHRoaXMuJGVsLCB7XG4gICAgICAgICAgdGl0bGU6ICcnLFxuICAgICAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogdGhpcy5pZCB9KTtcblxuICAgICAgICBtYWtlRm9jdXNhYmxlKHRoaXMuJGVsKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIGF0dHIodGhpcy4kZWwsICd0aXRsZScsIHRoaXMuX2hhc1RpdGxlID8gdGhpcy50aXRsZSA6IG51bGwpO1xuICAgICAgfSxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBzaG93KCkge1xuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCh0aGlzLnRvb2x0aXAgfHwgbnVsbCkgfHwgIXRoaXMudGl0bGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl91bmJpbmQgPSBvbmNlKFxuICAgICAgICAgIGRvY3VtZW50LCBcImtleWRvd24gXCIgK1xuICAgICAgICAgIHBvaW50ZXJEb3duJDEsXG4gICAgICAgICAgdGhpcy5oaWRlLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIChlKSA9PlxuICAgICAgICAgIGUudHlwZSA9PT0gcG9pbnRlckRvd24kMSAmJiAhd2l0aGluKGUudGFyZ2V0LCB0aGlzLiRlbCkgfHxcbiAgICAgICAgICBlLnR5cGUgPT09ICdrZXlkb3duJyAmJiBlLmtleUNvZGUgPT09IDI3KTtcblxuXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2hvd1RpbWVyKTtcbiAgICAgICAgICB0aGlzLnNob3dUaW1lciA9IHNldFRpbWVvdXQodGhpcy5fc2hvdywgdGhpcy5kZWxheSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXN5bmMgaGlkZSgpIHtcbiAgICAgICAgICBpZiAobWF0Y2hlcyh0aGlzLiRlbCwgJ2lucHV0OmZvY3VzJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zaG93VGltZXIpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmlzVG9nZ2xlZCh0aGlzLnRvb2x0aXAgfHwgbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy50b29sdGlwLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgIHJlbW92ZSQxKHRoaXMudG9vbHRpcCk7XG4gICAgICAgICAgdGhpcy50b29sdGlwID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl91bmJpbmQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2hvdygpIHtcbiAgICAgICAgICB0aGlzLnRvb2x0aXAgPSBhcHBlbmQoXG4gICAgICAgICAgdGhpcy5jb250YWluZXIsIFwiPGRpdiBpZD1cXFwiXCIgK1xuICAgICAgICAgIHRoaXMuaWQgKyBcIlxcXCIgY2xhc3M9XFxcInVrLVwiICsgdGhpcy4kb3B0aW9ucy5uYW1lICsgXCJcXFwiIHJvbGU9XFxcInRvb2x0aXBcXFwiPiA8ZGl2IGNsYXNzPVxcXCJ1ay1cIiArXG4gICAgICAgICAgdGhpcy4kb3B0aW9ucy5uYW1lICsgXCItaW5uZXJcXFwiPlwiICsgdGhpcy50aXRsZSArIFwiPC9kaXY+IDwvZGl2PlwiKTtcblxuXG5cbiAgICAgICAgICBvbih0aGlzLnRvb2x0aXAsICd0b2dnbGVkJywgKGUsIHRvZ2dsZWQpID0+IHtcbiAgICAgICAgICAgIGlmICghdG9nZ2xlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25BdCh0aGlzLnRvb2x0aXAsIHRoaXMuJGVsKTtcblxuICAgICAgICAgICAgY29uc3QgW2RpciwgYWxpZ25dID0gZ2V0QWxpZ25tZW50KHRoaXMudG9vbHRpcCwgdGhpcy4kZWwsIHRoaXMucG9zKTtcblxuICAgICAgICAgICAgdGhpcy5vcmlnaW4gPVxuICAgICAgICAgICAgdGhpcy5heGlzID09PSAneScgP1xuICAgICAgICAgICAgZmxpcFBvc2l0aW9uKGRpcikgKyBcIi1cIiArIGFsaWduIDpcbiAgICAgICAgICAgIGFsaWduICsgXCItXCIgKyBmbGlwUG9zaXRpb24oZGlyKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLnRvb2x0aXAsIHRydWUpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGZvY3VzOiAnc2hvdycsXG4gICAgICAgIGJsdXI6ICdoaWRlJyxcblxuICAgICAgICBbcG9pbnRlckVudGVyICsgXCIgXCIgKyBwb2ludGVyTGVhdmVdKGUpIHtcbiAgICAgICAgICBpZiAoIWlzVG91Y2goZSkpIHtcbiAgICAgICAgICAgIHRoaXNbZS50eXBlID09PSBwb2ludGVyRW50ZXIgPyAnc2hvdycgOiAnaGlkZSddKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENsaWNraW5nIGEgYnV0dG9uIGRvZXMgbm90IGdpdmUgaXQgZm9jdXMgb24gYWxsIGJyb3dzZXJzIGFuZCBwbGF0Zm9ybXNcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2J1dHRvbiNjbGlja2luZ19hbmRfZm9jdXNcbiAgICAgICAgW3BvaW50ZXJEb3duJDFdKGUpIHtcbiAgICAgICAgICBpZiAoaXNUb3VjaChlKSkge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBtYWtlRm9jdXNhYmxlKGVsKSB7XG4gICAgICBpZiAoIWlzRm9jdXNhYmxlKGVsKSkge1xuICAgICAgICBhdHRyKGVsLCAndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEFsaWdubWVudChlbCwgdGFyZ2V0LCBfcmVmKSB7bGV0IFtkaXIsIGFsaWduXSA9IF9yZWY7XG4gICAgICBjb25zdCBlbE9mZnNldCA9IG9mZnNldChlbCk7XG4gICAgICBjb25zdCB0YXJnZXRPZmZzZXQgPSBvZmZzZXQodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBbXG4gICAgICBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgIFsndG9wJywgJ2JvdHRvbSddXTtcblxuXG4gICAgICBmb3IgKGNvbnN0IHByb3BzIG9mIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKGVsT2Zmc2V0W3Byb3BzWzBdXSA+PSB0YXJnZXRPZmZzZXRbcHJvcHNbMV1dKSB7XG4gICAgICAgICAgZGlyID0gcHJvcHNbMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsT2Zmc2V0W3Byb3BzWzFdXSA8PSB0YXJnZXRPZmZzZXRbcHJvcHNbMF1dKSB7XG4gICAgICAgICAgZGlyID0gcHJvcHNbMF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvcHMgPSBpbmNsdWRlcyhwcm9wZXJ0aWVzWzBdLCBkaXIpID8gcHJvcGVydGllc1sxXSA6IHByb3BlcnRpZXNbMF07XG4gICAgICBpZiAoZWxPZmZzZXRbcHJvcHNbMF1dID09PSB0YXJnZXRPZmZzZXRbcHJvcHNbMF1dKSB7XG4gICAgICAgIGFsaWduID0gcHJvcHNbMF07XG4gICAgICB9IGVsc2UgaWYgKGVsT2Zmc2V0W3Byb3BzWzFdXSA9PT0gdGFyZ2V0T2Zmc2V0W3Byb3BzWzFdXSkge1xuICAgICAgICBhbGlnbiA9IHByb3BzWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtkaXIsIGFsaWduXTtcbiAgICB9XG5cbiAgICB2YXIgdXBsb2FkID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgYWxsb3c6IFN0cmluZyxcbiAgICAgICAgY2xzRHJhZ292ZXI6IFN0cmluZyxcbiAgICAgICAgY29uY3VycmVudDogTnVtYmVyLFxuICAgICAgICBtYXhTaXplOiBOdW1iZXIsXG4gICAgICAgIG1ldGhvZDogU3RyaW5nLFxuICAgICAgICBtaW1lOiBTdHJpbmcsXG4gICAgICAgIG1zZ0ludmFsaWRNaW1lOiBTdHJpbmcsXG4gICAgICAgIG1zZ0ludmFsaWROYW1lOiBTdHJpbmcsXG4gICAgICAgIG1zZ0ludmFsaWRTaXplOiBTdHJpbmcsXG4gICAgICAgIG11bHRpcGxlOiBCb29sZWFuLFxuICAgICAgICBuYW1lOiBTdHJpbmcsXG4gICAgICAgIHBhcmFtczogT2JqZWN0LFxuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHVybDogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBhbGxvdzogZmFsc2UsXG4gICAgICAgIGNsc0RyYWdvdmVyOiAndWstZHJhZ292ZXInLFxuICAgICAgICBjb25jdXJyZW50OiAxLFxuICAgICAgICBtYXhTaXplOiAwLFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgbWltZTogZmFsc2UsXG4gICAgICAgIG1zZ0ludmFsaWRNaW1lOiAnSW52YWxpZCBGaWxlIFR5cGU6ICVzJyxcbiAgICAgICAgbXNnSW52YWxpZE5hbWU6ICdJbnZhbGlkIEZpbGUgTmFtZTogJXMnLFxuICAgICAgICBtc2dJbnZhbGlkU2l6ZTogJ0ludmFsaWQgRmlsZSBTaXplOiAlcyBLaWxvYnl0ZXMgTWF4JyxcbiAgICAgICAgbXVsdGlwbGU6IGZhbHNlLFxuICAgICAgICBuYW1lOiAnZmlsZXNbXScsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIHR5cGU6ICcnLFxuICAgICAgICB1cmw6ICcnLFxuICAgICAgICBhYm9ydDogbm9vcCxcbiAgICAgICAgYmVmb3JlQWxsOiBub29wLFxuICAgICAgICBiZWZvcmVTZW5kOiBub29wLFxuICAgICAgICBjb21wbGV0ZTogbm9vcCxcbiAgICAgICAgY29tcGxldGVBbGw6IG5vb3AsXG4gICAgICAgIGVycm9yOiBub29wLFxuICAgICAgICBmYWlsOiBub29wLFxuICAgICAgICBsb2FkOiBub29wLFxuICAgICAgICBsb2FkRW5kOiBub29wLFxuICAgICAgICBsb2FkU3RhcnQ6IG5vb3AsXG4gICAgICAgIHByb2dyZXNzOiBub29wIH0sXG5cblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGNoYW5nZShlKSB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVzKGUudGFyZ2V0LCAnaW5wdXRbdHlwZT1cImZpbGVcIl0nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmIChlLnRhcmdldC5maWxlcykge1xuICAgICAgICAgICAgdGhpcy51cGxvYWQoZS50YXJnZXQuZmlsZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGUudGFyZ2V0LnZhbHVlID0gJyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJvcChlKSB7XG4gICAgICAgICAgc3RvcChlKTtcblxuICAgICAgICAgIGNvbnN0IHRyYW5zZmVyID0gZS5kYXRhVHJhbnNmZXI7XG5cbiAgICAgICAgICBpZiAoISh0cmFuc2ZlciAhPSBudWxsICYmIHRyYW5zZmVyLmZpbGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0RyYWdvdmVyKTtcblxuICAgICAgICAgIHRoaXMudXBsb2FkKHRyYW5zZmVyLmZpbGVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkcmFnZW50ZXIoZSkge1xuICAgICAgICAgIHN0b3AoZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJhZ292ZXIoZSkge1xuICAgICAgICAgIHN0b3AoZSk7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRHJhZ292ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyYWdsZWF2ZShlKSB7XG4gICAgICAgICAgc3RvcChlKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcmFnb3Zlcik7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIHVwbG9hZChmaWxlcykge1xuICAgICAgICAgIGZpbGVzID0gdG9BcnJheShmaWxlcyk7XG5cbiAgICAgICAgICBpZiAoIWZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICd1cGxvYWQnLCBbZmlsZXNdKTtcblxuICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMubWF4U2l6ZSAmJiB0aGlzLm1heFNpemUgKiAxMDAwIDwgZmlsZS5zaXplKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmFpbCh0aGlzLm1zZ0ludmFsaWRTaXplLnJlcGxhY2UoJyVzJywgdGhpcy5tYXhTaXplKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3cgJiYgIW1hdGNoKHRoaXMuYWxsb3csIGZpbGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5mYWlsKHRoaXMubXNnSW52YWxpZE5hbWUucmVwbGFjZSgnJXMnLCB0aGlzLmFsbG93KSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMubWltZSAmJiAhbWF0Y2godGhpcy5taW1lLCBmaWxlLnR5cGUpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmFpbCh0aGlzLm1zZ0ludmFsaWRNaW1lLnJlcGxhY2UoJyVzJywgdGhpcy5taW1lKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGZpbGVzID0gZmlsZXMuc2xpY2UoMCwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5iZWZvcmVBbGwodGhpcywgZmlsZXMpO1xuXG4gICAgICAgICAgY29uc3QgY2h1bmtzID0gY2h1bmsoZmlsZXMsIHRoaXMuY29uY3VycmVudCk7XG4gICAgICAgICAgY29uc3QgdXBsb2FkID0gYXN5bmMgKGZpbGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAgICAgICAgIGZpbGVzLmZvckVhY2goKGZpbGUpID0+IGRhdGEuYXBwZW5kKHRoaXMubmFtZSwgZmlsZSkpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLnBhcmFtcykge1xuICAgICAgICAgICAgICBkYXRhLmFwcGVuZChrZXksIHRoaXMucGFyYW1zW2tleV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCB4aHIgPSBhd2FpdCBhamF4KHRoaXMudXJsLCB7XG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIGJlZm9yZVNlbmQ6IChlbnYpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHsgeGhyIH0gPSBlbnY7XG4gICAgICAgICAgICAgICAgICB4aHIudXBsb2FkICYmIG9uKHhoci51cGxvYWQsICdwcm9ncmVzcycsIHRoaXMucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIFsnbG9hZFN0YXJ0JywgJ2xvYWQnLCAnbG9hZEVuZCcsICdhYm9ydCddKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uKHhociwgdHlwZS50b0xvd2VyQ2FzZSgpLCB0aGlzW3R5cGVdKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2VuZChlbnYpO1xuICAgICAgICAgICAgICAgIH0gfSk7XG5cblxuICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlKHhocik7XG5cbiAgICAgICAgICAgICAgaWYgKGNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB1cGxvYWQoY2h1bmtzLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVBbGwoeGhyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBhd2FpdCB1cGxvYWQoY2h1bmtzLnNoaWZ0KCkpO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBtYXRjaChwYXR0ZXJuLCBwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5tYXRjaChcbiAgICAgIG5ldyBSZWdFeHAoXCJeXCIgK1xuICAgICAgcGF0dGVybi5cbiAgICAgIHJlcGxhY2UoL1xcLy9nLCAnXFxcXC8nKS5cbiAgICAgIHJlcGxhY2UoL1xcKlxcKi9nLCAnKFxcXFwvW15cXFxcL10rKSonKS5cbiAgICAgIHJlcGxhY2UoL1xcKi9nLCAnW15cXFxcL10rJykuXG4gICAgICByZXBsYWNlKC8oKD8hXFxcXCkpXFw/L2csICckMS4nKSArIFwiJFwiLFxuICAgICAgJ2knKSk7XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNodW5rKGZpbGVzLCBzaXplKSB7XG4gICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpICs9IHNpemUpIHtcbiAgICAgICAgY2h1bmtzLnB1c2goZmlsZXMuc2xpY2UoaSwgaSArIHNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaHVua3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RvcChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIENvdW50ZG93bjogY291bnRkb3duLFxuICAgICAgICBGaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgTGlnaHRib3g6IGxpZ2h0Ym94LFxuICAgICAgICBMaWdodGJveFBhbmVsOiBMaWdodGJveFBhbmVsLFxuICAgICAgICBOb3RpZmljYXRpb246IG5vdGlmaWNhdGlvbixcbiAgICAgICAgUGFyYWxsYXg6IHBhcmFsbGF4LFxuICAgICAgICBTbGlkZXI6IHNsaWRlcixcbiAgICAgICAgU2xpZGVyUGFyYWxsYXg6IHNsaWRlclBhcmFsbGF4LFxuICAgICAgICBTbGlkZXNob3c6IHNsaWRlc2hvdyxcbiAgICAgICAgU2xpZGVzaG93UGFyYWxsYXg6IHNsaWRlclBhcmFsbGF4LFxuICAgICAgICBTb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgIFRvb2x0aXA6IHRvb2x0aXAsXG4gICAgICAgIFVwbG9hZDogdXBsb2FkXG4gICAgfSk7XG5cbiAgICBlYWNoKGNvbXBvbmVudHMsIChjb21wb25lbnQsIG5hbWUpID0+IFVJa2l0LmNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpKTtcblxuICAgIHJldHVybiBVSWtpdDtcblxufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uikit/dist/js/uikit.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/style/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;